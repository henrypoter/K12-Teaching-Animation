<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA半保留复制叉实时动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ecf0f1;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            max-width: 900px;
            width: 100%;
        }
        
        h1 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 2.2rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            max-width: 1200px;
            width: 100%;
            gap: 20px;
            justify-content: center;
        }
        
        .animation-area {
            flex: 1;
            min-width: 700px;
            background-color: rgba(44, 62, 80, 0.7);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background-color: #2c3e50;
            border: 1px solid #34495e;
        }
        
        #dnaCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .info-panel {
            width: 300px;
            background-color: rgba(44, 62, 80, 0.7);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            color: #3498db;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3498db;
        }
        
        .control-panel {
            background-color: rgba(52, 73, 94, 0.8);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-title {
            color: #ecf0f1;
            font-size: 1.1rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .control-title i {
            margin-right: 8px;
            color: #3498db;
        }
        
        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 70px;
        }
        
        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.secondary {
            background-color: #7f8c8d;
        }
        
        button.secondary:hover {
            background-color: #95a5a6;
        }
        
        button.highlight {
            background-color: #e74c3c;
        }
        
        button.highlight:hover {
            background-color: #c0392b;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-label {
            min-width: 80px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: #34495e;
            border-radius: 4px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .legend {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #34495e;
        }
        
        .legend-title {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            border-radius: 2px;
        }
        
        .current-info {
            flex: 1;
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(52, 73, 94, 0.8);
            border-radius: 8px;
            overflow-y: auto;
            max-height: 200px;
        }
        
        .info-title {
            color: #2ecc71;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .info-content {
            line-height: 1.5;
            font-size: 0.95rem;
        }
        
        .stage-indicator {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(52, 73, 94, 0.6);
            border-radius: 8px;
        }
        
        .stage {
            text-align: center;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .stage.active {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        
        .footer {
            margin-top: 20px;
            text-align: center;
            color: #7f8c8d;
            font-size: 0.9rem;
            max-width: 900px;
            width: 100%;
            padding-top: 15px;
            border-top: 1px solid #34495e;
        }
        
        @media (max-width: 1100px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .animation-area, .info-panel {
                min-width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DNA半保留复制叉实时动画</h1>
        <p class="subtitle">交互式教学动画 - 展示DNA复制过程中复制叉的动态推进与半保留机制</p>
    </div>
    
    <div class="container">
        <div class="animation-area">
            <div class="canvas-container">
                <canvas id="dnaCanvas"></canvas>
            </div>
            
            <div class="stage-indicator">
                <div class="stage" id="stage1">起始</div>
                <div class="stage" id="stage2">解旋</div>
                <div class="stage" id="stage3">引物合成</div>
                <div class="stage" id="stage4">链延伸</div>
                <div class="stage" id="stage5">连接完成</div>
            </div>
        </div>
        
        <div class="info-panel">
            <h2 class="panel-title">控制面板</h2>
            
            <div class="control-panel">
                <div class="control-group">
                    <div class="control-title">动画控制</div>
                    <div class="buttons">
                        <button id="playBtn">▶ 播放</button>
                        <button id="pauseBtn">⏸ 暂停</button>
                        <button id="resetBtn">↺ 重置</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">帧控制</div>
                    <div class="buttons">
                        <button id="prevBtn">◀ 上一帧</button>
                        <button id="nextBtn">下一帧 ▶</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">速度控制</div>
                    <div class="slider-container">
                        <span class="slider-label">慢</span>
                        <input type="range" id="speedSlider" min="0.5" max="3" step="0.5" value="1">
                        <span class="slider-label">快</span>
                    </div>
                    <div style="text-align: center; margin-top: 5px; font-size: 0.9rem;">
                        当前速度: <span id="speedValue">1.0x</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">阶段跳转</div>
                    <div class="buttons">
                        <button class="secondary" data-stage="0">起始</button>
                        <button class="secondary" data-stage="1">解旋</button>
                        <button class="secondary" data-stage="2">引物合成</button>
                        <button class="secondary" data-stage="3">链延伸</button>
                        <button class="secondary" data-stage="4">连接完成</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">显示选项</div>
                    <div class="checkbox-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="labelsToggle" checked>
                            <label for="labelsToggle">显示标签</label>
                        </div>
                        <div class="checkbox-item">
                            <input type="checkbox" id="highlightTemplate">
                            <label for="highlightTemplate">高亮模板链</label>
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-title">概念强化</div>
                    <div class="buttons">
                        <button class="highlight" id="showResultBtn">展示半保留结果</button>
                    </div>
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-title">图例说明</div>
                <div class="legend-items">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2E5A88;"></div>
                        <span>亲代DNA链1</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #6C9BCF;"></div>
                        <span>亲代DNA链2</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #FF9800;"></div>
                        <span>前导链（新）</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #E53935;"></div>
                        <span>滞后链（新）</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #FFEB3B;"></div>
                        <span>RNA引物</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9C27B0;"></div>
                        <span>解旋酶</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4CAF50;"></div>
                        <span>单链结合蛋白</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #F57C00;"></div>
                        <span>DNA聚合酶</span>
                    </div>
                </div>
            </div>
            
            <div class="current-info">
                <div class="info-title" id="currentStepTitle">起始状态</div>
                <div class="info-content" id="currentStepInfo">
                    点击动画中的元素查看详细信息，或使用控制面板操作动画。
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>DNA半保留复制教学动画 | 设计用于生物学教学 | 交互式可视化演示</p>
    </div>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('dnaCanvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // 初始调整尺寸
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 动画状态
        let animationState = {
            isPlaying: false,
            currentFrame: 0,
            totalFrames: 300,
            speed: 1.0,
            showLabels: true,
            highlightTemplate: false,
            showResult: false
        };
        
        // DNA复制状态
        let dnaState = {
            // 亲代DNA链
            parentStrand1: { x: 100, y: 300, length: 400, angle: 0, bases: 40 },
            parentStrand2: { x: 100, y: 300, length: 400, angle: Math.PI, bases: 40 },
            
            // 复制叉位置
            forkX: 200,
            forkProgress: 0, // 0到1，表示复制叉推进进度
            
            // 解旋酶
            helicase: { x: 200, y: 300, active: false },
            
            // 单链结合蛋白
            ssbProteins: [],
            
            // RNA引物
            rnaPrimers: [],
            
            // 前导链（连续合成）
            leadingStrand: { segments: [] },
            
            // 滞后链（冈崎片段）
            laggingStrand: { okazakiFragments: [] },
            
            // DNA聚合酶
            dnaPolymeraseLeading: { x: 0, y: 0, active: false },
            dnaPolymeraseLagging: { x: 0, y: 0, active: false },
            
            // 连接酶
            ligase: { x: 0, y: 0, active: false }
        };
        
        // 颜色定义
        const colors = {
            parentStrand1: '#2E5A88',    // 深蓝
            parentStrand2: '#6C9BCF',    // 浅蓝
            leadingStrand: '#FF9800',    // 橙色
            laggingStrand: '#E53935',    // 红色
            rnaPrimer: '#FFEB3B',        // 黄色
            helicase: '#9C27B0',         // 紫色
            ssbProtein: '#4CAF50',       // 绿色
            dnaPolymerase: '#F57C00',    // 深橙色
            primerase: '#E91E63',        // 亮粉色
            ligase: '#00BCD4',           // 青色
            background: '#2c3e50',       // 深灰蓝
            grid: '#34495e'              // 中灰蓝
        };
        
        // 动画阶段定义
        const stages = [
            { name: "起始", frame: 0, description: "DNA双螺旋结构完整，准备开始复制。" },
            { name: "解旋", frame: 60, description: "解旋酶结合到DNA上，开始解开双螺旋结构，形成复制叉。" },
            { name: "引物合成", frame: 120, description: "引物酶在两条模板链上合成RNA引物，为DNA合成提供起点。" },
            { name: "链延伸", frame: 180, description: "DNA聚合酶以RNA引物为起点，合成新的DNA链。前导链连续合成，滞后链以冈崎片段形式不连续合成。" },
            { name: "连接完成", frame: 240, description: "DNA连接酶将冈崎片段连接起来，形成完整的滞后链。复制完成，产生两个半保留的子代DNA分子。" }
        ];
        
        // 当前阶段索引
        let currentStageIndex = 0;
        
        // 初始化DNA状态
        function initDNAState() {
            dnaState = {
                parentStrand1: { x: 100, y: canvas.height / 2, length: 400, angle: 0, bases: 40 },
                parentStrand2: { x: 100, y: canvas.height / 2, length: 400, angle: Math.PI, bases: 40 },
                forkX: 200,
                forkProgress: 0,
                helicase: { x: 200, y: canvas.height / 2, active: false },
                ssbProteins: [],
                rnaPrimers: [],
                leadingStrand: { segments: [] },
                laggingStrand: { okazakiFragments: [] },
                dnaPolymeraseLeading: { x: 0, y: 0, active: false },
                dnaPolymeraseLagging: { x: 0, y: 0, active: false },
                ligase: { x: 0, y: 0, active: false }
            };
        }
        
        // 更新DNA状态基于当前帧
        function updateDNAState() {
            const frame = animationState.currentFrame;
            const progress = frame / animationState.totalFrames;
            
            // 更新复制叉位置
            dnaState.forkProgress = progress;
            dnaState.forkX = 200 + progress * 300;
            
            // 更新解旋酶
            if (frame >= 20) {
                dnaState.helicase.active = true;
                dnaState.helicase.x = dnaState.forkX - 20;
                dnaState.helicase.y = canvas.height / 2;
            }
            
            // 更新单链结合蛋白
            if (frame >= 40 && frame % 15 === 0 && dnaState.ssbProteins.length < 8) {
                const offset = (dnaState.ssbProteins.length % 4) * 30;
                dnaState.ssbProteins.push({
                    x: dnaState.forkX + 30 + offset,
                    y: canvas.height / 2 + (dnaState.ssbProteins.length < 4 ? -25 : 25),
                    id: dnaState.ssbProteins.length
                });
            }
            
            // 更新RNA引物
            if (frame >= 80) {
                // 前导链引物
                if (dnaState.rnaPrimers.length < 1) {
                    dnaState.rnaPrimers.push({
                        x: dnaState.forkX - 40,
                        y: canvas.height / 2 - 25,
                        length: 20,
                        type: 'leading'
                    });
                }
                
                // 滞后链引物（多个）
                if (frame >= 100 && frame % 40 === 0 && dnaState.rnaPrimers.length < 4) {
                    dnaState.rnaPrimers.push({
                        x: dnaState.forkX - 80 - (dnaState.rnaPrimers.length * 60),
                        y: canvas.height / 2 + 25,
                        length: 20,
                        type: 'lagging'
                    });
                }
            }
            
            // 更新前导链
            if (frame >= 100) {
                const leadingLength = Math.min(300, (frame - 100) * 2);
                dnaState.leadingStrand.segments = [{
                    x: dnaState.forkX - 40 - leadingLength,
                    y: canvas.height / 2 - 25,
                    length: leadingLength,
                    progress: Math.min(1, (frame - 100) / 100)
                }];
                
                // 更新前导链DNA聚合酶
                dnaState.dnaPolymeraseLeading.active = true;
                dnaState.dnaPolymeraseLeading.x = dnaState.forkX - 40;
                dnaState.dnaPolymeraseLeading.y = canvas.height / 2 - 25;
            }
            
            // 更新滞后链（冈崎片段）
            if (frame >= 120) {
                const fragmentCount = Math.min(3, Math.floor((frame - 120) / 40));
                dnaState.laggingStrand.okazakiFragments = [];
                
                for (let i = 0; i < fragmentCount; i++) {
                    const fragmentProgress = Math.min(1, (frame - 120 - i * 40) / 30);
                    dnaState.laggingStrand.okazakiFragments.push({
                        x: dnaState.forkX - 80 - i * 60,
                        y: canvas.height / 2 + 25,
                        length: 50,
                        progress: fragmentProgress,
                        id: i
                    });
                }
                
                // 更新滞后链DNA聚合酶
                if (fragmentCount > 0 && fragmentProgress < 1) {
                    dnaState.dnaPolymeraseLagging.active = true;
                    dnaState.dnaPolymeraseLagging.x = dnaState.forkX - 80 - (fragmentCount - 1) * 60 + 50 * fragmentProgress;
                    dnaState.dnaPolymeraseLagging.y = canvas.height / 2 + 25;
                } else {
                    dnaState.dnaPolymeraseLagging.active = false;
                }
            }
            
            // 更新连接酶
            if (frame >= 200) {
                dnaState.ligase.active = true;
                dnaState.ligase.x = dnaState.forkX - 150;
                dnaState.ligase.y = canvas.height / 2 + 25;
            }
            
            // 更新当前阶段
            updateCurrentStage();
        }
        
        // 更新当前阶段
        function updateCurrentStage() {
            const frame = animationState.currentFrame;
            for (let i = stages.length - 1; i >= 0; i--) {
                if (frame >= stages[i].frame) {
                    if (currentStageIndex !== i) {
                        currentStageIndex = i;
                        updateStageIndicator();
                        updateStepInfo(stages[i].name, stages[i].description);
                    }
                    break;
                }
            }
        }
        
        // 更新阶段指示器
        function updateStageIndicator() {
            const stageElements = document.querySelectorAll('.stage');
            stageElements.forEach((el, index) => {
                if (index === currentStageIndex) {
                    el.classList.add('active');
                } else {
                    el.classList.remove('active');
                }
            });
        }
        
        // 绘制网格背景
        function drawGrid() {
            ctx.strokeStyle = colors.grid;
            ctx.lineWidth = 0.5;
            
            // 垂直线
            for (let x = 50; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 水平线
            for (let y = 50; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // 绘制DNA双螺旋
        function drawDNA() {
            const centerY = canvas.height / 2;
            const startX = 100;
            const endX = dnaState.forkX;
            const length = endX - startX;
            
            // 绘制未解旋的DNA双螺旋
            ctx.lineWidth = 3;
            
            // 第一条链（深蓝）
            ctx.strokeStyle = animationState.highlightTemplate ? '#FFFFFF' : colors.parentStrand1;
            ctx.beginPath();
            for (let i = 0; i <= length; i += 10) {
                const x = startX + i;
                const y = centerY + 15 * Math.sin(i / 20);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 第二条链（浅蓝）
            ctx.strokeStyle = animationState.highlightTemplate ? '#FFFFFF' : colors.parentStrand2;
            ctx.beginPath();
            for (let i = 0; i <= length; i += 10) {
                const x = startX + i;
                const y = centerY + 15 * Math.sin(i / 20 + Math.PI);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // 绘制碱基对（连接线）
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= length; i += 20) {
                const x = startX + i;
                const y1 = centerY + 15 * Math.sin(i / 20);
                const y2 = centerY + 15 * Math.sin(i / 20 + Math.PI);
                
                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x, y2);
                ctx.stroke();
            }
            
            // 绘制解旋后的单链
            const singleStrandLength = 150;
            
            // 上方的单链（模板用于前导链）
            ctx.strokeStyle = animationState.highlightTemplate ? '#FFFFFF' : colors.parentStrand1;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(endX, centerY + 15 * Math.sin(length / 20));
            ctx.lineTo(endX + singleStrandLength, centerY - 40);
            ctx.stroke();
            
            // 下方的单链（模板用于滞后链）
            ctx.strokeStyle = animationState.highlightTemplate ? '#FFFFFF' : colors.parentStrand2;
            ctx.beginPath();
            ctx.moveTo(endX, centerY + 15 * Math.sin(length / 20 + Math.PI));
            ctx.lineTo(endX + singleStrandLength, centerY + 40);
            ctx.stroke();
            
            // 绘制复制叉指示器
            ctx.fillStyle = '#E74C3C';
            ctx.beginPath();
            ctx.arc(endX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            if (animationState.showLabels) {
                ctx.fillStyle = '#ECF0F1';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('复制叉', endX, centerY - 20);
            }
        }
        
        // 绘制解旋酶
        function drawHelicase() {
            if (!dnaState.helicase.active) return;
            
            const x = dnaState.helicase.x;
            const y = dnaState.helicase.y;
            
            // 绘制解旋酶主体（楔形）
            ctx.fillStyle = colors.helicase;
            ctx.beginPath();
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x + 30, y);
            ctx.lineTo(x, y + 15);
            ctx.closePath();
            ctx.fill();
            
            // 绘制解旋酶细节
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            if (animationState.showLabels) {
                ctx.fillStyle = '#ECF0F1';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('解旋酶', x + 15, y - 25);
            }
        }
        
        // 绘制单链结合蛋白
        function drawSSBProteins() {
            dnaState.ssbProteins.forEach(protein => {
                ctx.fillStyle = colors.ssbProtein;
                ctx.beginPath();
                ctx.arc(protein.x, protein.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制SSB文字
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('SSB', protein.x, protein.y);
                
                if (animationState.showLabels && protein.id === 0) {
                    ctx.fillStyle = '#ECF0F1';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('单链结合蛋白', protein.x, protein.y - 20);
                }
            });
        }
        
        // 绘制RNA引物
        function drawRNAPrimers() {
            dnaState.rnaPrimers.forEach(primer => {
                ctx.strokeStyle = colors.rnaPrimer;
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 3]); // 虚线表示RNA
                
                ctx.beginPath();
                ctx.moveTo(primer.x, primer.y);
                ctx.lineTo(primer.x + primer.length, primer.y);
                ctx.stroke();
                
                ctx.setLineDash([]); // 重置为实线
                
                if (animationState.showLabels && primer.type === 'leading') {
                    ctx.fillStyle = '#ECF0F1';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('RNA引物', primer.x + primer.length/2, primer.y - 15);
                }
            });
        }
        
        // 绘制前导链
        function drawLeadingStrand() {
            dnaState.leadingStrand.segments.forEach(segment => {
                const visibleLength = segment.length * segment.progress;
                
                ctx.strokeStyle = colors.leadingStrand;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(segment.x + segment.length - visibleLength, segment.y);
                ctx.lineTo(segment.x + segment.length, segment.y);
                ctx.stroke();
                
                // 绘制生长动画效果
                if (segment.progress < 1 && animationState.isPlaying) {
                    ctx.fillStyle = colors.leadingStrand;
                    ctx.beginPath();
                    ctx.arc(segment.x + segment.length, segment.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (animationState.showLabels && segment.progress > 0.5) {
                    ctx.fillStyle = '#ECF0F1';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('前导链', segment.x + segment.length/2, segment.y - 15);
                }
            });
        }
        
        // 绘制滞后链（冈崎片段）
        function drawLaggingStrand() {
            dnaState.laggingStrand.okazakiFragments.forEach(fragment => {
                const visibleLength = fragment.length * fragment.progress;
                
                ctx.strokeStyle = colors.laggingStrand;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(fragment.x, fragment.y);
                ctx.lineTo(fragment.x + visibleLength, fragment.y);
                ctx.stroke();
                
                // 绘制生长动画效果
                if (fragment.progress < 1 && animationState.isPlaying) {
                    ctx.fillStyle = colors.laggingStrand;
                    ctx.beginPath();
                    ctx.arc(fragment.x + visibleLength, fragment.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 标记冈崎片段
                if (animationState.showLabels && fragment.id === 0 && fragment.progress > 0.3) {
                    ctx.fillStyle = '#ECF0F1';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('冈崎片段', fragment.x + fragment.length/2, fragment.y + 20);
                }
            });
            
            // 绘制滞后链标签
            if (dnaState.laggingStrand.okazakiFragments.length > 0 && animationState.showLabels) {
                ctx.fillStyle = '#ECF0F1';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('滞后链', dnaState.forkX - 120, canvas.height / 2 + 50);
            }
        }
        
        // 绘制DNA聚合酶
        function drawDNAPolymerase() {
            // 前导链DNA聚合酶
            if (dnaState.dnaPolymeraseLeading.active) {
                const x = dnaState.dnaPolymeraseLeading.x;
                const y = dnaState.dnaPolymeraseLeading.y;
                
                ctx.fillStyle = colors.dnaPolymerase;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制聚合酶文字
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Pol', x, y);
                
                if (animationState.showLabels) {
                    ctx.fillStyle = '#ECF0F1';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('DNA聚合酶', x, y - 20);
                }
            }
            
            // 滞后链DNA聚合酶
            if (dnaState.dnaPolymeraseLagging.active) {
                const x = dnaState.dnaPolymeraseLagging.x;
                const y = dnaState.dnaPolymeraseLagging.y;
                
                ctx.fillStyle = colors.dnaPolymerase;
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制聚合酶文字
                ctx.fillStyle = '#FFFFFF';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Pol', x, y);
            }
        }
        
        // 绘制连接酶
        function drawLigase() {
            if (!dnaState.ligase.active) return;
            
            const x = dnaState.ligase.x;
            const y = dnaState.ligase.y;
            
            ctx.fillStyle = colors.ligase;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.P
<!--检测到代码截断，自动续写中...-->
* 2);
            ctx.fill();
            
            // 绘制连接酶文字
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Lig', x, y);
            
            if (animationState.showLabels) {
                ctx.fillStyle = '#ECF0F1';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('DNA连接酶', x, y - 20);
            }
        }
        
        // 绘制半保留结果展示
        function drawSemiConservativeResult() {
            if (!animationState.showResult) return;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // 绘制半透明背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制标题
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('半保留复制结果', centerX, 80);
            
            // 绘制第一个子代DNA分子
            const dna1Y = centerY - 80;
            drawDNAMolecule(centerX - 150, dna1Y, colors.parentStrand1, colors.leadingStrand, '子代DNA 1');
            
            // 绘制第二个子代DNA分子
            const dna2Y = centerY + 80;
            drawDNAMolecule(centerX - 150, dna2Y, colors.parentStrand2, colors.laggingStrand, '子代DNA 2');
            
            // 绘制图例说明
            ctx.fillStyle = '#ECF0F1';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('每个子代DNA分子包含一条亲代链（模板链）和一条新合成链', centerX, canvas.height - 60);
            ctx.fillText('这就是"半保留复制"的含义', centerX, canvas.height - 30);
        }
        
        // 绘制DNA分子（用于结果展示）
        function drawDNAMolecule(x, y, parentColor, newColor, label) {
            const length = 200;
            
            // 绘制亲代链（模板链）
            ctx.strokeStyle = parentColor;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= length; i += 10) {
                const px = x + i;
                const py = y + 15 * Math.sin(i / 20);
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            
            // 绘制新合成链
            ctx.strokeStyle = newColor;
            ctx.beginPath();
            for (let i = 0; i <= length; i += 10) {
                const px = x + i;
                const py = y + 15 * Math.sin(i / 20 + Math.PI);
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            
            // 绘制标签
            ctx.fillStyle = '#ECF0F1';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + length/2, y - 40);
            
            // 绘制链标识
            ctx.font = '14px Arial';
            ctx.fillStyle = parentColor;
            ctx.fillText('亲代链（模板）', x + length/2, y + 50);
            ctx.fillStyle = newColor;
            ctx.fillText('新合成链', x + length/2, y + 70);
        }
        
        // 绘制所有元素
        function draw() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景
            ctx.fillStyle = colors.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格
            drawGrid();
            
            // 绘制DNA
            drawDNA();
            
            // 绘制酶和蛋白
            drawHelicase();
            drawSSBProteins();
            drawRNAPrimers();
            drawDNAPolymerase();
            drawLigase();
            
            // 绘制新合成的链
            drawLeadingStrand();
            drawLaggingStrand();
            
            // 如果显示结果，绘制半保留结果
            if (animationState.showResult) {
                drawSemiConservativeResult();
            }
            
            // 绘制帧信息
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`帧: ${animationState.currentFrame}/${animationState.totalFrames}`, 20, 30);
            ctx.fillText(`阶段: ${stages[currentStageIndex].name}`, 20, 50);
        }
        
        // 动画循环
        function animate() {
            if (animationState.isPlaying) {
                animationState.currentFrame += animationState.speed;
                
                if (animationState.currentFrame >= animationState.totalFrames) {
                    animationState.currentFrame = animationState.totalFrames;
                    animationState.isPlaying = false;
                    document.getElementById('playBtn').textContent = '▶ 播放';
                }
                
                updateDNAState();
                draw();
            }
            
            requestAnimationFrame(animate);
        }
        
        // 开始动画循环
        animate();
        
        // 更新步骤信息
        function updateStepInfo(title, info) {
            document.getElementById('currentStepTitle').textContent = title;
            document.getElementById('currentStepInfo').textContent = info;
        }
        
        // 事件监听器设置
        function setupEventListeners() {
            // 播放按钮
            document.getElementById('playBtn').addEventListener('click', function() {
                animationState.isPlaying = !animationState.isPlaying;
                this.textContent = animationState.isPlaying ? '⏸ 暂停' : '▶ 播放';
                
                // 如果动画已结束，重置到开始
                if (animationState.currentFrame >= animationState.totalFrames) {
                    animationState.currentFrame = 0;
                    initDNAState();
                }
            });
            
            // 暂停按钮
            document.getElementById('pauseBtn').addEventListener('click', function() {
                animationState.isPlaying = false;
                document.getElementById('playBtn').textContent = '▶ 播放';
            });
            
            // 重置按钮
            document.getElementById('resetBtn').addEventListener('click', function() {
                animationState.isPlaying = false;
                animationState.currentFrame = 0;
                animationState.showResult = false;
                document.getElementById('playBtn').textContent = '▶ 播放';
                initDNAState();
                updateDNAState();
                draw();
                updateStepInfo("起始状态", "DNA双螺旋结构完整，准备开始复制。点击播放按钮开始动画。");
            });
            
            // 上一帧按钮
            document.getElementById('prevBtn').addEventListener('click', function() {
                animationState.isPlaying = false;
                document.getElementById('playBtn').textContent = '▶ 播放';
                animationState.currentFrame = Math.max(0, animationState.currentFrame - 1);
                updateDNAState();
                draw();
            });
            
            // 下一帧按钮
            document.getElementById('nextBtn').addEventListener('click', function() {
                animationState.isPlaying = false;
                document.getElementById('playBtn').textContent = '▶ 播放';
                animationState.currentFrame = Math.min(animationState.totalFrames, animationState.currentFrame + 1);
                updateDNAState();
                draw();
            });
            
            // 速度滑块
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            
            speedSlider.addEventListener('input', function() {
                animationState.speed = parseFloat(this.value);
                speedValue.textContent = this.value + 'x';
            });
            
            // 阶段跳转按钮
            document.querySelectorAll('button[data-stage]').forEach(button => {
                button.addEventListener('click', function() {
                    const stageIndex = parseInt(this.getAttribute('data-stage'));
                    animationState.currentFrame = stages[stageIndex].frame;
                    animationState.isPlaying = false;
                    document.getElementById('playBtn').textContent = '▶ 播放';
                    animationState.showResult = false;
                    updateDNAState();
                    draw();
                    updateStepInfo(stages[stageIndex].name, stages[stageIndex].description);
                });
            });
            
            // 标签切换
            document.getElementById('labelsToggle').addEventListener('change', function() {
                animationState.showLabels = this.checked;
                draw();
            });
            
            // 高亮模板链
            document.getElementById('highlightTemplate').addEventListener('change', function() {
                animationState.highlightTemplate = this.checked;
                draw();
            });
            
            // 展示半保留结果
            document.getElementById('showResultBtn').addEventListener('click', function() {
                animationState.showResult = !animationState.showResult;
                this.textContent = animationState.showResult ? '隐藏结果' : '展示半保留结果';
                draw();
                
                if (animationState.showResult) {
                    updateStepInfo("半保留复制结果", "每个子代DNA分子包含一条亲代链（模板链）和一条新合成链，这就是'半保留复制'的含义。");
                } else {
                    updateStepInfo(stages[currentStageIndex].name, stages[currentStageIndex].description);
                }
            });
            
            // Canvas点击事件（用于元素交互）
            canvas.addEventListener('click', function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // 检查点击了哪个元素（简化版本）
                const centerY = canvas.height / 2;
                
                // 检查是否点击了解旋酶区域
                if (dnaState.helicase.active) {
                    const dx = x - dnaState.helicase.x;
                    const dy = y - dnaState.helicase.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 20) {
                        updateStepInfo("解旋酶", "解旋酶是一种分子马达，利用ATP水解提供的能量，在复制叉处解开DNA双螺旋结构。");
                        return;
                    }
                }
                
                // 检查是否点击了DNA聚合酶区域
                if (dnaState.dnaPolymeraseLeading.active) {
                    const dx = x - dnaState.dnaPolymeraseLeading.x;
                    const dy = y - dnaState.dnaPolymeraseLeading.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 15) {
                        updateStepInfo("DNA聚合酶", "DNA聚合酶以DNA为模板，按照碱基互补配对原则，催化合成新的DNA链。前导链的合成是连续的。");
                        return;
                    }
                }
                
                // 检查是否点击了前导链区域
                if (dnaState.leadingStrand.segments.length > 0) {
                    const segment = dnaState.leadingStrand.segments[0];
                    if (y > segment.y - 10 && y < segment.y + 10 && 
                        x > segment.x && x < segment.x + segment.length) {
                        updateStepInfo("前导链", "前导链的合成方向与复制叉移动方向一致，因此可以连续合成，不需要冈崎片段。");
                        return;
                    }
                }
                
                // 检查是否点击了滞后链区域
                if (dnaState.laggingStrand.okazakiFragments.length > 0) {
                    const fragment = dnaState.laggingStrand.okazakiFragments[0];
                    if (y > fragment.y - 10 && y < fragment.y + 10 && 
                        x > fragment.x && x < fragment.x + fragment.length) {
                        updateStepInfo("滞后链与冈崎片段", "滞后链的合成方向与复制叉移动方向相反，因此以短片段（冈崎片段）形式不连续合成，随后由连接酶连接。");
                        return;
                    }
                }
                
                // 检查是否点击了复制叉区域
                if (x > dnaState.forkX - 20 && x < dnaState.forkX + 20 && 
                    y > centerY - 20 && y < centerY + 20) {
                    updateStepInfo("复制叉", "复制叉是DNA复制时双链解开形成的Y形结构，是DNA复制的活跃区域，多种酶和蛋白在此协同工作。");
                    return;
                }
                
                // 默认信息
                updateStepInfo(stages[currentStageIndex].name, stages[currentStageIndex].description);
            });
        }
        
        // 初始化
        function init() {
            initDNAState();
            setupEventListeners();
            updateStageIndicator();
            updateStepInfo("起始状态", "DNA双螺旋结构完整，准备开始复制。点击播放按钮开始动画，或使用控制面板的其他功能。");
            draw();
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>