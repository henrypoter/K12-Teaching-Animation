<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…‰åˆä½œç”¨å…¨è¿‡ç¨‹æ•™å­¦åŠ¨ç”»</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(to right, #2E7D32, #4CAF50);
            color: white;
            padding: 25px 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.4rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }
        
        .animation-section {
            flex: 3;
            min-width: 300px;
            background-color: #f9f9f9;
            border-radius: 10px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.05);
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background-color: #f0f8ff;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #ddd;
        }
        
        #animationCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls-section {
            flex: 1;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .control-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e0e0e0;
        }
        
        h2 {
            color: #2E7D32;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #E8F5E9;
        }
        
        .scene-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .scene-btn {
            padding: 12px 8px;
            background-color: #f1f8e9;
            border: 2px solid #C8E6C9;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #2E7D32;
            transition: all 0.3s;
            text-align: center;
        }
        
        .scene-btn:hover {
            background-color: #E8F5E9;
            transform: translateY(-2px);
        }
        
        .scene-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #2E7D32;
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }
        
        .animation-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px 5px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background-color: #1976D2;
            transform: translateY(-2px);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .control-btn.reset {
            background-color: #FF9800;
        }
        
        .control-btn.reset:hover {
            background-color: #F57C00;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .speed-slider {
            flex: 1;
        }
        
        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .info-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border: 1px solid #e0e0e0;
            margin-top: 10px;
        }
        
        .step-indicator {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2E7D32;
            margin-bottom: 10px;
        }
        
        .step-description {
            line-height: 1.6;
            color: #555;
            font-size: 0.95rem;
        }
        
        .hint {
            background-color: #E3F2FD;
            border-left: 4px solid #2196F3;
            padding: 12px;
            margin-top: 15px;
            border-radius: 0 8px 8px 0;
            font-size: 0.9rem;
            color: #1565C0;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
            border-top: 1px solid #eee;
            background-color: #f9f9f9;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .canvas-container {
                height: 400px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å…‰åˆä½œç”¨å…¨è¿‡ç¨‹æ•™å­¦åŠ¨ç”»</h1>
            <p class="subtitle">æ¢ç´¢å¶ç»¿ä½“ä¸­çš„èƒ½é‡è½¬æ¢ï¼šå…‰ååº”ï¼ˆç±»å›Šä½“è–„è†œï¼‰ä¸æš—ååº”ï¼ˆåŸºè´¨ï¼‰çš„åŠ¨æ€è¿‡ç¨‹</p>
        </header>
        
        <div class="main-content">
            <section class="animation-section">
                <div class="canvas-container">
                    <canvas id="animationCanvas"></canvas>
                </div>
            </section>
            
            <section class="controls-section">
                <div class="control-panel">
                    <h2>åœºæ™¯é€‰æ‹©</h2>
                    <div class="scene-buttons">
                        <button class="scene-btn active" data-scene="overview">æ€»è§ˆ</button>
                        <button class="scene-btn" data-scene="light">å…‰ååº”</button>
                        <button class="scene-btn" data-scene="dark">æš—ååº”</button>
                        <button class="scene-btn" data-scene="full">å®Œæ•´å¾ªç¯</button>
                    </div>
                    
                    <h2>åŠ¨ç”»æ§åˆ¶</h2>
                    <div class="animation-controls">
                        <button class="control-btn" id="playBtn">æ’­æ”¾</button>
                        <button class="control-btn" id="pauseBtn">æš‚åœ</button>
                        <button class="control-btn" id="stepBtn">ä¸‹ä¸€æ­¥</button>
                        <button class="control-btn reset" id="resetBtn">é‡ç½®</button>
                    </div>
                    
                    <div class="speed-control">
                        <span>é€Ÿåº¦:</span>
                        <input type="range" min="1" max="10" value="5" class="speed-slider" id="speedSlider">
                    </div>
                </div>
                
                <div class="control-panel">
                    <h2>åˆ†å­å›¾ä¾‹</h2>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #42A5F5;"></div>
                            <span>æ°´ (Hâ‚‚O)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #EF5350;"></div>
                            <span>æ°§æ°” (Oâ‚‚)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #BDBDBD;"></div>
                            <span>äºŒæ°§åŒ–ç¢³ (COâ‚‚)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFB74D;"></div>
                            <span>ATP (èƒ½é‡)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #BA68C8;"></div>
                            <span>NADPH (è¿˜åŸåŠ›)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #388E3C;"></div>
                            <span>ç³–ç±» (G3P)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #F48FB1;"></div>
                            <span>æ°¢ç¦»å­ (Hâº)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #FFEB3B;"></div>
                            <span>ç”µå­ (eâ»)</span>
                        </div>
                    </div>
                </div>
                
                <div class="info-panel">
                    <div class="step-indicator" id="stepTitle">å¶ç»¿ä½“ç»“æ„æ€»è§ˆ</div>
                    <div class="step-description" id="stepDescription">
                        è¿™æ˜¯æ¤ç‰©ç»†èƒä¸­çš„å¶ç»¿ä½“ã€‚å¤–éƒ¨æ˜¯åŒå±‚è†œç»“æ„ï¼Œå†…éƒ¨æœ‰ç±»å›Šä½“å †å å½¢æˆçš„åŸºç²’ï¼Œä»¥åŠå……æ»¡åŸºè´¨çš„æ¶²æ€ç©ºé—´ã€‚å…‰ååº”å‘ç”Ÿåœ¨ç±»å›Šä½“è–„è†œä¸Šï¼Œæš—ååº”å‘ç”Ÿåœ¨åŸºè´¨ä¸­ã€‚
                    </div>
                    <div class="hint">
                        ğŸ’¡ æç¤ºï¼šå°†é¼ æ ‡æ‚¬åœåœ¨åŠ¨ç”»ä¸­çš„å…ƒç´ ä¸Šï¼Œå¯ä»¥æŸ¥çœ‹å…¶åç§°å’ŒåŠŸèƒ½ã€‚
                    </div>
                </div>
            </section>
        </div>
        
        <footer>
            <p>å…‰åˆä½œç”¨æ•™å­¦åŠ¨ç”» | è®¾è®¡ï¼šæ•™è‚²æŠ€æœ¯ä¸“å®¶ | æœ¬åŠ¨ç”»ç”¨äºæ•™å­¦æ¼”ç¤ºç›®çš„</p>
        </footer>
    </div>

    <script>
        // è·å–Canvaså’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        
        // è®¾ç½®Canvaså°ºå¯¸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // åˆå§‹è°ƒæ•´å°ºå¯¸
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // åŠ¨ç”»çŠ¶æ€
        let animationState = {
            currentScene: 'overview', // overview, light, dark, full
            isPlaying: false,
            animationSpeed: 5, // 1-10
            step: 0,
            time: 0,
            hoveredElement: null
        };
        
        // åœºæ™¯æ•°æ®
        const scenes = {
            overview: {
                steps: 1,
                title: "å¶ç»¿ä½“ç»“æ„æ€»è§ˆ",
                description: "è¿™æ˜¯æ¤ç‰©ç»†èƒä¸­çš„å¶ç»¿ä½“ã€‚å¤–éƒ¨æ˜¯åŒå±‚è†œç»“æ„ï¼Œå†…éƒ¨æœ‰ç±»å›Šä½“å †å å½¢æˆçš„åŸºç²’ï¼Œä»¥åŠå……æ»¡åŸºè´¨çš„æ¶²æ€ç©ºé—´ã€‚å…‰ååº”å‘ç”Ÿåœ¨ç±»å›Šä½“è–„è†œä¸Šï¼Œæš—ååº”å‘ç”Ÿåœ¨åŸºè´¨ä¸­ã€‚"
            },
            light: {
                steps: 6,
                titles: [
                    "å…‰å­æ¿€å‘å¶ç»¿ç´ ",
                    "æ°´çš„å…‰è§£",
                    "ç”µå­ä¼ é€’ä¸Hâºæ³µé€",
                    "ATPåˆæˆ",
                    "NADPHç”Ÿæˆ",
                    "å…‰ååº”äº§ç‰©æ€»ç»“"
                ],
                descriptions: [
                    "å…‰å­ï¼ˆé»„è‰²å…‰ç‚¹ï¼‰è¢«ç±»å›Šä½“è†œä¸Šçš„å¶ç»¿ç´ åˆ†å­å¸æ”¶ï¼Œæ¿€å‘ç”µå­ã€‚",
                    "æ°´åˆ†å­åœ¨å…‰ç³»ç»ŸIIå¤„è¢«åˆ†è§£ï¼Œé‡Šæ”¾æ°§æ°”ï¼ˆOâ‚‚ï¼‰å’Œæ°¢ç¦»å­ï¼ˆHâºï¼‰ï¼Œå¹¶æä¾›ç”µå­ã€‚",
                    "ç”µå­æ²¿ç€ç”µå­ä¼ é€’é“¾ç§»åŠ¨ï¼Œèƒ½é‡ç”¨äºå°†Hâºæ³µå…¥ç±»å›Šä½“å†…è…”ï¼Œå½¢æˆæµ“åº¦æ¢¯åº¦ã€‚",
                    "Hâºé€šè¿‡ATPåˆé…¶é¡ºæµ“åº¦æ¢¯åº¦æµå‡ºï¼Œé©±åŠ¨ATPçš„åˆæˆã€‚",
                    "ç”µå­æœ€ç»ˆä¼ é€’ç»™NADPâºï¼Œç»“åˆHâºå½¢æˆNADPHï¼ˆè¿˜åŸåŠ›ï¼‰ã€‚",
                    "å…‰ååº”äº§ç”ŸATPï¼ˆèƒ½é‡è´§å¸ï¼‰å’ŒNADPHï¼ˆè¿˜åŸåŠ›ï¼‰ï¼Œå¹¶é‡Šæ”¾æ°§æ°”ã€‚è¿™äº›äº§ç‰©å°†ç”¨äºæš—ååº”ã€‚"
                ]
            },
            dark: {
                steps: 5,
                titles: [
                    "COâ‚‚çš„å›ºå®š",
                    "ä¸‰ç¢³åŒ–åˆç‰©çš„å½¢æˆ",
                    "ä¸‰ç¢³åŒ–åˆç‰©çš„è¿˜åŸ",
                    "ç³–åˆ†å­çš„ç”Ÿæˆ",
                    "RuBPçš„å†ç”Ÿ"
                ],
                descriptions: [
                    "äºŒæ°§åŒ–ç¢³ï¼ˆCOâ‚‚ï¼‰è¿›å…¥å¶ç»¿ä½“åŸºè´¨ï¼Œä¸RuBPï¼ˆäº”ç¢³åŒ–åˆç‰©ï¼‰ç»“åˆï¼Œå½¢æˆä¸ç¨³å®šçš„å…­ç¢³åŒ–åˆç‰©ã€‚",
                    "ä¸ç¨³å®šçš„å…­ç¢³åŒ–åˆç‰©è¿…é€Ÿåˆ†è§£ä¸ºä¸¤ä¸ªä¸‰ç¢³åŒ–åˆç‰©ï¼ˆ3-ç£·é…¸ç”˜æ²¹é…¸ï¼‰ã€‚",
                    "åœ¨ATPå’ŒNADPHçš„é©±åŠ¨ä¸‹ï¼Œä¸‰ç¢³åŒ–åˆç‰©è¢«è¿˜åŸä¸ºä¸‰ç¢³ç³–ï¼ˆ3-ç£·é…¸ç”˜æ²¹é†›ï¼ŒG3Pï¼‰ã€‚",
                    "éƒ¨åˆ†G3Pè¾“å‡ºç”¨äºåˆæˆè‘¡è„ç³–ç­‰æœ‰æœºç‰©ï¼Œå…¶ä½™ç”¨äºå†ç”ŸRuBPã€‚",
                    "é€šè¿‡ä¸€ç³»åˆ—ååº”ï¼Œå‰©ä½™çš„G3Påœ¨æ¶ˆè€—ATPçš„æƒ…å†µä¸‹ï¼Œé‡æ–°ç”ŸæˆRuBPï¼Œç»´æŒå¡å°”æ–‡å¾ªç¯ã€‚"
                ]
            },
            full: {
                steps: 1,
                title: "å…‰åˆä½œç”¨å®Œæ•´å¾ªç¯",
                description: "å…‰ååº”å’Œæš—ååº”ååŒå·¥ä½œï¼šå…‰ååº”åœ¨ç±»å›Šä½“è†œä¸Šæ•è·å…‰èƒ½ï¼Œäº§ç”ŸATPå’ŒNADPHï¼›æš—ååº”åœ¨åŸºè´¨ä¸­åˆ©ç”¨è¿™äº›äº§ç‰©å°†COâ‚‚å›ºå®šå¹¶è¿˜åŸä¸ºæœ‰æœºç‰©ã€‚ä¸¤è€…æ„æˆèƒ½é‡ä¸ç‰©è´¨çš„å®Œæ•´å¾ªç¯ã€‚"
            }
        };
        
        // é¢œè‰²å®šä¹‰
        const colors = {
            chloroplastOuter: '#E8F5E9',
            chloroplastInner: '#C8E6C9',
            thylakoid: '#4CAF50',
            stroma: 'rgba(255, 249, 196, 0.7)',
            water: '#42A5F5',
            oxygen: '#EF5350',
            co2: '#BDBDBD',
            atp: '#FFB74D',
            nadph: '#BA68C8',
            sugar: '#388E3C',
            proton: '#F48FB1',
            electron: '#FFEB3B',
            photon: '#FFFF00',
            highlight: '#00BCD4',
            text: '#424242'
        };
        
        // åŠ¨ç”»å…ƒç´ 
        let animationElements = [];
        
        // åˆå§‹åŒ–åŠ¨ç”»å…ƒç´ 
        function initAnimationElements() {
            animationElements = [];
            
            // æ ¹æ®å½“å‰åœºæ™¯åˆ›å»ºä¸åŒçš„å…ƒç´ 
            if (animationState.currentScene === 'overview') {
                // å¶ç»¿ä½“
                animationElements.push({
                    type: 'chloroplast',
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    width: Math.min(canvas.width, canvas.height) * 0.7,
                    height: Math.min(canvas.width, canvas.height) * 0.5,
                    label: 'å¶ç»¿ä½“',
                    description: 'å…‰åˆä½œç”¨çš„åœºæ‰€ï¼Œå…·æœ‰åŒå±‚è†œç»“æ„'
                });
                
                // ç±»å›Šä½“/åŸºç²’
                for (let i = 0; i < 5; i++) {
                    animationElements.push({
                        type: 'thylakoid',
                        x: canvas.width / 2 - 100 + i * 50,
                        y: canvas.height / 2 - 30,
                        width: 40,
                        height: 60,
                        label: 'ç±»å›Šä½“ï¼ˆåŸºç²’ï¼‰',
                        description: 'å…‰ååº”çš„åœºæ‰€ï¼Œå«æœ‰å¶ç»¿ç´ å’Œç”µå­ä¼ é€’é“¾'
                    });
                }
                
                // åŸºè´¨
                animationElements.push({
                    type: 'stroma',
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    width: Math.min(canvas.width, canvas.height) * 0.65,
                    height: Math.min(canvas.width, canvas.height) * 0.45,
                    label: 'åŸºè´¨',
                    description: 'æš—ååº”ï¼ˆå¡å°”æ–‡å¾ªç¯ï¼‰çš„åœºæ‰€ï¼Œå«æœ‰å¤šç§é…¶'
                });
                
            } else if (animationState.currentScene === 'light') {
                // ç±»å›Šä½“è†œ
                animationElements.push({
                    type: 'thylakoidMembrane',
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    width: 300,
                    height: 100,
                    label: 'ç±»å›Šä½“è†œ',
                    description: 'å…‰ååº”å‘ç”Ÿçš„åœºæ‰€'
                });
                
                // æ ¹æ®æ­¥éª¤æ·»åŠ åŠ¨æ€å…ƒç´ 
                if (animationState.step >= 0) {
                    // å…‰å­
                    for (let i = 0; i < 5; i++) {
                        animationElements.push({
                            type: 'photon',
                            x: canvas.width / 2 - 150 + i * 60,
                            y: canvas.height / 2 - 80,
                            radius: 8,
                            phase: i * 0.5,
                            label: 'å…‰å­',
                            description: 'å…‰èƒ½çš„åŸºæœ¬å•ä½ï¼Œæ¿€å‘å¶ç»¿ç´ ä¸­çš„ç”µå­'
                        });
                    }
                }
                
                if (animationState.step >= 1) {
                    // æ°´åˆ†å­
                    animationElements.push({
                        type: 'water',
                        x: canvas.width / 2 - 180,
                        y: canvas.height / 2,
                        radius: 12,
                        label: 'æ°´åˆ†å­ (Hâ‚‚O)',
                        description: 'åœ¨å…‰ç³»ç»ŸIIå¤„è¢«å…‰è§£ï¼Œæä¾›ç”µå­å’Œè´¨å­'
                    });
                    
                    // æ°§æ°”
                    for (let i = 0; i < 3; i++) {
                        animationElements.push({
                            type: 'oxygen',
                            x: canvas.width / 2 - 180 + i * 15,
                            y: canvas.height / 2 - 50 - i * 5,
                            radius: 10,
                            phase: i * 0.3,
                            label: 'æ°§æ°” (Oâ‚‚)',
                            description: 'å…‰åˆä½œç”¨çš„å‰¯äº§ç‰©ï¼Œé‡Šæ”¾åˆ°å¤§æ°”ä¸­'
                        });
                    }
                }
                
                if (animationState.step >= 2) {
                    // ç”µå­ä¼ é€’é“¾
                    animationElements.push({
                        type: 'electronChain',
                        x: canvas.width / 2 - 100,
                        y: canvas.height / 2,
                        length: 200,
                        label: 'ç”µå­ä¼ é€’é“¾',
                        description: 'ä¼ é€’ç”µå­ï¼Œå°†èƒ½é‡ç”¨äºæ³µé€Hâº'
                    });
                    
                    // H+ æ³µé€
                    for (let i = 0; i < 8; i++) {
                        animationElements.push({
                            type: 'proton',
                            x: canvas.width / 2 - 80 + i * 20,
                            y: canvas.height / 2 + 30,
                            radius: 8,
                            phase: i * 0.4,
                            direction: 'in',
                            label: 'æ°¢ç¦»å­ (Hâº)',
                            description: 'è¢«æ³µå…¥ç±»å›Šä½“å†…è…”ï¼Œå½¢æˆæµ“åº¦æ¢¯åº¦'
                        });
                    }
                }
                
                if (animationState.step >= 3) {
                    // ATPåˆé…¶
                    animationElements.push({
                        type: 'atpSynthase',
                        x: canvas.width / 2 + 120,
                        y: canvas.height / 2,
                        width: 40,
                        height: 60,
                        label: 'ATPåˆé…¶',
                        description: 'åˆ©ç”¨Hâºæµ“åº¦æ¢¯åº¦åˆæˆATP'
                    });
                    
                    // ATPåˆ†å­
                    for (let i = 0; i < 3; i++) {
                        animationElements.push({
                            type: 'atp',
                            x: canvas.width / 2 + 140 + i * 25,
                            y: canvas.height / 2 - 30 - i * 5,
                            radius: 12,
                            phase: i * 0.5,
                            label: 'ATP',
                            description: 'èƒ½é‡è´§å¸ï¼Œä¸ºæš—ååº”æä¾›èƒ½é‡'
                        });
                    }
                }
                
                if (animationState.step >= 4) {
                    // NADPH
                    animationElements.push({
                        type: 'nadph',
                        x: canvas.width / 2 + 180,
                        y: canvas.height / 2 + 20,
                        radius: 12,
                        label: 'NADPH',
                        description: 'è¿˜åŸåŠ›ï¼Œä¸ºæš—ååº”æä¾›è¿˜åŸèƒ½åŠ›'
                    });
                }
                
            } else if (animationState.currentScene === 'dark') {
                // åŸºè´¨èƒŒæ™¯
                animationElements.push({
                    type: 'stromaBackground',
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    width: canvas.width * 0.8,
                    height: canvas.height * 0.7,
                    label: 'åŸºè´¨',
                    description: 'æš—ååº”å‘ç”Ÿçš„æ¶²æ€ç¯å¢ƒ'
                });
                
                // å¡å°”æ–‡å¾ªç¯
                animationElements.push({
                    type: 'calvinCycle',
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    radius: 120,
                    label: 'å¡å°”æ–‡å¾ªç¯',
                    description: 'æš—ååº”çš„æ ¸å¿ƒè¿‡ç¨‹ï¼Œå›ºå®šCOâ‚‚å¹¶åˆæˆç³–ç±»'
                });
                
                if (animationState.step >= 0) {
                    // CO2åˆ†å­
                    animationElements.push({
                        type: 'co2',
                        x: canvas.width / 2 - 200,
                        y: canvas.height / 2,
                        radius: 12,
                        label: 'äºŒæ°§åŒ–ç¢³ (COâ‚‚)',
                        description: 'ä»å¤§æ°”ä¸­å¸æ”¶ï¼Œç”¨äºç¢³å›ºå®š'
                    });
                    
                    // RuBP
                    animationElements.push({
                        type: 'rubp',
                        x: canvas.width / 2,
                        y: canvas.height / 2 - 120,
                        radius: 15,
                        label: 'RuBP (äº”ç¢³åŒ–åˆç‰©)',
                        description: 'äºŒæ°§åŒ–ç¢³çš„å—ä½“åˆ†å­'
                    });
                }
                
                if (animationState.step >= 1) {
                    // 3-ç£·é…¸ç”˜æ²¹é…¸
                    for (let i = 0; i < 2; i++) {
                        animationElements.push({
                            type: 'pga',
                            x: canvas.width / 2 + (i === 0 ? -60 : 60),
                            y: canvas.height / 2 + 30,
                            radius: 12,
                            label: '3-ç£·é…¸ç”˜æ²¹é…¸',
                            description: 'COâ‚‚å›ºå®šåå½¢æˆçš„ä¸‰ç¢³åŒ–åˆç‰©'
                        });
                    }
                }
                
                if (animationState.step >= 2) {
                    // ATPå’ŒNADPHè¾“å…¥
                    animationElements.push({
                        type: 'atpInput',
                        x: canvas.width / 2 - 150,
                        y: canvas.height / 2 + 100,
                        radius: 12,
                        label: 'ATP',
                        description: 'æ¥è‡ªå…‰ååº”ï¼Œæä¾›èƒ½é‡'
                    });
                    
                    animationElements.push({
                        type: 'nadphInput',
                        x: canvas.width / 2 + 150,
                        y: canvas.height / 2 + 100,
                        radius: 12,
                        label: 'NADPH',
                        description: 'æ¥è‡ªå…‰ååº”ï¼Œæä¾›è¿˜åŸåŠ›'
                    });
                }
                
                if (animationState.step >= 3) {
                    // G3Pè¾“å‡º
                    animationElements.push({
                        type: 'g3p',
                        x: canvas.width / 2,
                        y: canvas.height / 2 + 150,
                        radius: 14,
                        label: 'G3P (ä¸‰ç¢³ç³–)',
                        description: 'å¡å°”æ–‡å¾ªç¯çš„äº§ç‰©ï¼Œç”¨äºåˆæˆè‘¡è„ç³–'
                    });
                }
                
                if (animationState.step >= 4) {
                    // RuBPå†ç”Ÿ
                    animationElements.push({
                        type: 'rubpRegen',
                        x: canvas.width / 2,
                        y: canvas.height / 2 - 120,
                        radius: 15,
                        label: 'RuBPå†ç”Ÿ',
                        description: 'éƒ¨åˆ†G3Pç”¨äºé‡æ–°ç”ŸæˆRuBPï¼Œç»´æŒå¾ªç¯'
                    });
                }
                
            } else if (animationState.currentScene === 'full') {
                // å®Œæ•´å¾ªç¯ï¼šç»“åˆå…‰ååº”å’Œæš—ååº”
                // ç±»å›Šä½“éƒ¨åˆ†
                animationElements.push({
                    type: 'thylakoidSection',
                    x: canvas.width / 2 - 150,
                    y: canvas.height / 2,
                    width: 200,
                    height: 150,
                    label: 'ç±»å›Šä½“è†œï¼ˆå…‰ååº”ï¼‰',
                    description: 'æ•è·å…‰èƒ½ï¼Œäº§ç”ŸATPå’ŒNADPH'
                });
                
                // åŸºè´¨éƒ¨åˆ†
                animationElements.push({
                    type: 'stromaSection',
                    x: canvas.width / 2 + 150,
                    y: canvas.height / 2,
                    width: 200,
                    height: 150,
                    label: 'åŸºè´¨ï¼ˆæš—ååº”ï¼‰',
                    description: 'åˆ©ç”¨ATPå’ŒNADPHå°†COâ‚‚è½¬åŒ–ä¸ºç³–ç±»'
                });
                
                // ç‰©è´¨æµåŠ¨
                // ATPä»ç±»å›Šä½“æµå‘åŸºè´¨
                for (let i = 0; i < 3; i++) {
                    animationElements.push({
                        type: 'atpFlow',
                        x: canvas.width / 2 - 50 + i * 20,
                        y: canvas.height / 2 - 20,
                        radius: 10,
                        phase: i * 0.3,
                        label: 'ATPæµåŠ¨',
                        description: 'å…‰ååº”äº§ç”Ÿçš„ATPç”¨äºé©±åŠ¨æš—ååº”'
                    });
                }
                
                // NADPHä»ç±»å›Šä½“æµå‘åŸºè´¨
                for (let i = 0; i < 3; i++) {
                    animationElements.push({
                        type: 'nadphFlow',
                        x: canvas.width / 2 - 50 + i * 20,
                        y: canvas.height / 2 + 20,
                        radius: 10,
                        phase: i * 0.5,
                        label: 'NADPHæµåŠ¨',
                        description: 'å…‰ååº”äº§ç”Ÿçš„NADPHç”¨äºè¿˜åŸCOâ‚‚'
                    });
                }
                
                // CO2è¿›å…¥åŸºè´¨
                animationElements.push({
                    type: 'co2Flow',
                    x: canvas.width / 2 + 50,
                    y: canvas.height / 2 + 60,
                    radius: 10,
                    phase: 0,
                    label: 'COâ‚‚è¾“å…¥',
                    description: 'ä»å¤§æ°”è¿›å…¥å¶ç»¿ä½“åŸºè´¨'
                });
                
                // ç³–ç±»è¾“å‡º
                animationElements.push({
                    type: 'sugarOutput',
                    x: canvas.width / 2 + 250,
                    y: canvas.height / 2,
                    radius: 12,
                    phase: 0,
                    label: 'ç³–ç±»è¾“å‡º',
                    description: 'å…‰åˆä½œç”¨æœ€ç»ˆäº§ç‰©ï¼Œç”¨äºæ¤ç‰©ç”Ÿé•¿'
                });
            }
        }
        
        // ç»˜åˆ¶å‡½æ•°
        function draw() {
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ‰€æœ‰åŠ¨ç”»å…ƒç´ 
            animationElements.forEach(element => {
                drawElement(element);
            });
            
            // ç»˜åˆ¶æ‚¬åœæç¤º
            if (animationState.hoveredElement) {
                drawTooltip(animationState.hoveredElement);
            }
            
            // æ›´æ–°æ—¶é—´
            if (animationState.isPlaying) {
                animationState.time += 0.05 * animationState.animationSpeed;
            }
        }
        
        // ç»˜åˆ¶å•ä¸ªå…ƒç´ 
        function drawElement(element) {
            ctx.save();
            
            // æ ¹æ®å…ƒç´ ç±»å‹ç»˜åˆ¶
            switch (element.type) {
                case 'chloroplast':
                    // ç»˜åˆ¶å¶ç»¿ä½“å¤–è†œ
                    ctx.strokeStyle = colors.chloroplastOuter;
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.ellipse(element.x, element.y, element.width/2, element.height/2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶å¶ç»¿ä½“å†…è†œ
                    ctx.strokeStyle = colors.chloroplastInner;
                    ctx.lineWidth = 6;
                    ctx.beginPath();
                    ctx.ellipse(element.x, element.y, element.width/2 - 10, element.height/2 - 10, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.height/2 - 20);
                    }
                    break;
                    
                case 'thylakoid':
                    // ç»˜åˆ¶ç±»å›Šä½“ï¼ˆåŸºç²’ï¼‰
                    ctx.fillStyle = colors.thylakoid;
                    ctx.fillRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶ç±»å›Šä½“è†œ
                    ctx.strokeStyle = '#2E7D32';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶å†…éƒ¨æ¡çº¹ï¼ˆè¡¨ç¤ºè†œç»“æ„ï¼‰
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(element.x - element.width/2 + 5, element.y - element.height/2 + 10 + i*15);
                        ctx.lineTo(element.x + element.width/2 - 5, element.y - element.height/2 + 10 + i*15);
                        ctx.strokeStyle = '#1B5E20';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.height/2 - 15);
                    }
                    break;
                    
                case 'stroma':
                    // ç»˜åˆ¶åŸºè´¨
                    ctx.fillStyle = colors.stroma;
                    ctx.beginPath();
                    ctx.ellipse(element.x, element.y, element.width/2 - 20, element.height/2 - 20, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y + element.height/2 + 30);
                    }
                    break;
                    
                case 'thylakoidMembrane':
                    // ç»˜åˆ¶ç±»å›Šä½“è†œï¼ˆå…‰ååº”åœºæ™¯ï¼‰
                    ctx.fillStyle = colors.thylakoid;
                    ctx.fillRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶è†œç»†èŠ‚
                    ctx.strokeStyle = '#1B5E20';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶å†…éƒ¨è†œè›‹ç™½ç¤ºæ„
                    for (let i = 0; i < 5; i++) {
                        const proteinX = element.x - element.width/2 + 40 + i * 60;
                        ctx.fillStyle = '#8BC34A';
                        ctx.beginPath();
                        ctx.arc(proteinX, element.y, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = '#1B5E20';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('PS', proteinX, element.y + 4);
                    }
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.height/2 - 20);
                    }
                    break;
                    
                case 'photon':
                    // ç»˜åˆ¶å…‰å­
                    const pulse = Math.sin(animationState.time + element.phase) * 0.3 + 0.7;
                    ctx.fillStyle = colors.photon;
                    ctx.globalAlpha = pulse;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y + Math.sin(animationState.time + element.phase) * 10, element.radius * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶å…‰çº¿æ¡
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y - 50);
                    ctx.lineTo(element.x, element.y - element.radius);
                    ctx.strokeStyle = colors.photon;
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = pulse * 0.5;
                    ctx.stroke();
                    
                    ctx.globalAlpha = 1.0;
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.radius - 20);
                    }
                    break;
                    
                case 'water':
                    // ç»˜åˆ¶æ°´åˆ†å­
                    ctx.fillStyle = colors.water;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Hâ‚‚O', element.x, element.y + 4);
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.radius - 20);
                    }
                    break;
                    
                case 'oxygen':
                    // ç»˜åˆ¶æ°§æ°”åˆ†å­
                    const o2Y = element.y + Math.sin(animationState.time + element.phase) * 5;
                    ctx.fillStyle = colors.oxygen;
                    ctx.beginPath();
                    ctx.arc(element.x, o2Y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Oâ‚‚', element.x, o2Y + 4);
                    
                    // ç»˜åˆ¶ä¸Šå‡æ°”æ³¡æ•ˆæœ
                    if (animationState.step >= 1 && animationState.currentScene === 'light') {
                        ctx.beginPath();
                        ctx.arc(element.x, o2Y - element.radius - 5, 3, 0, Math.PI * 2);
                        ctx.fillStyle = colors.oxygen;
                        ctx.globalAlpha = 0.7;
                        ctx.fill();
                        ctx.globalAlpha = 1.0;
                    }
                    break;
                    
                case 'electronChain':
                    // ç»˜åˆ¶ç”µå­ä¼ é€’é“¾
                    ctx.strokeStyle = '#FFC107';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(element.x - element.length/2, element.y);
                    ctx.lineTo(element.x + element.length/2, element.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // ç»˜åˆ¶ç”µå­åœ¨ä¼ é€’é“¾ä¸Šç§»åŠ¨
                    const electronX = element
<!--æ£€æµ‹åˆ°ä»£ç æˆªæ–­ï¼Œè‡ªåŠ¨ç»­å†™ä¸­...-->
.x - element.length/2 + (animationState.time % 1) * element.length;
                    ctx.fillStyle = colors.electron;
                    ctx.beginPath();
                    ctx.arc(electronX, element.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - 30);
                    }
                    break;
                    
                case 'proton':
                    // ç»˜åˆ¶æ°¢ç¦»å­
                    const protonY = element.y + Math.sin(animationState.time + element.phase) * 10;
                    ctx.fillStyle = colors.proton;
                    ctx.beginPath();
                    ctx.arc(element.x, protonY, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Hâº', element.x, protonY + 4);
                    
                    // ç»˜åˆ¶ç§»åŠ¨æ–¹å‘
                    if (element.direction === 'in') {
                        ctx.beginPath();
                        ctx.moveTo(element.x, protonY - element.radius - 5);
                        ctx.lineTo(element.x - 5, protonY - element.radius - 10);
                        ctx.lineTo(element.x + 5, protonY - element.radius - 10);
                        ctx.closePath();
                        ctx.fillStyle = colors.proton;
                        ctx.fill();
                    }
                    break;
                    
                case 'atpSynthase':
                    // ç»˜åˆ¶ATPåˆé…¶
                    ctx.fillStyle = '#795548';
                    ctx.fillRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶æ—‹è½¬éƒ¨åˆ†
                    ctx.save();
                    ctx.translate(element.x, element.y);
                    ctx.rotate(animationState.time * 2);
                    ctx.fillStyle = '#5D4037';
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(10, 10);
                    ctx.lineTo(-10, 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.height/2 - 15);
                    }
                    break;
                    
                case 'atp':
                    // ç»˜åˆ¶ATPåˆ†å­
                    const atpY = element.y + Math.sin(animationState.time + element.phase) * 5;
                    ctx.fillStyle = colors.atp;
                    ctx.beginPath();
                    ctx.arc(element.x, atpY, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ATP', element.x, atpY + 4);
                    break;
                    
                case 'nadph':
                    // ç»˜åˆ¶NADPHåˆ†å­
                    ctx.fillStyle = colors.nadph;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('NADPH', element.x, element.y + 4);
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.radius - 20);
                    }
                    break;
                    
                case 'stromaBackground':
                    // ç»˜åˆ¶åŸºè´¨èƒŒæ™¯
                    ctx.fillStyle = colors.stroma;
                    ctx.fillRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.height/2 - 20);
                    }
                    break;
                    
                case 'calvinCycle':
                    // ç»˜åˆ¶å¡å°”æ–‡å¾ªç¯
                    ctx.strokeStyle = '#388E3C';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶å¾ªç¯ç®­å¤´
                    ctx.fillStyle = '#388E3C';
                    ctx.beginPath();
                    ctx.moveTo(element.x + element.radius, element.y);
                    ctx.lineTo(element.x + element.radius - 15, element.y - 10);
                    ctx.lineTo(element.x + element.radius - 15, element.y + 10);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = '#388E3C';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('å¡å°”æ–‡å¾ªç¯', element.x, element.y);
                    
                    // ç»˜åˆ¶æ ‡ç­¾
                    if (isElementHovered(element)) {
                        ctx.fillStyle = colors.highlight;
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(element.label, element.x, element.y - element.radius - 20);
                    }
                    break;
                    
                case 'co2':
                    // ç»˜åˆ¶äºŒæ°§åŒ–ç¢³åˆ†å­
                    ctx.fillStyle = colors.co2;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('COâ‚‚', element.x, element.y + 4);
                    
                    // ç»˜åˆ¶ç§»åŠ¨åŠ¨ç”»
                    if (animationState.step >= 0 && animationState.currentScene === 'dark') {
                        const moveX = element.x + Math.sin(animationState.time) * 20;
                        ctx.beginPath();
                        ctx.arc(moveX, element.y, element.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('COâ‚‚', moveX, element.y + 4);
                    }
                    break;
                    
                case 'rubp':
                    // ç»˜åˆ¶RuBPåˆ†å­
                    ctx.fillStyle = '#7B1FA2';
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('RuBP', element.x, element.y + 4);
                    break;
                    
                case 'pga':
                    // ç»˜åˆ¶3-ç£·é…¸ç”˜æ²¹é…¸
                    ctx.fillStyle = '#0288D1';
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('PGA', element.x, element.y + 4);
                    break;
                    
                case 'atpInput':
                    // ç»˜åˆ¶ATPè¾“å…¥
                    const atpInputY = element.y + Math.sin(animationState.time) * 10;
                    ctx.fillStyle = colors.atp;
                    ctx.beginPath();
                    ctx.arc(element.x, atpInputY, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ATP', element.x, atpInputY + 4);
                    
                    // ç»˜åˆ¶ç®­å¤´æŒ‡å‘å¾ªç¯
                    ctx.beginPath();
                    ctx.moveTo(element.x, atpInputY - element.radius);
                    ctx.lineTo(element.x, element.y - 80);
                    ctx.strokeStyle = colors.atp;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // ç»˜åˆ¶ç®­å¤´å¤´
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y - 80);
                    ctx.lineTo(element.x - 5, element.y - 85);
                    ctx.lineTo(element.x + 5, element.y - 85);
                    ctx.closePath();
                    ctx.fillStyle = colors.atp;
                    ctx.fill();
                    break;
                    
                case 'nadphInput':
                    // ç»˜åˆ¶NADPHè¾“å…¥
                    const nadphInputY = element.y + Math.sin(animationState.time + 1) * 10;
                    ctx.fillStyle = colors.nadph;
                    ctx.beginPath();
                    ctx.arc(element.x, nadphInputY, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('NADPH', element.x, nadphInputY + 4);
                    
                    // ç»˜åˆ¶ç®­å¤´æŒ‡å‘å¾ªç¯
                    ctx.beginPath();
                    ctx.moveTo(element.x, nadphInputY - element.radius);
                    ctx.lineTo(element.x, element.y - 80);
                    ctx.strokeStyle = colors.nadph;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // ç»˜åˆ¶ç®­å¤´å¤´
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y - 80);
                    ctx.lineTo(element.x - 5, element.y - 85);
                    ctx.lineTo(element.x + 5, element.y - 85);
                    ctx.closePath();
                    ctx.fillStyle = colors.nadph;
                    ctx.fill();
                    break;
                    
                case 'g3p':
                    // ç»˜åˆ¶G3Påˆ†å­
                    ctx.fillStyle = colors.sugar;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('G3P', element.x, element.y + 4);
                    
                    // ç»˜åˆ¶è¾“å‡ºç®­å¤´
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y - element.radius);
                    ctx.lineTo(element.x, element.y - 50);
                    ctx.strokeStyle = colors.sugar;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // ç»˜åˆ¶ç®­å¤´å¤´
                    ctx.beginPath();
                    ctx.moveTo(element.x, element.y - 50);
                    ctx.lineTo(element.x - 5, element.y - 55);
                    ctx.lineTo(element.x + 5, element.y - 55);
                    ctx.closePath();
                    ctx.fillStyle = colors.sugar;
                    ctx.fill();
                    break;
                    
                case 'rubpRegen':
                    // ç»˜åˆ¶RuBPå†ç”ŸåŠ¨ç”»
                    const pulseSize = Math.sin(animationState.time * 3) * 0.2 + 1;
                    ctx.fillStyle = '#7B1FA2';
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius * pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('RuBP', element.x, element.y + 4);
                    break;
                    
                case 'thylakoidSection':
                    // ç»˜åˆ¶ç±»å›Šä½“éƒ¨åˆ†ï¼ˆå®Œæ•´å¾ªç¯ï¼‰
                    ctx.fillStyle = colors.thylakoid;
                    ctx.fillRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶å…‰ååº”æ ‡ç­¾
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('å…‰ååº”', element.x, element.y);
                    
                    // ç»˜åˆ¶å°å¤ªé˜³å›¾æ ‡
                    ctx.fillStyle = '#FFEB3B';
                    ctx.beginPath();
                    ctx.arc(element.x, element.y - 40, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç»˜åˆ¶å…‰çº¿
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(element.x + Math.cos(angle) * 15, element.y - 40 + Math.sin(angle) * 15);
                        ctx.lineTo(element.x + Math.cos(angle) * 25, element.y - 40 + Math.sin(angle) * 25);
                        ctx.strokeStyle = '#FFEB3B';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    break;
                    
                case 'stromaSection':
                    // ç»˜åˆ¶åŸºè´¨éƒ¨åˆ†ï¼ˆå®Œæ•´å¾ªç¯ï¼‰
                    ctx.fillStyle = colors.stroma;
                    ctx.fillRect(element.x - element.width/2, element.y - element.height/2, element.width, element.height);
                    
                    // ç»˜åˆ¶æš—ååº”æ ‡ç­¾
                    ctx.fillStyle = colors.text;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('æš—ååº”', element.x, element.y);
                    
                    // ç»˜åˆ¶COâ‚‚å›¾æ ‡
                    ctx.fillStyle = colors.co2;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y - 40, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('COâ‚‚', element.x, element.y - 40 + 4);
                    break;
                    
                case 'atpFlow':
                    // ç»˜åˆ¶ATPæµåŠ¨
                    const atpFlowX = element.x + (animationState.time % 3) * 30;
                    ctx.fillStyle = colors.atp;
                    ctx.beginPath();
                    ctx.arc(atpFlowX, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ATP', atpFlowX, element.y + 4);
                    break;
                    
                case 'nadphFlow':
                    // ç»˜åˆ¶NADPHæµåŠ¨
                    const nadphFlowX = element.x + (animationState.time % 3) * 30;
                    ctx.fillStyle = colors.nadph;
                    ctx.beginPath();
                    ctx.arc(nadphFlowX, element.y, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 8px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('NADPH', nadphFlowX, element.y + 4);
                    break;
                    
                case 'co2Flow':
                    // ç»˜åˆ¶COâ‚‚æµåŠ¨
                    const co2FlowY = element.y - (animationState.time % 3) * 20;
                    ctx.fillStyle = colors.co2;
                    ctx.beginPath();
                    ctx.arc(element.x, co2FlowY, element.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 9px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('COâ‚‚', element.x, co2FlowY + 4);
                    break;
                    
                case 'sugarOutput':
                    // ç»˜åˆ¶ç³–ç±»è¾“å‡º
                    const sugarPulse = Math.sin(animationState.time * 2) * 0.2 + 0.8;
                    ctx.fillStyle = colors.sugar;
                    ctx.globalAlpha = sugarPulse;
                    ctx.beginPath();
                    ctx.arc(element.x, element.y, element.radius * sugarPulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ç³–ç±»', element.x, element.y + 4);
                    break;
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶å·¥å…·æç¤º
        function drawTooltip(element) {
            const x = element.x;
            const y = element.y;
            const label = element.label;
            const description = element.description;
            
            // è®¡ç®—æ–‡æœ¬å®½åº¦
            ctx.font = 'bold 14px Arial';
            const labelWidth = ctx.measureText(label).width;
            ctx.font = '12px Arial';
            const descWidth = ctx.measureText(description).width;
            const tooltipWidth = Math.max(labelWidth, descWidth) + 20;
            
            // ç»˜åˆ¶å·¥å…·æç¤ºèƒŒæ™¯
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = colors.highlight;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(x - tooltipWidth/2, y - 80, tooltipWidth, 60, 5);
            ctx.fill();
            ctx.stroke();
            
            // ç»˜åˆ¶å·¥å…·æç¤ºæ–‡æœ¬
            ctx.fillStyle = colors.text;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x, y - 60);
            
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // å¤„ç†é•¿æè¿°æ–‡æœ¬
            const words = description.split(' ');
            let line = '';
            let lineHeight = 15;
            let lines = [];
            
            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                const testWidth = ctx.measureText(testLine).width;
                
                if (testWidth > tooltipWidth - 20 && i > 0) {
                    lines.push(line);
                    line = words[i] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line);
            
            // ç»˜åˆ¶å¤šè¡Œæ–‡æœ¬
            for (let i = 0; i < lines.length; i++) {
                ctx.fillText(lines[i], x, y - 40 + i * lineHeight);
            }
        }
        
        // æ£€æŸ¥å…ƒç´ æ˜¯å¦è¢«æ‚¬åœ
        function isElementHovered(element) {
            if (!animationState.hoveredElement) return false;
            return animationState.hoveredElement === element;
        }
        
        // æ›´æ–°UIä¿¡æ¯
        function updateUI() {
            const scene = scenes[animationState.currentScene];
            const stepTitle = document.getElementById('stepTitle');
            const stepDescription = document.getElementById('stepDescription');
            
            if (animationState.currentScene === 'overview' || animationState.currentScene === 'full') {
                stepTitle.textContent = scene.title;
                stepDescription.textContent = scene.description;
            } else {
                stepTitle.textContent = scene.titles[animationState.step];
                stepDescription.textContent = scene.descriptions[animationState.step];
            }
            
            // æ›´æ–°åœºæ™¯æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.scene-btn').forEach(btn => {
                if (btn.dataset.scene === animationState.currentScene) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        
        // åˆ‡æ¢åœºæ™¯
        function switchScene(sceneName) {
            animationState.currentScene = sceneName;
            animationState.step = 0;
            animationState.time = 0;
            initAnimationElements();
            updateUI();
        }
        
        // ä¸‹ä¸€æ­¥
        function nextStep() {
            const scene = scenes[animationState.currentScene];
            if (animationState.currentScene === 'overview' || animationState.currentScene === 'full') {
                // è¿™äº›åœºæ™¯åªæœ‰ä¸€æ­¥ï¼Œå¾ªç¯æ’­æ”¾åŠ¨ç”»
                animationState.time += 0.1;
            } else {
                animationState.step = (animationState.step + 1) % scene.steps;
                initAnimationElements();
            }
            updateUI();
        }
        
        // ä¸Šä¸€æ­¥
        function prevStep() {
            const scene = scenes[animationState.currentScene];
            if (animationState.currentScene === 'overview' || animationState.currentScene === 'full') {
                // è¿™äº›åœºæ™¯åªæœ‰ä¸€æ­¥
                animationState.time -= 0.1;
            } else {
                animationState.step = (animationState.step - 1 + scene.steps) % scene.steps;
                initAnimationElements();
            }
            updateUI();
        }
        
        // é‡ç½®åŠ¨ç”»
        function resetAnimation() {
            animationState.step = 0;
            animationState.time = 0;
            initAnimationElements();
            updateUI();
        }
        
        // æ£€æµ‹é¼ æ ‡æ‚¬åœ
        function checkHover(mouseX, mouseY) {
            animationState.hoveredElement = null;
            
            for (let i = animationElements.length - 1; i >= 0; i--) {
                const element = animationElements[i];
                let isHovered = false;
                
                // æ ¹æ®å…ƒç´ ç±»å‹æ£€æµ‹æ‚¬åœ
                switch (element.type) {
                    case 'chloroplast':
                    case 'stroma':
                        const dx = mouseX - element.x;
                        const dy = mouseY - element.y;
                        const rx = element.width / 2;
                        const ry = element.height / 2;
                        isHovered = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1;
                        break;
                        
                    case 'thylakoid':
                    case 'thylakoidMembrane':
                    case 'stromaBackground':
                    case 'thylakoidSection':
                    case 'stromaSection':
                        isHovered = mouseX >= element.x - element.width/2 && 
                                   mouseX <= element.x + element.width/2 && 
                                   mouseY >= element.y - element.height/2 && 
                                   mouseY <= element.y + element.height/2;
                        break;
                        
                    case 'photon':
                    case 'water':
                    case 'oxygen':
                    case 'proton':
                    case 'atp':
                    case 'nadph':
                    case 'co2':
                    case 'rubp':
                    case 'pga':
                    case 'atpInput':
                    case 'nadphInput':
                    case 'g3p':
                    case 'rubpRegen':
                    case 'atpFlow':
                    case 'nadphFlow':
                    case 'co2Flow':
                    case 'sugarOutput':
                        const distance = Math.sqrt(
                            Math.pow(mouseX - element.x, 2) + 
                            Math.pow(mouseY - element.y, 2)
                        );
                        isHovered = distance <= element.radius * 1.5;
                        break;
                        
                    case 'electronChain':
                        isHovered = mouseY >= element.y - 15 && 
                                   mouseY <= element.y + 15 && 
                                   mouseX >= element.x - element.length/2 && 
                                   mouseX <= element.x + element.length/2;
                        break;
                        
                    case 'atpSynthase':
                        isHovered = mouseX >= element.x - element.width/2 && 
                                   mouseX <= element.x + element.width/2 && 
                                   mouseY >= element.y - element.height/2 && 
                                   mouseY <= element.y + element.height/2;
                        break;
                        
                    case 'calvinCycle':
                        const distToCenter = Math.sqrt(
                            Math.pow(mouseX - element.x, 2) + 
                            Math.pow(mouseY - element.y, 2)
                        );
                        isHovered = distToCenter <= element.radius + 10;
                        break;
                }
                
                if (isHovered) {
                    animationState.hoveredElement = element;
                    break;
                }
            }
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        
        // åˆå§‹åŒ–
        function init() {
            // åˆå§‹åŒ–Canvas
            resizeCanvas();
            
            // åˆå§‹åŒ–åŠ¨ç”»å…ƒç´ 
            initAnimationElements();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            // åœºæ™¯æŒ‰é’®
            document.querySelectorAll('.scene-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    switchScene(btn.dataset.scene);
                });
            });
            
            // æ§åˆ¶æŒ‰é’®
            document.getElementById('playBtn').addEventListener('click', () => {
                animationState.isPlaying = true;
            });
            
            document.getElementById('pauseBtn').addEventListener('click', () => {
                animationState.isPlaying = false;
            });
            
            document.getElementById('stepBtn').addEventListener('click', nextStep);
            
            document.getElementById('resetBtn').addEventListener('click', resetAnimation);
            
            // é€Ÿåº¦æ»‘å—
            document.getElementById('speedSlider').addEventListener('input', (e) => {
                animationState.animationSpeed = parseInt(e.target.value);
            });
            
            // é¼ æ ‡ç§»åŠ¨æ£€æµ‹
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                checkHover(mouseX, mouseY);
            });
            
            canvas.addEventListener('mouseleave', () => {
                animationState.hoveredElement = null;
            });
            
            // é”®ç›˜æ§åˆ¶
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case ' ':
                        animationState.isPlaying = !animationState.isPlaying;
                        break;
                    case 'ArrowRight':
                        nextStep();
                        break;
                    case 'ArrowLeft':
                        prevStep();
                        break;
                    case 'r':
                    case 'R':
                        resetAnimation();
                        break;
                    case '1':
                        switchScene('overview');
                        break;
                    case '2':
                        switchScene('light');
                        break;
                    case '3':
                        switchScene('dark');
                        break;
                    case '4':
                        switchScene('full');
                        break;
                }
            });
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
            
            // åˆå§‹UIæ›´æ–°
            updateUI();
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
        
        // æ·»åŠ  roundRect æ–¹æ³•ï¼ˆå¦‚æœæµè§ˆå™¨ä¸æ”¯æŒï¼‰
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                if (width < 2 * radius) radius = width / 2;
                if (height < 2 * radius) radius = height / 2;
                this.beginPath();
                this.moveTo(x + radius, y);
                this.arcTo(x + width, y, x + width, y + height, radius);
                this.arcTo(x + width, y + height, x, y + height, radius);
                this.arcTo(x, y + height, x, y, radius);
                this.arcTo(x, y, x + width, y, radius);
                this.closePath();
                return this;
            };
        }
    </script>
</body>
</html>