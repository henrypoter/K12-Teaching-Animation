<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äºŒå‰æ ‘éå†é€’å½’è¿‡ç¨‹å¯è§†åŒ–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #2196F3;
        }

        h1 {
            color: #1565C0;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .control-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group h3 {
            color: #2196F3;
            font-size: 1em;
            margin-bottom: 5px;
        }

        .tree-selector, .traversal-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 8px 16px;
            background-color: #E3F2FD;
            border: 1px solid #BBDEFB;
            border-radius: 6px;
            cursor: pointer;
            color: #1565C0;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn:hover {
            background-color: #BBDEFB;
            transform: translateY(-2px);
        }

        .btn.active {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .animation-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-slider {
            width: 120px;
        }

        .status-display {
            background-color: #FFF3E0;
            padding: 12px 20px;
            border-radius: 8px;
            border-left: 4px solid #FFA726;
            font-weight: 500;
            color: #333;
            min-height: 50px;
            display: flex;
            align-items: center;
        }

        .visualization-area {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .tree-section {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }

        .tree-section h2 {
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #E0E0E0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tree-section h2 .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .preorder .color-indicator { background-color: #FFCDD2; }
        .inorder .color-indicator { background-color: #C8E6C9; }
        .postorder .color-indicator { background-color: #BBDEFB; }

        .tree-container {
            flex: 1;
            position: relative;
            min-height: 300px;
            border: 1px solid #E0E0E0;
            border-radius: 8px;
            overflow: auto;
            background-color: #fafafa;
        }

        .code-container, .stack-container, .sequence-container {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #E0E0E0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow: auto;
        }

        .code-line {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .code-line.highlighted {
            background-color: #FFF3E0;
            font-weight: bold;
        }

        .stack-visualization {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            gap: 5px;
            min-height: 150px;
        }

        .stack-frame {
            background-color: #E3F2FD;
            border: 2px solid #BBDEFB;
            border-radius: 6px;
            padding: 10px 15px;
            width: 80%;
            text-align: center;
            font-weight: 500;
            color: #1565C0;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stack-frame.active {
            background-color: #BBDEFB;
            border-color: #2196F3;
            transform: scale(1.05);
        }

        .sequence-visualization {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            min-height: 60px;
        }

        .sequence-node {
            background-color: #C8E6C9;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #2E7D32;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s;
        }

        .sequence-node.new {
            background-color: #81C784;
            transform: scale(1.1);
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .node-default { background-color: white; border: 2px solid #333; }
        .node-current { background-color: #FFA726; }
        .node-visited { background-color: #C8E6C9; }

        @media (max-width: 1200px) {
            .visualization-area {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸŒ³ äºŒå‰æ ‘éå†é€’å½’è¿‡ç¨‹å¯è§†åŒ–</h1>
            <p class="subtitle">å‰åºã€ä¸­åºã€ååºéå†çš„é€’å½’è¿‡ç¨‹ã€æŒ‡é’ˆç§»åŠ¨ä¸è°ƒç”¨æ ˆå¯è§†åŒ–</p>
        </header>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <h3>äºŒå‰æ ‘ç»“æ„</h3>
                    <div class="tree-selector">
                        <button class="btn active" data-tree="balanced">å¹³è¡¡äºŒå‰æ ‘</button>
                        <button class="btn" data-tree="left-skewed">å·¦æ–œæ ‘</button>
                        <button class="btn" data-tree="right-skewed">å³æ–œæ ‘</button>
                        <button class="btn" data-tree="custom">æ™®é€šäºŒå‰æ ‘</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>éå†æ¨¡å¼</h3>
                    <div class="traversal-selector">
                        <button class="btn active" data-traversal="preorder">å‰åºéå† (Vâ†’Lâ†’R)</button>
                        <button class="btn" data-traversal="inorder">ä¸­åºéå† (Lâ†’Vâ†’R)</button>
                        <button class="btn" data-traversal="postorder">ååºéå† (Lâ†’Râ†’V)</button>
                        <label style="display: flex; align-items: center; gap: 8px; margin-left: 10px;">
                            <input type="checkbox" id="compare-mode"> å¯¹æ¯”æ¨¡å¼
                        </label>
                    </div>
                </div>

                <div class="control-group animation-controls">
                    <h3>åŠ¨ç”»æ§åˆ¶</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" id="start-pause">â–¶ï¸ å¼€å§‹</button>
                        <button class="btn" id="next-step">â­ï¸ ä¸‹ä¸€æ­¥</button>
                        <button class="btn" id="prev-step">â®ï¸ ä¸Šä¸€æ­¥</button>
                        <button class="btn" id="reset">ğŸ”„ é‡ç½®</button>
                    </div>
                    <div class="speed-control">
                        <span>é€Ÿåº¦:</span>
                        <input type="range" min="1" max="10" value="5" class="speed-slider" id="speed-slider">
                        <span id="speed-value">ä¸­é€Ÿ</span>
                    </div>
                </div>
            </div>

            <div class="status-display" id="status-display">
                è¯·é€‰æ‹©éå†æ¨¡å¼å¹¶ç‚¹å‡»"å¼€å§‹"æŒ‰é’®å¯åŠ¨åŠ¨ç”»ã€‚
            </div>

            <div class="visualization-area" id="visualization-area">
                <!-- å‰åºéå†è§†å›¾ -->
                <div class="tree-section preorder" id="preorder-section">
                    <h2><span class="color-indicator"></span>å‰åºéå† (Vâ†’Lâ†’R)</h2>
                    <div class="tree-container" id="preorder-tree">
                        <canvas id="preorder-canvas" width="600" height="300"></canvas>
                    </div>
                    <div class="code-container" id="preorder-code">
                        <div class="code-line">function preorder(node) {</div>
                        <div class="code-line">    if (node == null) return;</div>
                        <div class="code-line">    visit(node);           // V</div>
                        <div class="code-line">    preorder(node.left);  // L</div>
                        <div class="code-line">    preorder(node.right); // R</div>
                        <div class="code-line">}</div>
                    </div>
                    <div class="stack-container">
                        <h3>é€’å½’è°ƒç”¨æ ˆ</h3>
                        <div class="stack-visualization" id="preorder-stack"></div>
                    </div>
                    <div class="sequence-container">
                        <h3>è®¿é—®åºåˆ—</h3>
                        <div class="sequence-visualization" id="preorder-sequence"></div>
                    </div>
                </div>

                <!-- ä¸­åºéå†è§†å›¾ -->
                <div class="tree-section inorder" id="inorder-section" style="display: none;">
                    <h2><span class="color-indicator"></span>ä¸­åºéå† (Lâ†’Vâ†’R)</h2>
                    <div class="tree-container" id="inorder-tree">
                        <canvas id="inorder-canvas" width="600" height="300"></canvas>
                    </div>
                    <div class="code-container" id="inorder-code">
                        <div class="code-line">function inorder(node) {</div>
                        <div class="code-line">    if (node == null) return;</div>
                        <div class="code-line">    inorder(node.left);   // L</div>
                        <div class="code-line">    visit(node);          // V</div>
                        <div class="code-line">    inorder(node.right);  // R</div>
                        <div class="code-line">}</div>
                    </div>
                    <div class="stack-container">
                        <h3>é€’å½’è°ƒç”¨æ ˆ</h3>
                        <div class="stack-visualization" id="inorder-stack"></div>
                    </div>
                    <div class="sequence-container">
                        <h3>è®¿é—®åºåˆ—</h3>
                        <div class="sequence-visualization" id="inorder-sequence"></div>
                    </div>
                </div>

                <!-- ååºéå†è§†å›¾ -->
                <div class="tree-section postorder" id="postorder-section" style="display: none;">
                    <h2><span class="color-indicator"></span>ååºéå† (Lâ†’Râ†’V)</h2>
                    <div class="tree-container" id="postorder-tree">
                        <canvas id="postorder-canvas" width="600" height="300"></canvas>
                    </div>
                    <div class="code-container" id="postorder-code">
                        <div class="code-line">function postorder(node) {</div>
                        <div class="code-line">    if (node == null) return;</div>
                        <div class="code-line">    postorder(node.left);  // L</div>
                        <div class="code-line">    postorder(node.right); // R</div>
                        <div class="code-line">    visit(node);           // V</div>
                        <div class="code-line">}</div>
                    </div>
                    <div class="stack-container">
                        <h3>é€’å½’è°ƒç”¨æ ˆ</h3>
                        <div class="stack-visualization" id="postorder-stack"></div>
                    </div>
                    <div class="sequence-container">
                        <h3>è®¿é—®åºåˆ—</h3>
                        <div class="sequence-visualization" id="postorder-sequence"></div>
                    </div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color node-default"></div>
                    <span>æœªè®¿é—®èŠ‚ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-current"></div>
                    <span>å½“å‰èŠ‚ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color node-visited"></div>
                    <span>å·²è®¿é—®èŠ‚ç‚¹</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #FFF3E0;"></div>
                    <span>å½“å‰æ‰§è¡Œä»£ç è¡Œ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #BBDEFB;"></div>
                    <span>æ´»åŠ¨æ ˆå¸§</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // äºŒå‰æ ‘èŠ‚ç‚¹ç±»
        class TreeNode {
            constructor(value, x, y) {
                this.value = value;
                this.left = null;
                this.right = null;
                this.x = x;
                this.y = y;
                this.radius = 25;
                this.state = 'default'; // 'default', 'current', 'visited'
            }
        }

        // éå†çŠ¶æ€ç±»
        class TraversalState {
            constructor(type) {
                this.type = type; // 'preorder', 'inorder', 'postorder'
                this.currentNode = null;
                this.callStack = [];
                this.visitedSequence = [];
                this.isAnimating = false;
                this.speed = 500; // æ¯«ç§’
                this.stepIndex = 0;
                this.traversalSteps = [];
                this.codeLines = [];
                this.initCodeLines();
            }

            initCodeLines() {
                if (this.type === 'preorder') {
                    this.codeLines = [2, 3, 4, 5, 6];
                } else if (this.type === 'inorder') {
                    this.codeLines = [2, 3, 4, 5, 6];
                } else if (this.type === 'postorder') {
                    this.codeLines = [2, 3, 4, 5, 6];
                }
            }

            reset() {
                this.currentNode = null;
                this.callStack = [];
                this.visitedSequence = [];
                this.isAnimating = false;
                this.stepIndex = 0;
                this.traversalSteps = [];
            }

            generateSteps(node) {
                this.traversalSteps = [];
                this._generateStepsRecursive(node, []);
                return this.traversalSteps;
            }

            _generateStepsRecursive(node, stack) {
                if (!node) {
                    this.traversalSteps.push({
                        action: 'return',
                        node: null,
                        stack: [...stack],
                        codeLine: 2
                    });
                    return;
                }

                // æ ¹æ®éå†ç±»å‹ç”Ÿæˆä¸åŒçš„æ­¥éª¤åºåˆ—
                if (this.type === 'preorder') {
                    // å‰åº: V -> L -> R
                    this.traversalSteps.push({
                        action: 'enter',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'V'}],
                        codeLine: 2
                    });
                    
                    this.traversalSteps.push({
                        action: 'visit',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'L'}],
                        codeLine: 3
                    });
                    
                    this._generateStepsRecursive(node.left, [...stack, {node: node, nextAction: 'R'}]);
                    
                    this.traversalSteps.push({
                        action: 'enter_right',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'R'}],
                        codeLine: 5
                    });
                    
                    this._generateStepsRecursive(node.right, [...stack]);
                    
                    this.traversalSteps.push({
                        action: 'return',
                        node: node,
                        stack: [...stack],
                        codeLine: 6
                    });
                } else if (this.type === 'inorder') {
                    // ä¸­åº: L -> V -> R
                    this.traversalSteps.push({
                        action: 'enter',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'L'}],
                        codeLine: 2
                    });
                    
                    this._generateStepsRecursive(node.left, [...stack, {node: node, nextAction: 'V'}]);
                    
                    this.traversalSteps.push({
                        action: 'visit',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'R'}],
                        codeLine: 4
                    });
                    
                    this.traversalSteps.push({
                        action: 'enter_right',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'R'}],
                        codeLine: 5
                    });
                    
                    this._generateStepsRecursive(node.right, [...stack]);
                    
                    this.traversalSteps.push({
                        action: 'return',
                        node: node,
                        stack: [...stack],
                        codeLine: 6
                    });
                } else if (this.type === 'postorder') {
                    // ååº: L -> R -> V
                    this.traversalSteps.push({
                        action: 'enter',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'L'}],
                        codeLine: 2
                    });
                    
                    this._generateStepsRecursive(node.left, [...stack, {node: node, nextAction: 'R'}]);
                    
                    this.traversalSteps.push({
                        action: 'enter_right',
                        node: node,
                        stack: [...stack, {node: node, nextAction: 'R'}],
                        codeLine: 4
                    });
                    
                    this._generateStepsRecursive(node.right, [...stack, {node: node, nextAction: 'V'}]);
                    
                    this.traversalSteps.push({
                        action: 'visit',
                        node: node,
                        stack: [...stack],
                        codeLine: 5
                    });
                    
                    this.traversalSteps.push({
                        action: 'return',
                        node: node,
                        stack: [...stack],
                        codeLine: 6
                    });
                }
            }

            getCurrentStep() {
                if (this.stepIndex < this.traversalSteps.length) {
                    return this.traversalSteps[this.stepIndex];
                }
                return null;
            }

            nextStep() {
                if (this.stepIndex < this.traversalSteps.length) {
                    const step = this.traversalSteps[this.stepIndex];
                    this.stepIndex++;
                    
                    // æ›´æ–°çŠ¶æ€
                    if (step.action === 'visit') {
                        this.visitedSequence.push(step.node.value);
                        step.node.state = 'visited';
                    } else if (step.action === 'enter' || step.action === 'enter_right') {
                        this.currentNode = step.node;
                        step.node.state = 'current';
                    } else if (step.action === 'return') {
                        if (this.currentNode) {
                            this.currentNode.state = 'visited';
                        }
                        this.currentNode = null;
                    }
                    
                    this.callStack = step.stack;
                    return step;
                }
                return null;
            }

            prevStep() {
                if (this.stepIndex > 0) {
                    this.stepIndex--;
                    const step = this.traversalSteps[this.stepIndex];
                    
                    // å›é€€çŠ¶æ€
                    if (step.action === 'visit') {
                        this.visitedSequence.pop();
                        step.node.state = 'default';
                    } else if (step.action === 'enter' || step.action === 'enter_right') {
                        step.node.state = 'default';
                        this.currentNode = null;
                    } else if (step.action === 'return') {
                        // æŸ¥æ‰¾å‰ä¸€ä¸ªèŠ‚ç‚¹
                        if (this.stepIndex > 0) {
                            const prevStep = this.traversalSteps[this.stepIndex - 1];
                            if (prevStep.node) {
                                this.currentNode = prevStep.node;
                                this.currentNode.state = 'current';
                            }
                        }
                    }
                    
                    // æ›´æ–°è°ƒç”¨æ ˆ
                    if (this.stepIndex > 0) {
                        this.callStack = this.traversalSteps[this.stepIndex - 1].stack;
                    } else {
                        this.callStack = [];
                    }
                    
                    return step;
                }
                return null;
            }
        }

        // ä¸»åº”ç”¨ç±»
        class BinaryTreeVisualizer {
            constructor() {
                this.treeRoot = null;
                this.traversalStates = {
                    preorder: new TraversalState('preorder'),
                    inorder: new TraversalState('inorder'),
                    postorder: new TraversalState('postorder')
                };
                this.currentTraversal = 'preorder';
                this.compareMode = false;
                this.animationInterval = null;
                this.speed = 5;
                
                this.initTree();
                this.initEventListeners();
                this.render();
            }

            initTree() {
                // åˆ›å»ºå¹³è¡¡äºŒå‰æ ‘
                this.createBalancedTree();
            }

            createBalancedTree() {
                // åˆ›å»ºèŠ‚ç‚¹
                const root = new TreeNode('A', 300, 50);
                const b = new TreeNode('B', 200, 120);
                const c = new TreeNode('C', 400, 120);
                const d = new TreeNode('D', 150, 190);
                const e = new TreeNode('E', 250, 190);
                const f = new TreeNode('F', 350, 190);
                const g = new TreeNode('G', 450, 190);
                
                // æ„å»ºæ ‘ç»“æ„
                root.left = b;
                root.right = c;
                b.left = d;
                b.right = e;
                c.left = f;
                c.right = g;
                
                this.treeRoot = root;
                this.resetAllTraversals();
            }

            createLeftSkewedTree() {
                const root = new TreeNode('A', 400, 50);
                const b = new TreeNode('B', 350, 120);
                const c = new TreeNode('C', 300, 190);
                const d = new TreeNode('D', 250, 260);
                
                root.left = b;
                b.left = c;
                c.left = d;
                
                this.treeRoot = root;
                this.resetAllTraversals();
            }

            createRightSkewedTree() {
                const root = new TreeNode('A', 200, 50);
                const b = new TreeNode('B', 250, 120);
                const c = new TreeNode('C', 300, 190);
                const d = new TreeNode('D', 350, 260);
                
                root.right = b;
                b.right = c;
                c.right = d;
                
                this.treeRoot = root;
                this.resetAllTraversals();
            }

            createCustomTree() {
                const root = new TreeNode('A', 300, 50);
                const b = new TreeNode('B', 200, 120);
                const c = new TreeNode('C', 400, 120);
                const d = new TreeNode('D', 150, 190);
                const e = new TreeNode('E', 350, 190);
                const f = new TreeNode('F', 450, 190);
                
                root.left = b;
                root.right = c;
                b.left = d;
                c.left = e;
                c.right = f;
                
                this.treeRoot = root;
                this.resetAllTraversals();
            }

            resetAllTraversals() {
                // é‡ç½®æ‰€æœ‰èŠ‚ç‚¹çŠ¶æ€
                this.resetNodeStates(this.treeRoot);
                
                // é‡ç½®æ‰€æœ‰éå†çŠ¶æ€
                Object.values(this.traversalStates).forEach(state => {
                    state.reset();
                    state.generateSteps(this.treeRoot);
                });
            }

            resetNodeStates(node) {
                if (!node) return;
                node.state = 'default';
                this.resetNodeStates(node.left);
                this.resetNodeStates(node.right);
            }

            initEventListeners() {
                // æ ‘ç»“æ„é€‰æ‹©
                document.querySelectorAll('.tree-selector .btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tree-selector .btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const treeType = btn.dataset.tree;
                        if (treeType === 'balanced') {
                            this.createBalancedTree();
                        } else if (treeType === 'left-skewed') {
                            this.createLeftSkewedTree();
                        } else if (treeType === 'right-skewed') {
                            this.createRightSkewedTree();
                        } else if (treeType === 'custom') {
                            this.createCustomTree();
                        }
                        
                        this.render();
                    });
                });

                // éå†æ¨¡å¼é€‰æ‹©
                document.querySelectorAll('.traversal-selector .btn[data-traversal]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.traversal-selector .btn[data-traversal]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        this.currentTraversal = btn.dataset.traversal;
                        this.updateViewVisibility();
                        this.render();
                    });
                });

                // å¯¹æ¯”æ¨¡å¼åˆ‡æ¢
                document.getElementById('compare-mode').addEventListener('change', (e) => {
                    this.compareMode = e.target.checked;
                    this.updateViewVisibility();
                    this.render();
                });

                // åŠ¨ç”»æ§åˆ¶
                document.getElementById('start-pause').addEventListener('click', () => {
                    this.toggleAnimation();
                });

                document.getElementById('next-step').addEventListener('click', () => {
                    this.stopAnimation();
                    this.nextStep();
                });

                document.getElementById('prev-step').addEventListener('click', () => {
                    this.stopAnimation();
                    this.prevStep();
                });

                document.getElementById('reset').addEventListener('click', () => {
                    this.stopAnimation();
                    this.resetAllTraversals();
                    this.render();
                });

                // é€Ÿåº¦æ§åˆ¶
                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    this.speed = parseInt(e.target.value);
                    document.getElementById('speed-value').textContent = 
                        this.speed <= 3 ? 'æ…¢é€Ÿ' : this.speed <= 7 ? 'ä¸­é€Ÿ' : 'å¿«é€Ÿ';
                    
                    if (this.animationInterval) {
                        this.stopAnimation();
                        this.startAnimation();
                    }
                });
            }

            updateViewVisibility() {
                const preorderSection = document.getElementById('preorder-section');
                const inorderSection = document.getElementById('inorder-section');
                const postorderSection = document.getElementById('postorder-section');
                const visualizationArea = document.getElementById('visualization-area');
                
                if (this.compareMode) {
                    // å¯¹æ¯”æ¨¡å¼ï¼šæ˜¾ç¤ºæ‰€æœ‰ä¸‰ä¸ªè§†å›¾
                    preorderSection.style.display = 'flex';
                    inorderSection.style.display = 'flex';
                    postorderSection.style.display = 'flex';
                    visualizationArea.style.flexDirection = 'row';
                } else {
                    // å•è§†å›¾æ¨¡å¼ï¼šåªæ˜¾ç¤ºå½“å‰é€‰æ‹©çš„éå†
                    preorderSection.style.display = this.currentTraversal === 'preorder' ? 'flex' : 'none';
                    inorderSection.style.display = this.currentTraversal === 'inorder' ? 'flex' : 'none';
                    postorderSection.style.display = this.currentTraversal === 'postorder' ? 'flex' : 'none';
                    visualizationArea.style.flexDirection = 'column';
                }
            }

            toggleAnimation() {
                const btn = document.getElementById('start-pause');
                if (this.animationInterval) {
                    this.stopAnimation();
                    btn.innerHTML = 'â–¶ï¸ ç»§ç»­';
                } else {
                    this.startAnimation();
                    btn.innerHTML = 'â¸ï¸ æš‚åœ';
                }
            }

            startAnimation() {
                this.stopAnimation();
                
                const interval = 1100 - (this.speed * 100); // é€Ÿåº¦æ˜ å°„ï¼š1=1000ms, 10=100ms
                this.animationInterval = setInterval(() => {
                    if (!this.nextStep()) {
                        this.stopAnimation();
                        document.getElementById('start-pause').innerHTML = 'â–¶ï¸ å¼€å§‹';
                    }
                }, interval);
            }

            stopAnimation() {
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
            }

            nextStep() {
                let stepPerformed = false;
                
                if (this.compareMode) {
                    // å¯¹æ¯”æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰éå†åŒæ—¶å‰è¿›
                    Object.values(this.traversalStates).forEach(state => {
                        if (state.nextStep()) {
                            stepPerformed = true;
                        }
                    });
                } else {
                    // å•è§†å›¾æ¨¡å¼ä¸‹ï¼Œåªå‰è¿›å½“å‰éå†
                    const state = this.traversalStates[this.currentTraversal];
                    if (state.nextStep()) {
                        stepPerformed = true;
                    }
                }
                
                if (stepPerformed) {
                    this.render();
                    this.updateStatus();
                }
                
                return stepPerformed;
            }

            prevStep() {
                let stepPerformed = false;
                
                if (this.compareMode) {
                    // å¯¹æ¯”æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰éå†åŒæ—¶å›é€€
                    Object.values(this.traversalStates).forEach(state => {
                        if (state.prevStep()) {
                            stepPerformed = true;
                        }
                    });
                } else {
                    // å•è§†å›¾æ¨¡å¼ä¸‹ï¼Œåªå›é€€å½“å‰éå†
                    const state = this.traversalStates[this.currentTraversal];
                    if (state.prevStep()) {
                        stepPerformed = true;
                    }
                }
                
                if (stepPerformed) {
                    this.render();
                    this.updateStatus();
                }
            }

            updateStatus() {
                const statusDisplay = document.getElementById('status-display');
                let statusText = '';
                
                if (this.compareMode) {
                    statusText = 'å¯¹æ¯”æ¨¡å¼ï¼šä¸‰ç§éå†åŒæ­¥è¿›è¡Œä¸­...';
                } else {
                    const state = this.traversalStates[this.currentTraversal];
                    const step = state.getCurrentStep();
                    
                    if (step) {
                        const actionMap = {
                            'enter': 'è¿›å…¥èŠ‚ç‚¹',
                            'visit': 'è®¿é—®èŠ‚ç‚¹',
                            'enter_right': 'è¿›å…¥å³å­æ ‘',
                            'return': 'è¿”å›'
                        };
                        
                        const nodeName = step.node ? step.node.value : 'null';
                        statusText = `${actionMap[step.action]} ${nodeName}`;
                        
                        if (step.action === 'visit') {
                            statusText += ` (å·²è®¿é—®èŠ‚ç‚¹: ${state.visitedSequence.join(' â†’ ')})`;
                        }
                    } else {
                        statusText = 'éå†å®Œæˆï¼';
                    }
                }
                
                statusDisplay.textContent = statusText;
            }

            drawTree(canvasId, traversalType) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                const state = this.traversalStates[traversalType];
                
                // æ¸…é™¤ç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶æ ‘
                this.drawTreeRecursive(ctx, this.treeRoot, state);
                
                // ç»˜åˆ¶å½“å‰èŠ‚ç‚¹æŒ‡é’ˆ
                if (state.currentNode) {
                    this.drawPointer(ctx, state.currentNode);
                }
            }

            drawTreeRecursive(ctx, node, state) {
                if (!node) return;
                
                // ç»˜åˆ¶è¿çº¿
                if (node.left) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y + node.radius);
                    ctx.lineTo(node.left.x, node.left.y - node.left.radius);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                if (node.right) {
                    ctx.beginPath();
                    ctx.moveTo(node.x, node.y + node.radius);
                    ctx.lineTo(node.right.x, node.right.y - node.right.radius);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å­èŠ‚ç‚¹
                this.drawTreeRecursive(ctx, node.left, state);
                this.drawTreeRecursive(ctx, node.right, state);
                
                // ç»˜åˆ¶å½“å‰èŠ‚ç‚¹
                this.drawNode(ctx, node, state);
            }

            drawNode(ctx, node, state) {
                // è®¾ç½®èŠ‚ç‚¹é¢œè‰²
                let fillColor = '#FFFFFF';
                if (node.state === 'current') {
                    fillColor = '#FFA726';
                } else if (node.state === 'visited') {
                    fillColor = '#C8E6C9';
                }
                
                // ç»˜åˆ¶èŠ‚ç‚¹åœ†
                ctx.beginPath();
                ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç»˜åˆ¶èŠ‚ç‚¹å€¼
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.value, node.x, node.y);
            }

            drawPointer(ctx, node) {
                // ç»˜åˆ¶æŒ‡å‘å½“å‰èŠ‚ç‚¹çš„ä¸‰è§’å½¢æŒ‡é’ˆ
                ctx.beginPath();
                ctx.moveTo(node.x, node.y - node.radius - 15);
                ctx.lineTo(node.x - 10, node.y - node.radius - 5);
                ctx.lineTo(node.x + 10, node.y - node.radius - 5);
                ctx.closePath();
                ctx.fillStyle = '#FF5722';
                ctx.fill();
                
                // æ·»åŠ æŒ‡é’ˆåŠ¨ç”»æ•ˆæœ
                ctx.beginPath();
                ctx.arc(node.x, node.y - node.radius - 10, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#FFF';
                ctx.fill();
            }

            updateCodeHighlight(traversalType) {
                const state = this.traversalStates[traversalType];
                const step = state.getCurrentStep();
                const codeContainer = document.getElementById(`${traversalType}-code`);
                
                // æ¸…é™¤æ‰€æœ‰é«˜äº®
                codeContainer.querySelectorAll('.code-line').forEach(line => {
                    line.classList.remove('highlighted');
                });
                
                // é«˜äº®å½“å‰ä»£ç è¡Œ
                if (step && step.codeLine
<!--æ£€æµ‹åˆ°ä»£ç æˆªæ–­ï¼Œè‡ªåŠ¨ç»­å†™ä¸­...-->
) {
                    const lines = codeContainer.querySelectorAll('.code-line');
                    if (step.codeLine - 1 < lines.length) {
                        lines[step.codeLine - 1].classList.add('highlighted');
                    }
                }
            }

            updateStackVisualization(traversalType) {
                const state = this.traversalStates[traversalType];
                const stackContainer = document.getElementById(`${traversalType}-stack`);
                
                // æ¸…ç©ºæ ˆæ˜¾ç¤º
                stackContainer.innerHTML = '';
                
                // æ˜¾ç¤ºæ ˆå¸§ï¼ˆä»æ ˆåº•åˆ°æ ˆé¡¶ï¼‰
                const stackFrames = [...state.callStack].reverse();
                
                stackFrames.forEach((frame, index) => {
                    const frameElement = document.createElement('div');
                    frameElement.className = 'stack-frame';
                    
                    // æœ€åä¸€ä¸ªæ ˆå¸§æ˜¯æ´»åŠ¨çš„
                    if (index === 0) {
                        frameElement.classList.add('active');
                    }
                    
                    frameElement.textContent = `${frame.node.value} (ä¸‹ä¸€æ­¥: ${frame.nextAction})`;
                    stackContainer.appendChild(frameElement);
                });
                
                // å¦‚æœæ ˆä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
                if (stackFrames.length === 0) {
                    const emptyFrame = document.createElement('div');
                    emptyFrame.className = 'stack-frame';
                    emptyFrame.textContent = 'è°ƒç”¨æ ˆä¸ºç©º';
                    stackContainer.appendChild(emptyFrame);
                }
            }

            updateSequenceVisualization(traversalType) {
                const state = this.traversalStates[traversalType];
                const sequenceContainer = document.getElementById(`${traversalType}-sequence`);
                
                // æ¸…ç©ºåºåˆ—æ˜¾ç¤º
                sequenceContainer.innerHTML = '';
                
                // æ˜¾ç¤ºè®¿é—®åºåˆ—
                state.visitedSequence.forEach((value, index) => {
                    const nodeElement = document.createElement('div');
                    nodeElement.className = 'sequence-node';
                    
                    // æœ€åä¸€ä¸ªèŠ‚ç‚¹æ˜¯æ–°è®¿é—®çš„
                    if (index === state.visitedSequence.length - 1) {
                        nodeElement.classList.add('new');
                    }
                    
                    nodeElement.textContent = value;
                    sequenceContainer.appendChild(nodeElement);
                    
                    // æ·»åŠ ç®­å¤´ï¼ˆé™¤äº†æœ€åä¸€ä¸ªï¼‰
                    if (index < state.visitedSequence.length - 1) {
                        const arrow = document.createElement('span');
                        arrow.textContent = 'â†’';
                        arrow.style.color = '#666';
                        arrow.style.margin = '0 5px';
                        sequenceContainer.appendChild(arrow);
                    }
                });
                
                // å¦‚æœåºåˆ—ä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
                if (state.visitedSequence.length === 0) {
                    const emptyText = document.createElement('div');
                    emptyText.textContent = 'å°šæœªè®¿é—®ä»»ä½•èŠ‚ç‚¹';
                    emptyText.style.color = '#999';
                    emptyText.style.fontStyle = 'italic';
                    sequenceContainer.appendChild(emptyText);
                }
            }

            render() {
                // æ›´æ–°æ‰€æœ‰è§†å›¾
                const traversals = this.compareMode ? 
                    ['preorder', 'inorder', 'postorder'] : 
                    [this.currentTraversal];
                
                traversals.forEach(traversalType => {
                    // ç»˜åˆ¶æ ‘
                    this.drawTree(`${traversalType}-canvas`, traversalType);
                    
                    // æ›´æ–°ä»£ç é«˜äº®
                    this.updateCodeHighlight(traversalType);
                    
                    // æ›´æ–°æ ˆå¯è§†åŒ–
                    this.updateStackVisualization(traversalType);
                    
                    // æ›´æ–°åºåˆ—å¯è§†åŒ–
                    this.updateSequenceVisualization(traversalType);
                });
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                this.updateStatus();
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            const visualizer = new BinaryTreeVisualizer();
            
            // åˆå§‹æ¸²æŸ“
            visualizer.render();
            
            // å°†visualizeræš´éœ²ç»™å…¨å±€ï¼Œä¾¿äºè°ƒè¯•
            window.visualizer = visualizer;
        });
    </script>
</body>
</html>