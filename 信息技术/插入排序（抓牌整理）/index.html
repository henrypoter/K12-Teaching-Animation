<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>插入排序（抓牌整理）教学动画</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #007bff;
        }

        h1 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #6c757d;
            font-size: 1.1rem;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
        }

        .visualization-section {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
        }

        .code-section {
            flex: 1;
            min-width: 300px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
        }

        .section-title {
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e9ecef;
            font-size: 1.3rem;
        }

        #animation-container {
            width: 100%;
            height: 300px;
            position: relative;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }

        .array-element {
            position: absolute;
            width: 60px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.5rem;
            transition: all 0.5s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            border: 2px solid transparent;
        }

        .sorted-region {
            position: absolute;
            height: 90px;
            background-color: rgba(195, 230, 203, 0.3);
            border-radius: 8px;
            border: 2px dashed #c3e6cb;
            transition: all 0.5s ease;
        }

        .unsorted-region {
            position: absolute;
            height: 90px;
            background-color: rgba(233, 236, 239, 0.3);
            border-radius: 8px;
            border: 2px dashed #e9ecef;
            transition: all 0.5s ease;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-play {
            background-color: #28a745;
            color: white;
        }

        .btn-play:hover {
            background-color: #218838;
        }

        .btn-pause {
            background-color: #ffc107;
            color: #333;
        }

        .btn-pause:hover {
            background-color: #e0a800;
        }

        .btn-next,
        .btn-prev {
            background-color: #007bff;
            color: white;
        }

        .btn-next:hover,
        .btn-prev:hover {
            background-color: #0069d9;
        }

        .btn-reset {
            background-color: #6c757d;
            color: white;
        }

        .btn-reset:hover {
            background-color: #5a6268;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        #speedSlider {
            width: 120px;
        }

        .code-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            overflow-x: auto;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .code-line {
            padding: 2px 5px;
            margin: 2px 0;
            border-radius: 3px;
            transition: background-color 0.3s;
        }

        .highlight {
            background-color: #fff3cd;
        }

        .variables-panel {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid #e9ecef;
        }

        .variables-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
        }

        .variable-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .variable-name {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .variable-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #333;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-panel {
            background-color: #e7f3ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #007bff;
        }

        .status-title {
            font-weight: bold;
            color: #007bff;
            margin-bottom: 8px;
        }

        .status-text {
            color: #333;
        }

        .explanation {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            margin-top: 20px;
        }

        .explanation h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        .explanation p {
            margin-bottom: 10px;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .controls {
                justify-content: center;
            }

            .speed-control {
                margin-left: 0;
                margin-top: 10px;
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>插入排序（抓牌整理）教学动画</h1>
        <p class="subtitle">像整理扑克牌一样理解插入排序算法</p>
    </header>

    <div class="container">
        <div class="main-content">
            <section class="visualization-section">
                <h2 class="section-title">排序过程可视化</h2>
                <div id="animation-container">
                    <!-- 数组元素将通过JS动态生成 -->
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #fd7e14;"></div>
                        <span>当前待插入元素 (key)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #007bff;"></div>
                        <span>正在比较的元素</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #c3e6cb;"></div>
                        <span>已排序区域</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e9ecef;"></div>
                        <span>未排序区域</span>
                    </div>
                </div>

                <div class="controls">
                    <button id="playBtn" class="btn-play">
                        <span>▶ 播放</span>
                    </button>
                    <button id="pauseBtn" class="btn-pause">
                        <span>⏸ 暂停</span>
                    </button>
                    <button id="prevBtn" class="btn-prev">
                        <span>◀ 上一步</span>
                    </button>
                    <button id="nextBtn" class="btn-next">
                        <span>▶ 下一步</span>
                    </button>
                    <button id="resetBtn" class="btn-reset">
                        <span>↺ 重置</span>
                    </button>

                    <div class="speed-control">
                        <span>速度:</span>
                        <input type="range" id="speedSlider" min="1" max="10" value="5">
                        <span id="speedValue">中速</span>
                    </div>
                </div>

                <div class="status-panel">
                    <div class="status-title">当前状态</div>
                    <div id="statusText" class="status-text">点击"播放"开始排序动画</div>
                </div>
            </section>

            <section class="code-section">
                <h2 class="section-title">算法代码</h2>
                <div class="code-container">
                    <div id="codeLine1" class="code-line">for (i = 1; i < n; i++) {</div>
                            <div id="codeLine2" class="code-line"> key = arr[i];</div>
                            <div id="codeLine3" class="code-line"> j = i - 1;</div>
                            <div id="codeLine4" class="code-line"> </div>
                            <div id="codeLine5" class="code-line"> while (j >= 0 && arr[j] > key) {</div>
                            <div id="codeLine6" class="code-line"> arr[j + 1] = arr[j];</div>
                            <div id="codeLine7" class="code-line"> j = j - 1;</div>
                            <div id="codeLine8" class="code-line"> }</div>
                            <div id="codeLine9" class="code-line"> </div>
                            <div id="codeLine10" class="code-line"> arr[j + 1] = key;</div>
                            <div id="codeLine11" class="code-line">}</div>
                    </div>

                    <div class="variables-panel">
                        <h3 class="section-title">当前变量值</h3>
                        <div class="variables-grid">
                            <div class="variable-item">
                                <div class="variable-name">i (当前索引)</div>
                                <div id="varI" class="variable-value">-</div>
                            </div>
                            <div class="variable-item">
                                <div class="variable-name">key (待插入值)</div>
                                <div id="varKey" class="variable-value">-</div>
                            </div>
                            <div class="variable-item">
                                <div class="variable-name">j (比较索引)</div>
                                <div id="varJ" class="variable-value">-</div>
                            </div>
                            <div class="variable-item">
                                <div class="variable-name">循环次数</div>
                                <div id="varLoop" class="variable-value">0</div>
                            </div>
                        </div>
                    </div>
            </section>
        </div>

        <section class="explanation">
            <h3>插入排序算法解析</h3>
            <p><strong>核心思想：</strong>插入排序的工作方式像整理手中的扑克牌。每次从未排序部分取出一张牌（元素），将其插入到已排序部分的正确位置。</p>
            <p><strong>算法步骤：</strong></p>
            <ol>
                <li>从第二个元素开始（索引 i=1），将其作为待插入元素（key）。</li>
                <li>将 key 与已排序部分的元素从右向左依次比较。</li>
                <li>如果已排序部分的元素大于 key，则将该元素向右移动一位，为 key 腾出空间。</li>
                <li>重复步骤3，直到找到 key 的正确插入位置。</li>
                <li>将 key 插入到正确位置。</li>
                <li>对未排序部分的所有元素重复上述过程。</li>
            </ol>
            <p><strong>时间复杂度：</strong>最坏情况 O(n²)，最好情况 O(n)（当数组已排序时）。</p>
            <p><strong>空间复杂度：</strong>O(1)（原地排序）。</p>
        </section>
    </div>

    <script>
        // 插入排序算法状态机
        class InsertionSortAnimation {
            constructor() {
                // 初始数据
                this.originalArray = [5, 2, 9, 1, 7, 4, 8, 3, 6];
                this.array = [...this.originalArray];
                this.n = this.array.length;

                // 算法状态变量
                this.i = 1;      // 外层循环索引
                this.j = 0;      // 内层循环索引
                this.key = 0;    // 当前待插入值
                this.loopCount = 0; // 循环计数

                // 动画状态
                this.isPlaying = false;
                this.speed = 5;  // 1-10，值越大速度越快
                this.animationInterval = null;
                this.currentStep = 0; // 当前步骤
                this.stepHistory = []; // 步骤历史，用于回退

                // 算法阶段
                this.phase = 'init'; // init, pick, compare, shift, insert, done
                this.comparing = false;
                this.shifting = false;

                // DOM 元素引用
                this.animationContainer = document.getElementById('animation-container');
                this.statusText = document.getElementById('statusText');
                this.varI = document.getElementById('varI');
                this.varKey = document.getElementById('varKey');
                this.varJ = document.getElementById('varJ');
                this.varLoop = document.getElementById('varLoop');
                this.speedSlider = document.getElementById('speedSlider');
                this.speedValue = document.getElementById('speedValue');

                // 代码高亮元素
                this.codeLines = [];
                for (let i = 1; i <= 11; i++) {
                    this.codeLines.push(document.getElementById(`codeLine${i}`));
                }

                // 初始化
                this.init();
                this.renderArray();
                this.updateVariables();
                this.updateStatus();
                this.setupEventListeners();
            }

            init() {
                // 重置状态
                this.array = [...this.originalArray];
                this.i = 1;
                this.j = 0;
                this.key = 0;
                this.loopCount = 0;
                this.phase = 'init';
                this.comparing = false;
                this.shifting = false;
                this.currentStep = 0;
                this.stepHistory = [];

                // 清除高亮
                this.clearCodeHighlight();

                // 保存初始状态
                this.saveStep();
            }

            saveStep() {
                this.stepHistory.push({
                    array: [...this.array],
                    i: this.i,
                    j: this.j,
                    key: this.key,
                    loopCount: this.loopCount,
                    phase: this.phase,
                    comparing: this.comparing,
                    shifting: this.shifting
                });
            }

            restorePreviousStep() {
                if (this.stepHistory.length > 1) {
                    this.stepHistory.pop(); // 移除当前状态
                    const prevState = this.stepHistory[this.stepHistory.length - 1];

                    this.array = [...prevState.array];
                    this.i = prevState.i;
                    this.j = prevState.j;
                    this.key = prevState.key;
                    this.loopCount = prevState.loopCount;
                    this.phase = prevState.phase;
                    this.comparing = prevState.comparing;
                    this.shifting = prevState.shifting;

                    this.renderArray();
                    this.updateVariables();
                    this.updateStatus();
                    this.updateCodeHighlight();

                    return true;
                }
                return false;
            }

            renderArray() {
                // 清空容器
                this.animationContainer.innerHTML = '';

                const containerWidth = this.animationContainer.clientWidth;
                const containerHeight = this.animationContainer.clientHeight;
                const elementWidth = 60;
                const elementHeight = 80;
                const spacing = 20;
                const totalWidth = this.n * elementWidth + (this.n - 1) * spacing;
                const startX = (containerWidth - totalWidth) / 2;
                const y = (containerHeight - elementHeight) / 2;

                // 绘制已排序区域
                if (this.i > 0) {
                    const sortedRegion = document.createElement('div');
                    sortedRegion.className = 'sorted-region';
                    sortedRegion.style.width = `${this.i * elementWidth + (this.i - 1) * spacing}px`;
                    sortedRegion.style.left = `${startX}px`;
                    sortedRegion.style.top = `${y - 5}px`;
                    this.animationContainer.appendChild(sortedRegion);
                }

                // 绘制未排序区域
                if (this.i < this.n) {
                    const unsortedRegion = document.createElement('div');
                    unsortedRegion.className = 'unsorted-region';
                    unsortedRegion.style.width = `${(this.n - this.i) * elementWidth + (this.n - this.i - 1) * spacing}px`;
                    unsortedRegion.style.left = `${startX + this.i * elementWidth + this.i * spacing}px`;
                    unsortedRegion.style.top = `${y - 5}px`;
                    this.animationContainer.appendChild(unsortedRegion);
                }

                // 绘制数组元素
                for (let index = 0; index < this.n; index++) {
                    const element = document.createElement('div');
                    element.className = 'array-element';

                    // 确定是否是当前 key 的位置
                    // 在 compare 或 shift 阶段，key 在 j+1 位置（即空出的位置）
                    // 在 pick 阶段，key 在 i 位置
                    let isKeyPos = false;
                    if ((this.phase === 'compare' || this.phase === 'shift') && index === this.j + 1) {
                        isKeyPos = true;
                    } else if (this.phase === 'pick' && index === this.i) {
                        isKeyPos = true;
                    }

                    // 设置内容：如果是 key 的位置且在排序过程中，显示 key 值，否则显示数组值
                    if (isKeyPos && this.phase !== 'done' && this.phase !== 'init') {
                        element.textContent = this.key;
                    } else {
                        element.textContent = this.array[index];
                    }

                    element.style.left = `${startX + index * (elementWidth + spacing)}px`;
                    element.style.top = `${y}px`;

                    // 设置元素颜色
                    if (isKeyPos && this.phase !== 'done') {
                        // 当前待插入元素 (Key)
                        element.style.backgroundColor = '#fd7e14';
                        element.style.color = 'white';
                        element.style.borderColor = '#e8590c';
                        element.style.zIndex = '10';
                        // 让 Key 稍微浮起一点，增强"抓牌"效果
                        element.style.transform = 'translateY(-10px)';
                        element.style.boxShadow = '0 10px 20px rgba(0,0,0,0.2)';
                    } else if (this.comparing && index === this.j) {
                        // 正在比较的元素
                        element.style.backgroundColor = '#007bff';
                        element.style.color = 'white';
                        element.style.borderColor = '#0056b3';
                        element.style.zIndex = '5';
                    } else if (index < this.i) {
                        // 已排序区域
                        element.style.backgroundColor = '#c3e6cb';
                        element.style.color = '#155724';
                        element.style.borderColor = '#b1dfbb';
                    } else {
                        // 未排序区域
                        element.style.backgroundColor = '#e9ecef';
                        element.style.color = '#495057';
                        element.style.borderColor = '#dee2e6';
                    }

                    // 如果排序完成，所有元素变为完成色
                    if (this.phase === 'done') {
                        element.style.backgroundColor = '#155724';
                        element.style.color = 'white';
                        element.style.borderColor = '#0c4128';
                        element.style.transform = 'none';
                        element.style.boxShadow = '';
                    }

                    this.animationContainer.appendChild(element);
                }
            }

            updateVariables() {
                this.varI.textContent = this.i < this.n ? this.i : '完成';
                this.varKey.textContent = this.key > 0 ? this.key : '-';
                this.varJ.textContent = this.j >= 0 ? this.j : '-';
                this.varLoop.textContent = this.loopCount;
            }

            updateStatus() {
                let status = '';

                switch (this.phase) {
                    case 'init':
                        status = '准备开始排序。点击"播放"按钮开始动画。';
                        break;
                    case 'pick':
                        status = `选取第 ${this.i + 1} 个元素 (值=${this.array[this.i]}) 作为待插入元素。`;
                        break;
                    case 'compare':
                        status = `比较待插入元素 (${this.key}) 与已排序元素 arr[${this.j}] = ${this.array[this.j]}。`;
                        if (this.j >= 0 && this.array[this.j] > this.key) {
                            status += ` 因为 ${this.array[this.j]} > ${this.key}，需要向右移动。`;
                        } else if (this.j >= 0) {
                            status += ` 因为 ${this.array[this.j]} ≤ ${this.key}，找到插入位置。`;
                        }
                        break;
                    case 'shift':
                        status = `将 arr[${this.j}] = ${this.array[this.j]} 向右移动一位。`;
                        break;
                    case 'insert':
                        status = `将待插入元素 (${this.key}) 插入到 arr[${this.j + 1}] 的位置。`;
                        break;
                    case 'done':
                        status = '排序完成！所有元素已按升序排列。';
                        break;
                }

                this.statusText.textContent = status;
            }

            updateCodeHighlight() {
                // 清除所有高亮
                this.clearCodeHighlight();

                // 根据当前阶段高亮对应代码行
                switch (this.phase) {
                    case 'pick':
                        this.codeLines[0].classList.add('highlight'); // for循环
                        this.codeLines[1].classList.add('highlight'); // key = arr[i]
                        break;
                    case 'compare':
                        this.codeLines[2].classList.add('highlight'); // j = i-1
                        this.codeLines[4].classList.add('highlight'); // while循环条件
                        break;
                    case 'shift':
                        this.codeLines[5].classList.add('highlight'); // arr[j+1] = arr[j]
                        this.codeLines[6].classList.add('highlight'); // j = j-1
                        break;
                    case 'insert':
                        this.codeLines[9].classList.add('highlight'); // arr[j+1] = key
                        break;
                    case 'done':
                        this.codeLines[10].classList.add('highlight'); // 循环结束
                        break;
                }
            }

            clearCodeHighlight() {
                this.codeLines.forEach(line => line.classList.remove('highlight'));
            }

            nextStep() {
                // 保存当前步骤
                this.saveStep();

                // 执行算法下一步
                switch (this.phase) {
                    case 'init':
                        this.phase = 'pick';
                        this.key = this.array[this.i];
                        this.updateCodeHighlight();
                        break;

                    case 'pick':
                        this.phase = 'compare';
                        this.j = this.i - 1;
                        this.comparing = true;
                        this.updateCodeHighlight();
                        break;

                    case 'compare':
                        if (this.j >= 0 && this.array[this.j] > this.key) {
                            this.phase = 'shift';
                            this.shifting = true;
                        } else {
                            this.phase = 'insert';
                            this.comparing = false;
                        }
                        this.updateCodeHighlight();
                        break;

                    case 'shift':
                        // 执行移动操作
                        this.array[this.j + 1] = this.array[this.j];
                        this.j = this.j - 1;

                        // 渲染移动效果
                        this.renderArray();

                        // 判断下一步
                        if (this.j >= 0 && this.array[this.j] > this.key) {
                            this.phase = 'compare';
                            this.shifting = false;
                            this.comparing = true;
                        } else {
                            this.phase = 'insert';
                            this.shifting = false;
                            this.comparing = false;
                        }
                        this.updateCodeHighlight();
                        break;

                    case 'insert':
                        // 执行插入操作
                        this.array[this.j + 1] = this.key;

                        // 准备下一轮循环
                        this.i++;
                        this.loopCount++;

                        if (this.i < this.n) {
                            this.phase = 'pick';
                            this.key = this.array[this.i];
                        } else {
                            this.phase = 'done';
                        }

                        this.comparing = false;
                        this.shifting = false;
                        this.updateCodeHighlight();
                        break;

                    case 'done':
                        // 排序已完成，不再前进
                        return;
                }

                this.renderArray();
                this.updateVariables();
                this.updateStatus();
                this.currentStep++;
            }

            prevStep() {
                if (this.restorePreviousStep()) {
                    this.currentStep--;
                }
            }

            play() {
                if (this.phase === 'done') {
                    this.reset();
                }

                this.isPlaying = true;
                const speedMap = {
                    1: 1500, 2: 1200, 3: 1000, 4: 800, 5: 600,
                    6: 500, 7: 400, 8: 300, 9: 200, 10: 100
                };

                const intervalTime = speedMap[this.speed] || 600;

                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                }

                this.animationInterval = setInterval(() => {
                    if (this.phase === 'done') {
                        this.pause();
                        return;
                    }

                    this.nextStep();
                }, intervalTime);
            }

            pause() {
                this.isPlaying = false;
                if (this.animationInterval) {
                    clearInterval(this.animationInterval);
                    this.animationInterval = null;
                }
            }

            reset() {
                this.pause();
                this.init();
                this.renderArray();
                this.updateVariables();
                this.updateStatus();
            }

            setSpeed(value) {
                this.speed = parseInt(value);
                const speedLabels = {
                    1: '极慢', 2: '很慢', 3: '慢速', 4: '较慢', 5: '中速',
                    6: '较快', 7: '快速', 8: '很快', 9: '极快', 10: '最快'
                };
                this.speedValue.textContent = speedLabels[this.speed] || '中速';

                // 如果正在播放，更新播放速度
                if (this.isPlaying) {
                    this.pause();
                    this.play();
                }
            }

            setupEventListeners() {
                document.getElementById('playBtn').addEventListener('click', () => {
                    this.play();
                });

                document.getElementById('pauseBtn').addEventListener('click', () => {
                    this.pause();
                });

                document.getElementById('nextBtn').addEventListener('click', () => {
                    this.pause();
                    this.nextStep();
                });

                document.getElementById('prevBtn').addEventListener('click', () => {
                    this.pause();
                    this.prevStep();
                });

                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });

                this.speedSlider.addEventListener('input', (e) => {
                    this.setSpeed(e.target.value);
                });

                // 初始速度设置
                this.speedSlider.value = this.speed;
                this.setSpeed(this.speed);

                // 窗口大小变化时重新渲染
                window.addEventListener('resize', () => {
                    this.renderArray();
                });
            }
        }

        // 页面加载完成后初始化动画
        document.addEventListener('DOMContentLoaded', () => {
            const insertionSort = new InsertionSortAnimation();
        });
    </script>
</body>

</html>