<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>阶乘递归调用栈动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        h1 {
            color: #2196f3;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 20px;
        }

        .control-panel {
            flex: 1;
            min-width: 300px;
        }

        .code-panel {
            flex: 1;
            min-width: 300px;
        }

        .animation-panel {
            flex: 2;
            min-width: 500px;
            min-height: 500px;
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: 600;
            color: #2196f3;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus {
            border-color: #2196f3;
            outline: none;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-primary {
            background-color: #2196f3;
            color: white;
        }

        .btn-primary:hover {
            background-color: #0d8bf2;
        }

        .btn-success {
            background-color: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background-color: #3d8b40;
        }

        .btn-warning {
            background-color: #ff9800;
            color: white;
        }

        .btn-warning:hover {
            background-color: #e68900;
        }

        .btn-secondary {
            background-color: #9e9e9e;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #757575;
        }

        .speed-control {
            margin-top: 15px;
        }

        .speed-control label {
            margin-bottom: 5px;
        }

        .speed-slider {
            width: 100%;
            margin-top: 5px;
        }

        .code-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 15px;
            line-height: 1.5;
            overflow-x: auto;
            border: 1px solid #e0e0e0;
        }

        .code-line {
            padding: 4px 8px;
            margin: 2px 0;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .code-line.highlighted {
            background-color: #e3f2fd;
            border-left: 3px solid #2196f3;
        }

        .code-keyword {
            color: #2196f3;
            font-weight: bold;
        }

        .code-function {
            color: #e91e63;
        }

        .code-number {
            color: #4caf50;
        }

        .code-operator {
            color: #ff9800;
        }

        #animationCanvas {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            background-color: white;
            display: block;
        }

        .status-panel {
            flex: 100%;
            min-height: 100px;
            margin-top: 10px;
        }

        .status-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #2196f3;
            margin-bottom: 10px;
        }

        .status-content {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            min-height: 70px;
            font-size: 16px;
        }

        .status-step {
            font-weight: 600;
            color: #2196f3;
            margin-bottom: 5px;
        }

        .status-desc {
            color: #333;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-text {
            font-size: 14px;
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            color: #666;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .animation-panel {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>阶乘递归调用栈动画</h1>
        <p class="subtitle">可视化理解递归函数的执行过程与调用栈变化</p>
    </div>

    <div class="container">
        <div class="panel control-panel">
            <div class="panel-title">控制面板</div>
            
            <div class="input-group">
                <label for="inputNumber">计算阶乘 factorial(n):</label>
                <input type="number" id="inputNumber" min="0" max="10" value="5">
                <button id="btnStart" class="btn-primary" style="margin-top: 10px; width: 100%;">
                    <span>开始演示</span>
                </button>
            </div>

            <div class="button-group">
                <button id="btnPrev" class="btn-secondary">
                    <span>上一步</span>
                </button>
                <button id="btnNext" class="btn-primary">
                    <span>下一步</span>
                </button>
                <button id="btnPlayPause" class="btn-success">
                    <span>播放</span>
                </button>
                <button id="btnReset" class="btn-warning">
                    <span>重置</span>
                </button>
            </div>

            <div class="speed-control">
                <label for="speedSlider">动画速度:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="5" class="speed-slider">
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e3f2fd; border: 2px solid #2196f3;"></div>
                    <div class="legend-text">当前活动栈帧</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #eeeeee; border: 1px solid #9e9e9e;"></div>
                    <div class="legend-text">非活动栈帧</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4caf50;"></div>
                    <div class="legend-text">"递"过程 (调用)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff9800;"></div>
                    <div class="legend-text">"归"过程 (返回)</div>
                </div>
            </div>
        </div>

        <div class="panel code-panel">
            <div class="panel-title">递归函数代码</div>
            <div class="code-container">
                <div id="codeLine1" class="code-line">
                    <span class="code-keyword">function</span> <span class="code-function">factorial</span>(<span class="code-number">n</span>) {
                </div>
                <div id="codeLine2" class="code-line">
                    &nbsp;&nbsp;<span class="code-keyword">if</span> (<span class="code-number">n</span> <span class="code-operator"><=</span> <span class="code-number">1</span>) {
                </div>
                <div id="codeLine3" class="code-line">
                    &nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">return</span> <span class="code-number">1</span>;
                </div>
                <div id="codeLine4" class="code-line">
                    &nbsp;&nbsp;}
                </div>
                <div id="codeLine5" class="code-line">
                    &nbsp;&nbsp;<span class="code-keyword">return</span> <span class="code-number">n</span> <span class="code-operator">*</span> <span class="code-function">factorial</span>(<span class="code-number">n</span> <span class="code-operator">-</span> <span class="code-number">1</span>);
                </div>
                <div id="codeLine6" class="code-line">
                    }
                </div>
            </div>
        </div>

        <div class="panel animation-panel">
            <div class="panel-title">调用栈动画</div>
            <canvas id="animationCanvas"></canvas>
        </div>

        <div class="panel status-panel">
            <div class="panel-title">执行状态</div>
            <div class="status-content">
                <div id="statusStep" class="status-step">准备开始</div>
                <div id="statusDesc" class="status-desc">请输入一个非负整数 n，然后点击"开始演示"按钮。</div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p>阶乘递归调用栈动画 | 设计用于理解递归执行过程与函数调用栈</p>
    </div>

    <script>
        // 全局变量
        let canvas, ctx;
        let n = 5; // 默认计算的阶乘数
        let stack = []; // 调用栈
        let animationSteps = []; // 动画步骤
        let currentStep = 0; // 当前步骤索引
        let isPlaying = false; // 是否正在播放
        let playInterval; // 播放定时器
        let animationSpeed = 5; // 动画速度 (1-10)
        let returnValues = {}; // 存储返回值 {depth: value}
        
        // 栈帧类
        class StackFrame {
            constructor(depth, nValue, expression, isActive = false) {
                this.depth = depth; // 递归深度
                this.nValue = nValue; // n的值
                this.expression = expression; // 表达式文本
                this.isActive = isActive; // 是否是活动栈帧
                this.returnValue = null; // 返回值
                this.isReturning = false; // 是否正在返回
            }
        }
        
        // 动画步骤类
        class AnimationStep {
            constructor(type, depth, nValue, description, codeLine) {
                this.type = type; // 'call', 'return', 'compute'
                this.depth = depth; // 栈深度
                this.nValue = nValue; // n的值
                this.description = description; // 描述
                this.codeLine = codeLine; // 高亮的代码行
            }
        }
        
        // 初始化
        function init() {
            canvas = document.getElementById('animationCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化事件监听
            setupEventListeners();
            
            // 初始状态
            updateStatus("准备开始", "请输入一个非负整数 n，然后点击'开始演示'按钮。");
        }
        
        // 调整Canvas尺寸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        
        // 设置事件监听
        function setupEventListeners() {
            // 开始演示按钮
            document.getElementById('btnStart').addEventListener('click', startDemo);
            
            // 控制按钮
            document.getElementById('btnPrev').addEventListener('click', prevStep);
            document.getElementById('btnNext').addEventListener('click', nextStep);
            document.getElementById('btnPlayPause').addEventListener('click', togglePlayPause);
            document.getElementById('btnReset').addEventListener('click', reset);
            
            // 速度滑块
            document.getElementById('speedSlider').addEventListener('input', function() {
                animationSpeed = parseInt(this.value);
                if (isPlaying) {
                    clearInterval(playInterval);
                    startPlayInterval();
                }
            });
            
            // 输入框回车键
            document.getElementById('inputNumber').addEventListener('keyup', function(e) {
                if (e.key === 'Enter') {
                    startDemo();
                }
            });
        }
        
        // 开始演示
        function startDemo() {
            const input = document.getElementById('inputNumber');
            n = parseInt(input.value);
            
            if (isNaN(n) || n < 0 || n > 10) {
                alert("请输入一个0到10之间的整数");
                return;
            }
            
            // 重置状态
            reset();
            
            // 生成动画步骤
            generateAnimationSteps();
            
            // 更新状态
            updateStatus("开始计算", `开始计算 factorial(${n})`);
            
            // 绘制初始状态
            draw();
        }
        
        // 生成动画步骤
        function generateAnimationSteps() {
            animationSteps = [];
            
            // 生成调用步骤
            for (let i = n; i >= 1; i--) {
                const depth = n - i;
                let expression = `factorial(${i})`;
                if (i > 1) {
                    expression += ` = ${i} × factorial(${i-1})`;
                } else {
                    expression += ` = 1 (基准情况)`;
                }
                
                animationSteps.push(new AnimationStep(
                    'call', 
                    depth, 
                    i, 
                    `调用 factorial(${i})，需要计算 ${i > 1 ? `${i} × factorial(${i-1})` : '基准情况'}`,
                    1
                ));
                
                // 添加计算步骤（仅对非基准情况）
                if (i > 1) {
                    animationSteps.push(new AnimationStep(
                        'compute', 
                        depth, 
                        i, 
                        `等待 factorial(${i-1}) 的结果来计算 ${i} × factorial(${i-1})`,
                        5
                    ));
                } else {
                    animationSteps.push(new AnimationStep(
                        'compute', 
                        depth, 
                        i, 
                        `到达基准情况，factorial(1) = 1`,
                        2
                    ));
                }
            }
            
            // 生成返回步骤
            for (let i = 1; i <= n; i++) {
                const depth = n - i;
                let result = 1;
                for (let j = 1; j <= i; j++) {
                    result *= j;
                }
                
                animationSteps.push(new AnimationStep(
                    'return', 
                    depth, 
                    i, 
                    `factorial(${i}) 返回 ${result}`,
                    i === 1 ? 3 : 5
                ));
                
                // 存储返回值
                returnValues[depth] = result;
            }
            
            // 添加最终结果步骤
            animationSteps.push(new AnimationStep(
                'complete', 
                0, 
                n, 
                `计算完成！factorial(${n}) = ${returnValues[0]}`,
                6
            ));
        }
        
        // 执行下一步
        function nextStep() {
            if (currentStep >= animationSteps.length) return;
            
            const step = animationSteps[currentStep];
            
            // 根据步骤类型更新栈
            if (step.type === 'call') {
                // 添加新的栈帧
                let expression = `factorial(${step.nValue})`;
                if (step.nValue > 1) {
                    expression += ` = ${step.nValue} × factorial(${step.nValue-1})`;
                } else {
                    expression += ` = 1`;
                }
                
                // 将之前的栈帧设为非活动
                stack.forEach(frame => frame.isActive = false);
                
                // 添加新栈帧
                stack.push(new StackFrame(step.depth, step.nValue, expression, true));
                
            } else if (step.type === 'return') {
                // 设置当前栈帧为返回状态
                const currentFrame = stack[stack.length - 1];
                if (currentFrame) {
                    currentFrame.isReturning = true;
                    currentFrame.returnValue = returnValues[step.depth];
                    
                    // 如果是最后一个返回步骤，移除栈帧
                    if (step.nValue === n) {
                        setTimeout(() => {
                            stack.pop();
                            draw();
                        }, 300);
                    }
                }
                
            } else if (step.type === 'compute') {
                // 计算步骤，不需要改变栈，只是状态更新
            }
            
            // 更新代码高亮
            highlightCodeLine(step.codeLine);
            
            // 更新状态文本
            updateStatus(
                step.type === 'call' ? "递归调用 (递)" : 
                step.type === 'return' ? "返回结果 (归)" : 
                step.type === 'compute' ? "等待结果" : "计算完成",
                step.description
            );
            
            // 增加步骤索引
            currentStep++;
            
            // 如果到达最后一步，停止播放
            if (currentStep >= animationSteps.length && isPlaying) {
                togglePlayPause();
            }
            
            // 重绘
            draw();
        }
        
        // 执行上一步
        function prevStep() {
            if (currentStep <= 0) return;
            
            // 减少步骤索引
            currentStep--;
            
            // 由于动画步骤是线性的，回退需要重新生成栈状态
            // 这里简化处理：重置栈然后重新执行到上一步
            const tempStep = currentStep;
            resetStack();
            currentStep = 0;
            
            for (let i = 0; i < tempStep; i++) {
                const step = animationSteps[i];
                
                if (step.type === 'call') {
                    let expression = `factorial(${step.nValue})`;
                    if (step.nValue > 1) {
                        expression += ` = ${step.nValue} × factorial(${step.nValue-1})`;
                    } else {
                        expression += ` = 1`;
                    }
                    
                    stack.forEach(frame => frame.isActive = false);
                    stack.push(new StackFrame(step.depth, step.nValue, expression, true));
                    
                } else if (step.type === 'return') {
                    const currentFrame = stack[stack.length - 1];
                    if (currentFrame) {
                        currentFrame.isReturning = true;
                        currentFrame.returnValue = returnValues[step.depth];
                    }
                }
            }
            
            // 更新代码高亮和状态
            if (tempStep > 0) {
                const step = animationSteps[tempStep - 1];
                highlightCodeLine(step.codeLine);
                updateStatus(
                    step.type === 'call' ? "递归调用 (递)" : 
                    step.type === 'return' ? "返回结果 (归)" : 
                    step.type === 'compute' ? "等待结果" : "计算完成",
                    step.description
                );
            } else {
                highlightCodeLine(0);
                updateStatus("准备开始", "请输入一个非负整数 n，然后点击'开始演示'按钮。");
            }
            
            // 重绘
            draw();
        }
        
        // 切换播放/暂停
        function togglePlayPause() {
            const btn = document.getElementById('btnPlayPause');
            
            if (isPlaying) {
                // 暂停
                clearInterval(playInterval);
                btn.innerHTML = '<span>播放</span>';
                btn.className = 'btn-success';
            } else {
                // 播放
                // 如果已经完成，从头开始
                if (currentStep >= animationSteps.length) {
                    resetStack();
                    currentStep = 0;
                }
                
                startPlayInterval();
                btn.innerHTML = '<span>暂停</span>';
                btn.className = 'btn-warning';
            }
            
            isPlaying = !isPlaying;
        }
        
        // 开始播放定时器
        function startPlayInterval() {
            const interval = 1100 - (animationSpeed * 100); // 速度从1000ms到100ms
            playInterval = setInterval(nextStep, interval);
        }
        
        // 重置
        function reset() {
            // 停止播放
            if (isPlaying) {
                togglePlayPause();
            }
            
            // 重置状态
            resetStack();
            animationSteps = [];
            currentStep = 0;
            returnValues = {};
            
            // 更新UI
            highlightCodeLine(0);
            updateStatus("准备开始", "请输入一个非负整数 n，然后点击'开始演示'按钮。");
            
            // 重绘
            draw();
        }
        
        // 重置栈
        function resetStack() {
            stack = [];
        }
        
        // 更新状态显示
        function updateStatus(step, description) {
            document.getElementById('statusStep').textContent = step;
            document.getElementById('statusDesc').textContent = description;
        }
        
        // 高亮代码行
        function highlightCodeLine(lineNumber) {
            // 移除所有高亮
            for (let i = 1; i <= 6; i++) {
                document.getElementById(`codeLine${i}`).classList.remove('highlighted');
            }
            
            // 高亮指定行
            if (lineNumber > 0 && lineNumber <= 6) {
                document.getElementById(`codeLine${lineNumber}`).classList.add('highlighted');
            }
        }
        
        // 绘制函数
        function draw() {
            if (!ctx) return;
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制标题
            ctx.fillStyle = '#333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`递归调用栈: factorial(${n})`, canvas.width / 2, 30);
            
            // 如果没有栈帧，显示提示
            if (stack.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('点击"开始演示"查看调用栈动画', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // 栈绘制参数
            const stackStartX = canvas.width / 2;
            const stackStartY = canvas.height - 50;
            const frameWidth = 200;
            const frameHeight = 80;
            const frameSpacing = 20;
            
            // 绘制栈帧
            for (let i = 0; i < stack.length; i++) {
                const frame = stack[i];
                const frameY = stackStartY - i * (frameHeight + frameSpacing);
                
                // 绘制栈帧背景
                if (frame.isActive) {
                    // 活动栈帧
                    ctx.fillStyle = '#e3f2fd';
                    ctx.strokeStyle = '#2196f3';
                    ctx.lineWidth = 3;
                } else {
                    // 非活动栈帧
                    ctx.fillStyle = '#eeeeee';
                    ctx.strokeStyle = '#9e9e9e';
                    ctx.lineWidth = 1;
                }
                
                // 绘制矩形
                ctx.fillRect(stackStartX - frameWidth / 2, frameY - frameHeight / 2, frameWidth, frameHeight);
                ctx.strokeRect(stackStartX - frameWidth / 2, frameY - frameHeight / 2, frameWidth, frameHeight);
                
                // 绘制栈帧内容
                ctx.fillStyle = '#333';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`factorial(${frame.nValue})`, stackStartX, frameY - 20);
                
                ctx.font = '16px Arial';
                ctx.fillText(frame.expression, stackStartX, frameY + 5);
                
                // 如果正在返回，显示返回值
                if (frame.isReturning && frame.returnValue) {
                    ctx.fillStyle = '#ff9800';
                    ctx.font = 'bold 18px Arial';
                    ctx.fillText(`返回: ${frame.returnValue}`, stackStartX, frameY + 25);
                }
                
                // 绘制栈深度标签
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`深度: ${frame.depth}`, stackStartX + frameWidth / 2 - 10, frameY - frameHeight / 2 + 20);
                
                // 绘制栈帧编号
                ctx.textAlign = 'left';
                ctx.fillText(`#${i+1}`, stackStartX - frameWidth / 2 + 10, frameY - frameHeight / 2 + 20);
            }
            
            // 绘制调用箭头（递）
            if (currentStep > 0 && currentStep <= animationSteps.length) {
                const currentAnimationStep = animationSteps[Math.min(currentStep, animationSteps.length - 1)];
                
                if (currentAnimationStep.type === 'call' && stack.length > 1) {
                    const fromFrameIndex = stack.length - 2;
                    const toFrameIndex = stack.length - 1;
                    
                    const fromY = stackStartY - fromFrameIndex * (frameHeight + frameSpacing) + frameHeight / 2;
                    const toY = stackStartY - toFrameIndex * (frameHeight + frameSpacing) - frameHeight / 2;
                    
                    drawArrow(stackStartX, fromY, stackStartX, toY, '#4caf50', '调用');
                }
            }
            
            // 绘制返回箭头（归）
            for (let i = 0; i < stack.length; i++) {
                const frame = stack[i];
                if (frame.isReturning && i > 0) {
                    const fromY = stackStartY - i * (frameHeight + frameSpacing) + frameHeight / 2;
                    const toY = stackStartY - (i - 1) * (frameHeight + frameSpacing) - frameHeight / 2;
                    
                    drawArrow(stackStartX, fromY, stackStartX, toY, '#ff9800', '返回');
                }
            }
            
            // 绘制栈底部
            ctx.fillStyle = '#999';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('栈底', stackStartX, stackStartY + 40);
            
            // 绘制栈指针
            if (stack.length > 0) {
                const topFrameIndex = stack.length - 1;
                const topFrameY = stackStartY - topFrameIndex * (frameHeight + frameSpacing) - frameHeight / 2;
                
                ctx.fillStyle = '#2196f3';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('↑ 栈顶指针', stackStartX + frameWidth / 2 + 20, topFrameY);
            }
        }
        
        // 绘制箭头函数
        function drawArrow(fromX, fromY, toX, toY, color, label) {
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 3;
            
            // 绘制箭头线
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            // 绘制箭头头部
            const headLength = 15;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
            
            // 绘制标签
            ctx.fillStyle = color;
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            
            // 偏移标签位置，避免与线重叠
            const offsetX = Math.sin(angle) * 20;
            const offsetY = -Math.cos(angle) * 20;
            
            ctx.fillText(label, midX + offsetX, midY + offsetY);
        }
        
        // 页面加载完成后初始化
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>