<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图的深度优先搜索（DFS递归染色）教学动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #2d3748;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2.2rem;
            margin-bottom: 8px;
        }

        header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .left-panel {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .right-panel {
            flex: 2;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }

        .card h2 {
            color: #4a5568;
            font-size: 1.4rem;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #edf2f7;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card h2 i {
            color: #fbbf24;
        }

        /* 图控制区 */
        .graph-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 16px;
        }

        select, button {
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid #cbd5e0;
            background-color: white;
            color: #4a5568;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        select {
            flex: 1;
            min-width: 150px;
        }

        button {
            flex: 1;
            min-width: 120px;
            background-color: #edf2f7;
        }

        button:hover {
            background-color: #e2e8f0;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        button.primary {
            background-color: #4299e1;
            color: white;
            border-color: #4299e1;
        }

        button.primary:hover {
            background-color: #3182ce;
        }

        button.warning {
            background-color: #fbbf24;
            color: #78350f;
            border-color: #fbbf24;
        }

        button.warning:hover {
            background-color: #f59e0b;
        }

        /* 动画控制区 */
        .animation-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 200px;
        }

        .speed-control label {
            white-space: nowrap;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fbbf24;
            cursor: pointer;
        }

        /* 视图控制区 */
        .view-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #fbbf24;
        }

        /* 状态图例 */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .color-box {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #4a5568;
        }

        .unvisited { background-color: #ffffff; }
        .visiting { background-color: #fbbf24; }
        .visited { background-color: #34d399; }
        .tree-edge { background-color: #4a5568; height: 4px; margin-top: 10px; }
        .default-edge { background-color: #cbd5e0; height: 4px; margin-top: 10px; }

        /* 画布容器 */
        #graphCanvas {
            width: 100%;
            height: 500px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }

        /* 信息显示区 */
        .info-panel {
            height: 300px;
            display: flex;
            flex-direction: column;
        }

        .info-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }

        .step-log {
            margin-bottom: 20px;
        }

        .step-log h3 {
            color: #4a5568;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        #currentStep {
            background-color: #f7fafc;
            padding: 12px;
            border-radius: 8px;
            border-left: 4px solid #fbbf24;
            font-weight: 500;
            margin-bottom: 16px;
        }

        .data-display {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 16px;
        }

        .data-box {
            flex: 1;
            min-width: 200px;
        }

        .data-box h3 {
            color: #4a5568;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .data-list {
            background-color: #f7fafc;
            padding: 12px;
            border-radius: 8px;
            min-height: 80px;
            max-height: 120px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
        }

        .stack-item {
            padding: 6px 10px;
            margin-bottom: 4px;
            background-color: #fed7aa;
            border-radius: 4px;
            font-weight: 500;
            text-align: center;
        }

        .node-sequence {
            display: inline-block;
            padding: 4px 10px;
            margin: 2px;
            background-color: #d1fae5;
            border-radius: 4px;
            font-weight: 500;
        }

        /* 响应式调整 */
        @media (max-width: 1100px) {
            .main-content {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                min-width: 100%;
            }
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-project-diagram"></i> 图的深度优先搜索（DFS递归染色）</h1>
            <p>通过颜色变化可视化递归遍历过程：白色(未访问) → 琥珀色(访问中) → 绿色(已访问)</p>
        </header>

        <div class="main-content">
            <!-- 左侧控制面板 -->
            <div class="left-panel">
                <!-- 图控制区 -->
                <div class="card">
                    <h2><i class="fas fa-sitemap"></i> 图控制</h2>
                    <div class="graph-controls">
                        <select id="graphPreset">
                            <option value="default">默认连通图</option>
                            <option value="chain">链状图 (0-1-2-3-4)</option>
                            <option value="star">星形图</option>
                            <option value="cycle">简单环</option>
                            <option value="disconnected">不连通图</option>
                            <option value="tree">树状图</option>
                        </select>
                        <button id="randomGraph" class="primary">
                            <i class="fas fa-random"></i> 随机生成
                        </button>
                        <button id="resetGraph" class="warning">
                            <i class="fas fa-redo"></i> 重置图
                        </button>
                    </div>
                    
                    <div class="view-controls">
                        <div class="checkbox-group">
                            <input type="checkbox" id="showStack" checked>
                            <label for="showStack">显示递归栈</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="highlightTreeEdges" checked>
                            <label for="highlightTreeEdges">高亮DFS树边</label>
                        </div>
                    </div>
                </div>

                <!-- 动画控制区 -->
                <div class="card">
                    <h2><i class="fas fa-play-circle"></i> 动画控制</h2>
                    <div class="animation-controls">
                        <button id="startBtn" class="primary">
                            <i class="fas fa-play"></i> 开始
                        </button>
                        <button id="nextBtn">
                            <i class="fas fa-step-forward"></i> 下一步
                        </button>
                        <button id="prevBtn">
                            <i class="fas fa-step-backward"></i> 上一步
                        </button>
                        <button id="resetAnim" class="warning">
                            <i class="fas fa-stop"></i> 重置动画
                        </button>
                    </div>
                    
                    <div class="speed-control">
                        <label for="speedSlider"><i class="fas fa-tachometer-alt"></i> 速度:</label>
                        <input type="range" id="speedSlider" min="100" max="2000" value="800" step="100">
                        <span id="speedValue">0.8s</span>
                    </div>
                </div>

                <!-- 状态图例 -->
                <div class="card">
                    <h2><i class="fas fa-palette"></i> 状态图例</h2>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="color-box unvisited"></div>
                            <span>未访问</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box visiting"></div>
                            <span>访问中 (递归栈中)</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box visited"></div>
                            <span>已访问完成</span>
                        </div>
                    </div>
                    <div class="legend" style="margin-top: 16px;">
                        <div class="legend-item">
                            <div class="color-box tree-edge"></div>
                            <span>DFS树边</span>
                        </div>
                        <div class="legend-item">
                            <div class="color-box default-edge"></div>
                            <span>普通边</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 右侧主面板 -->
            <div class="right-panel">
                <!-- 图可视化区域 -->
                <div class="card" style="padding: 0; overflow: hidden;">
                    <canvas id="graphCanvas"></canvas>
                </div>

                <!-- 信息显示区 -->
                <div class="card info-panel">
                    <h2><i class="fas fa-info-circle"></i> 算法执行信息</h2>
                    <div class="info-content">
                        <div class="step-log">
                            <h3>当前步骤</h3>
                            <div id="currentStep">请选择图并点击"开始"按钮</div>
                        </div>
                        
                        <div class="data-display">
                            <div class="data-box">
                                <h3>递归栈内容 <span id="stackCount">(0)</span></h3>
                                <div class="data-list" id="stackContent">
                                    <div style="color: #a0aec0; text-align: center; padding: 20px;">栈为空</div>
                                </div>
                            </div>
                            
                            <div class="data-box">
                                <h3>访问顺序 (完成顺序)</h3>
                                <div class="data-list" id="visitOrder">
                                    <div style="color: #a0aec0; text-align: center; padding: 20px;">暂无节点</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== 全局变量和常量 ====================
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        
        // 颜色常量
        const COLORS = {
            BACKGROUND: '#ffffff',
            NODE: {
                UNVISITED: '#ffffff',
                VISITING: '#fbbf24',
                VISITED: '#34d399',
                BORDER: '#4a5568',
                TEXT: '#2d3748'
            },
            EDGE: {
                DEFAULT: '#cbd5e0',
                TREE: '#4a5568',
                ACTIVE: '#fbbf24',
                HIGHLIGHT: '#ef6c00'
            },
            STACK: {
                BACKGROUND: '#fed7aa',
                BORDER: '#fbbf24'
            }
        };
        
        // 图数据结构
        let graph = {
            nodes: [],
            edges: [],
            adjacencyList: {}
        };
        
        // 动画状态
        let animationState = {
            isRunning: false,
            isPaused: false,
            currentStepIndex: 0,
            speed: 800, // 毫秒
            visitedOrder: [],
            stack: [],
            currentNode: null,
            treeEdges: new Set()
        };
        
        // 算法步骤记录
        let algorithmSteps = [];
        
        // 视图设置
        let viewSettings = {
            showStack: true,
            highlightTreeEdges: true
        };
        
        // ==================== 初始化 ====================
        function init() {
            // 设置Canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化事件监听器
            initEventListeners();
            
            // 创建默认图
            createDefaultGraph();
            
            // 绘制初始状态
            drawGraph();
            
            // 更新UI
            updateUI();
        }
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawGraph();
        }
        
        function initEventListeners() {
            // 图控制
            document.getElementById('graphPreset').addEventListener('change', function() {
                if (this.value === 'default') createDefaultGraph();
                else if (this.value === 'chain') createChainGraph();
                else if (this.value === 'star') createStarGraph();
                else if (this.value === 'cycle') createCycleGraph();
                else if (this.value === 'disconnected') createDisconnectedGraph();
                else if (this.value === 'tree') createTreeGraph();
                
                resetAnimation();
                drawGraph();
            });
            
            document.getElementById('randomGraph').addEventListener('click', createRandomGraph);
            document.getElementById('resetGraph').addEventListener('click', function() {
                createDefaultGraph();
                resetAnimation();
                drawGraph();
            });
            
            // 视图控制
            document.getElementById('showStack').addEventListener('change', function() {
                viewSettings.showStack = this.checked;
                drawGraph();
            });
            
            document.getElementById('highlightTreeEdges').addEventListener('change', function() {
                viewSettings.highlightTreeEdges = this.checked;
                drawGraph();
            });
            
            // 动画控制
            document.getElementById('startBtn').addEventListener('click', toggleAnimation);
            document.getElementById('nextBtn').addEventListener('click', nextStep);
            document.getElementById('prevBtn').addEventListener('click', prevStep);
            document.getElementById('resetAnim').addEventListener('click', resetAnimation);
            
            // 速度控制
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            
            speedSlider.addEventListener('input', function() {
                animationState.speed = 2100 - this.value; // 反转值，使滑块向右速度更快
                speedValue.textContent = (animationState.speed / 1000).toFixed(1) + 's';
            });
            
            // 初始速度显示
            speedValue.textContent = (animationState.speed / 1000).toFixed(1) + 's';
            speedSlider.value = 2100 - animationState.speed;
        }
        
        // ==================== 图创建函数 ====================
        function createDefaultGraph() {
            // 创建一个简单的连通图
            graph.nodes = [
                {id: 0, x: 0.3, y: 0.3, state: 'unvisited'},
                {id: 1, x: 0.7, y: 0.3, state: 'unvisited'},
                {id: 2, x: 0.7, y: 0.7, state: 'unvisited'},
                {id: 3, x: 0.3, y: 0.7, state: 'unvisited'},
                {id: 4, x: 0.5, y: 0.5, state: 'unvisited'}
            ];
            
            graph.edges = [
                {from: 0, to: 1, type: 'default'},
                {from: 0, to: 3, type: 'default'},
                {from: 0, to: 4, type: 'default'},
                {from: 1, to: 2, type: 'default'},
                {from: 1, to: 4, type: 'default'},
                {from: 2, to: 3, type: 'default'},
                {from: 2, to: 4, type: 'default'},
                {from: 3, to: 4, type: 'default'}
            ];
            
            buildAdjacencyList();
            updateNodePositions();
        }
        
        function createChainGraph() {
            graph.nodes = [];
            graph.edges = [];
            
            // 创建5个节点的链
            for (let i = 0; i < 5; i++) {
                graph.nodes.push({
                    id: i,
                    x: 0.1 + i * 0.2,
                    y: 0.5,
                    state: 'unvisited'
                });
                
                if (i > 0) {
                    graph.edges.push({from: i-1, to: i, type: 'default'});
                }
            }
            
            buildAdjacencyList();
            updateNodePositions();
        }
        
        function createStarGraph() {
            graph.nodes = [];
            graph.edges = [];
            
            // 中心节点
            graph.nodes.push({id: 0, x: 0.5, y: 0.5, state: 'unvisited'});
            
            // 5个外围节点
            const angles = [0, 72, 144, 216, 288];
            for (let i = 0; i < 5; i++) {
                const angle = angles[i] * Math.PI / 180;
                graph.nodes.push({
                    id: i+1,
                    x: 0.5 + 0.3 * Math.cos(angle),
                    y: 0.5 + 0.3 * Math.sin(angle),
                    state: 'unvisited'
                });
                
                graph.edges.push({from: 0, to: i+1, type: 'default'});
            }
            
            buildAdjacencyList();
            updateNodePositions();
        }
        
        function createCycleGraph() {
            graph.nodes = [];
            graph.edges = [];
            
            // 创建6个节点的环
            for (let i = 0; i < 6; i++) {
                const angle = i * 60 * Math.PI / 180;
                graph.nodes.push({
                    id: i,
                    x: 0.5 + 0.3 * Math.cos(angle),
                    y: 0.5 + 0.3 * Math.sin(angle),
                    state: 'unvisited'
                });
                
                graph.edges.push({from: i, to: (i+1) % 6, type: 'default'});
            }
            
            buildAdjacencyList();
            updateNodePositions();
        }
        
        function createDisconnectedGraph() {
            graph.nodes = [];
            graph.edges = [];
            
            // 第一个连通分量 (3个节点)
            for (let i = 0; i < 3; i++) {
                graph.nodes.push({
                    id: i,
                    x: 0.2 + i * 0.15,
                    y: 0.3,
                    state: 'unvisited'
                });
                
                if (i > 0) {
                    graph.edges.push({from: i-1, to: i, type: 'default'});
                }
            }
            
            // 第二个连通分量 (4个节点)
            for (let i = 0; i < 4; i++) {
                graph.nodes.push({
                    id: i+3,
                    x: 0.5 + i * 0.15,
                    y: 0.7,
                    state: 'unvisited'
                });
                
                if (i > 0) {
                    graph.edges.push({from: i+2, to: i+3, type: 'default'});
                }
            }
            
            buildAdjacencyList();
            updateNodePositions();
        }
        
        function createTreeGraph() {
            graph.nodes = [];
            graph.edges = [];
            
            // 创建一棵二叉树
            const nodes = [
                {id: 0, x: 0.5, y: 0.2},  // 根节点
                {id: 1, x: 0.3, y: 0.4},  // 左子节点
                {id: 2, x: 0.7, y: 0.4},  // 右子节点
                {id: 3, x: 0.2, y: 0.6},  // 左左子节点
                {id: 4, x: 0.4, y: 0.6},  // 左右子节点
                {id: 5, x: 0.6, y: 0.6},  // 右左子节点
                {id: 6, x: 0.8, y: 0.6}   // 右右子节点
            ];
            
            graph.nodes = nodes.map(node => ({...node, state: 'unvisited'}));
            
            const edges = [
                {from: 0, to: 1}, {from: 0, to: 2},
                {from: 1, to: 3}, {from: 1, to: 4},
                {from: 2, to: 5}, {from: 2, to: 6}
            ];
            
            graph.edges = edges.map(edge => ({...edge, type: 'default'}));
            
            buildAdjacencyList();
            updateNodePositions();
        }
        
        function createRandomGraph() {
            graph.nodes = [];
            graph.edges = [];
            
            // 随机生成5-8个节点
            const nodeCount = Math.floor(Math.random() * 4) + 5;
            
            for (let i = 0; i < nodeCount; i++) {
                graph.nodes.push({
                    id: i,
                    x: 0.1 + Math.random() * 0.8,
                    y: 0.1 + Math.random() * 0.8,
                    state: 'unvisited'
                });
            }
            
            // 随机生成边，确保图是连通的
            const connected = new Set([0]);
            const unconnected = new Set(Array.from({length: nodeCount-1}, (_, i) => i+1));
            
            while (unconnected.size > 0) {
                const from = Array.from(connected)[Math.floor(Math.random() * connected.size)];
                const to = Array.from(unconnected)[Math.floor(Math.random() * unconnected.size)];
                
                graph.edges.push({from, to, type: 'default'});
                connected.add(to);
                unconnected.delete(to);
            }
            
            // 添加一些额外的随机边
            const extraEdges = Math.floor(Math.random() * 5) + 2;
            for (let i = 0; i < extraEdges; i++) {
                const from = Math.floor(Math.random() * nodeCount);
                const to = Math.floor(Math.random() * nodeCount);
                
                if (from !== to && !graph.edges.some(e => 
                    (e.from === from && e.to === to) || (e.from === to && e.to === from))) {
                    graph.edges.push({from, to, type: 'default'});
                }
            }
            
            buildAdjacencyList();
            updateNodePositions();
            resetAnimation();
            drawGraph();
        }
        
        function buildAdjacencyList() {
            graph.adjacencyList = {};
            
            for (const node of graph.nodes) {
                graph.adjacencyList[node.id] = [];
            }
            
            for (const edge of graph.edges) {
                graph.adjacencyList[edge.from].push(edge.to);
                graph.adjacencyList[edge.to].push(edge.from);
            }
        }
        
        function updateNodePositions() {
            // 将相对坐标转换为绝对坐标
            const width = canvas.width;
            const height = canvas.height;
            const margin = 60;
            
            graph.nodes.forEach(node => {
                node.actualX = margin + node.x * (width - 2 * margin);
                node.actualY = margin + node.y * (height - 2 * margin);
            });
        }
        
        // ==================== 绘图函数 ====================
        function drawGraph() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制边
            drawEdges();
            
            // 绘制节点
            drawNodes();
            
            // 绘制递归栈（如果启用）
            if (viewSettings.showStack) {
                drawStack();
            }
        }
        
        function drawEdges() {
            for (const edge of graph.edges) {
                const fromNode = graph.nodes.find(n => n.id === edge.from);
                const toNode = graph.nodes.find(n => n.id === edge.to);
                
                if (!fromNode || !toNode) continue;
                
                // 确定边的颜色
                let color = COLORS.EDGE.DEFAULT;
                let lineWidth = 2;
                
                // 检查是否是树边
                const edgeKey = `${Math.min(edge.from, edge.to)}-${Math.max(edge.from, edge.to)}`;
                const isTreeEdge = animationState.treeEdges.has(edgeKey);
                
                if (isTreeEdge && viewSettings.highlightTreeEdges) {
                    color = COLORS.EDGE.TREE;
                    lineWidth = 3;
                }
                
                // 检查是否是当前活动的边
                if (animationState.currentNode !== null) {
                    const currentNode = graph.nodes.find(n => n.id === animationState.currentNode);
                    if (currentNode && 
                        ((edge.from === currentNode.id && graph.nodes.find(n => n.id === edge.to).state === 'visiting') ||
                         (edge.to === currentNode.id && graph.nodes.find(n => n.id === edge.from).state === 'visiting'))) {
                        color = COLORS.EDGE.ACTIVE;
                        lineWidth = 4;
                    }
                }
                
                // 绘制边
                ctx.beginPath();
                ctx.moveTo(fromNode.actualX, fromNode.actualY);
                ctx.lineTo(toNode.actualX, toNode.actualY);
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        }
        
        function drawNodes() {
            for (const node of graph.nodes) {
                // 确定节点颜色
                let fillColor;
                switch (node.state) {
                    case 'unvisited': fillColor = COLORS.NODE.UNVISITED; break;
                    case 'visiting': fillColor = COLORS.NODE.VISITING; break;
                    case 'visited': fillColor = COLORS.NODE.VISITED; break;
                    default: fillColor = COLORS.NODE.UNVISITED;
                }
                
                // 绘制节点外圈（如果正在访问，添加脉动效果）
                if (node.state === 'visiting') {
                    ctx.beginPath();
                    ctx.arc(node.actualX, node.actualY, 28, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
                    ctx.fill();
                    
                    // 脉动动画
                    const pulseSize = 24 + Math.sin(Date.now() / 300) * 4;
                    ctx.beginPath();
                    ctx.arc(node.actualX, node.actualY, pulseSize, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // 绘制节点
                ctx.beginPath();
                ctx.arc(node.actualX, node.actualY, 22, 0, Math.PI * 2);
                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = COLORS.NODE.BORDER;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 绘制节点ID
                ctx.fillStyle = COLORS.NODE.TEXT;
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, node.actualX, node.actualY);
                
                // 如果节点是当前活动节点，添加指示器
                if (animationState.currentNode === node.id) {
                    ctx.beginPath();
                    ctx.arc(node.actualX, node.actualY, 26, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        }
        
        function drawStack() {
            const stack = animationState.stack;
            if (stack.length === 0) return;
            
            const stackWidth = 80;
            const stackHeight = 40;
            const startX = canvas.width - stackWidth - 20;
            const startY = 20;
            
            // 绘制栈标题
            ctx.fillStyle = COLORS.NODE.TEXT;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('递归栈:', startX, startY - 10);
            
            // 绘制栈容器
            ctx.strokeStyle = COLORS.STACK.BORDER;
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, stackWidth, stackHeight * 6);
            
            // 绘制栈中的节点
            for (let i = 0; i < stack.length; i++) {
                const nodeId = stack[i];
                const yPos = startY + stackHeight * (5 - i); // 从底部开始绘制
                
                // 栈项背景
                ctx.fillStyle = COLORS.STACK.BACKGROUND;
                ctx.fillRect(startX + 2, yPos + 2, stackWidth - 4, stackHeight - 4);
                
                // 栈项边框
                ctx.strokeStyle = COLORS.STACK.BORDER;
                ctx.lineWidth = 2;
                ctx.strokeRect(startX + 2, yPos + 2, stackWidth - 4, stackHeight - 4);
                
                // 栈项文本
                ctx.fillStyle = COLORS.NODE.TEXT;
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`节点 ${nodeId}`, startX + stackWidth / 2, yPos + stackHeight / 2);
            }
        }
        
        // ==================== 算法实现 ====================
        function generateAlgorithmSteps() {
            algorithmSteps = [];
            animationState.treeEdges.clear();
            
            // 重置所有节点状态
            graph.nodes.forEach(node => node.state = 'unvisited');
            
            // 深度优先搜索递归函数
            function dfs(nodeId, parentId = null) {
                const node = graph.nodes.find(n => n.id === nodeId);
                if (!node) return;
                
                // 步骤1: 访问节点，标记为访问中
                algorithmSteps.push({
                    action: 'visit',
                    nodeId: nodeId,
                    description: `访问节点 ${nodeId}，将其标记为"访问中"（灰色）并压入递归栈`
                });
                
                node.state = 'visiting';
                if (parentId !== null) {
                    const edgeKey = `${Math.min(nodeId, parentId)}-${Math.max(nodeId, parentId)}`;
                    animationState.treeEdges.add(edgeKey);
                    
                    algorithmSteps.push({
                        action: 'tree_edge',
                        from: parentId,
                        to: nodeId,
                        description: `边 ${parentId}-${nodeId} 成为DFS树边`
                    });
                }
                
                // 获取邻居节点
                const neighbors = graph.adjacencyList[nodeId] || [];
                
                for (const neighborId of neighbors) {
                    const neighbor = graph.nodes.find(n => n.id === neighborId);
                    
                    // 步骤2: 检查邻居
                    algorithmSteps.push({
                        action: 'check_neighbor',
                        currentNode: nodeId,
                        neighborId: neighborId,
                        description: `检查节点 ${nodeId} 的邻居节点 ${neighborId}`
                    });
                    
                    if (neighbor.state === 'unvisited') {
                        // 步骤3: 递归访问邻居

<!--检测到代码截断，自动续写中...-->
algorithmSteps.push({
                            action: 'recurse',
                            from: nodeId,
                            to: neighborId,
                            description: `节点 ${neighborId} 未访问，递归调用DFS(${neighborId})`
                        });
                        
                        dfs(neighborId, nodeId);
                        
                        // 步骤4: 递归返回
                        algorithmSteps.push({
                            action: 'return',
                            nodeId: nodeId,
                            description: `从节点 ${neighborId} 递归返回到节点 ${nodeId}`
                        });
                    } else if (neighbor.state === 'visiting') {
                        // 发现回边（指向递归栈中的节点）
                        algorithmSteps.push({
                            action: 'back_edge',
                            from: nodeId,
                            to: neighborId,
                            description: `发现回边 ${nodeId}→${neighborId}（指向递归栈中的节点）`
                        });
                    } else {
                        // 邻居已访问完成
                        algorithmSteps.push({
                            action: 'skip_neighbor',
                            currentNode: nodeId,
                            neighborId: neighborId,
                            description: `节点 ${neighborId} 已访问完成，跳过`
                        });
                    }
                }
                
                // 步骤5: 完成节点访问
                algorithmSteps.push({
                    action: 'complete',
                    nodeId: nodeId,
                    description: `节点 ${nodeId} 的所有邻居已处理，标记为"已访问"（绿色）并弹出递归栈`
                });
                
                node.state = 'visited';
            }
            
            // 从节点0开始DFS（如果存在）
            if (graph.nodes.length > 0) {
                dfs(0);
            }
            
            // 检查是否有未访问的节点（不连通图）
            for (const node of graph.nodes) {
                if (node.state === 'unvisited') {
                    algorithmSteps.push({
                        action: 'new_component',
                        nodeId: node.id,
                        description: `发现新的连通分量，从节点 ${node.id} 开始DFS`
                    });
                    
                    dfs(node.id);
                }
            }
            
            // 添加完成步骤
            algorithmSteps.push({
                action: 'finish',
                description: `DFS遍历完成！总共访问了 ${graph.nodes.length} 个节点`
            });
        }
        
        // ==================== 动画控制函数 ====================
        function toggleAnimation() {
            const startBtn = document.getElementById('startBtn');
            const icon = startBtn.querySelector('i');
            
            if (!animationState.isRunning) {
                // 开始动画
                if (algorithmSteps.length === 0 || animationState.currentStepIndex >= algorithmSteps.length) {
                    generateAlgorithmSteps();
                    animationState.currentStepIndex = 0;
                    animationState.visitedOrder = [];
                    animationState.stack = [];
                    animationState.currentNode = null;
                }
                
                animationState.isRunning = true;
                animationState.isPaused = false;
                startBtn.innerHTML = '<i class="fas fa-pause"></i> 暂停';
                startBtn.classList.remove('primary');
                startBtn.classList.add('warning');
                
                playNextStep();
            } else {
                // 暂停动画
                animationState.isPaused = !animationState.isPaused;
                
                if (animationState.isPaused) {
                    startBtn.innerHTML = '<i class="fas fa-play"></i> 继续';
                    startBtn.classList.remove('warning');
                    startBtn.classList.add('primary');
                } else {
                    startBtn.innerHTML = '<i class="fas fa-pause"></i> 暂停';
                    startBtn.classList.remove('primary');
                    startBtn.classList.add('warning');
                    playNextStep();
                }
            }
            
            updateUI();
        }
        
        function playNextStep() {
            if (!animationState.isRunning || animationState.isPaused) return;
            
            if (animationState.currentStepIndex < algorithmSteps.length) {
                executeStep(animationState.currentStepIndex);
                animationState.currentStepIndex++;
                
                if (animationState.currentStepIndex < algorithmSteps.length) {
                    setTimeout(playNextStep, animationState.speed);
                } else {
                    // 动画完成
                    animationState.isRunning = false;
                    const startBtn = document.getElementById('startBtn');
                    startBtn.innerHTML = '<i class="fas fa-play"></i> 重新开始';
                    startBtn.classList.remove('warning');
                    startBtn.classList.add('primary');
                }
            }
            
            updateUI();
        }
        
        function nextStep() {
            if (algorithmSteps.length === 0 || animationState.currentStepIndex >= algorithmSteps.length) {
                generateAlgorithmSteps();
                animationState.currentStepIndex = 0;
                animationState.visitedOrder = [];
                animationState.stack = [];
                animationState.currentNode = null;
            }
            
            if (animationState.currentStepIndex < algorithmSteps.length) {
                executeStep(animationState.currentStepIndex);
                animationState.currentStepIndex++;
            }
            
            animationState.isRunning = false;
            animationState.isPaused = false;
            
            const startBtn = document.getElementById('startBtn');
            startBtn.innerHTML = '<i class="fas fa-play"></i> 继续';
            startBtn.classList.remove('warning');
            startBtn.classList.add('primary');
            
            updateUI();
        }
        
        function prevStep() {
            if (animationState.currentStepIndex > 0) {
                animationState.currentStepIndex--;
                undoStep(animationState.currentStepIndex);
            }
            
            animationState.isRunning = false;
            animationState.isPaused = false;
            
            const startBtn = document.getElementById('startBtn');
            startBtn.innerHTML = '<i class="fas fa-play"></i> 继续';
            startBtn.classList.remove('warning');
            startBtn.classList.add('primary');
            
            updateUI();
        }
        
        function executeStep(stepIndex) {
            const step = algorithmSteps[stepIndex];
            if (!step) return;
            
            // 更新当前步骤描述
            document.getElementById('currentStep').textContent = step.description;
            
            // 根据步骤类型执行相应操作
            switch (step.action) {
                case 'visit':
                    // 标记节点为访问中
                    const visitNode = graph.nodes.find(n => n.id === step.nodeId);
                    if (visitNode) visitNode.state = 'visiting';
                    
                    // 添加到递归栈
                    animationState.stack.push(step.nodeId);
                    animationState.currentNode = step.nodeId;
                    break;
                    
                case 'tree_edge':
                    // 树边已经在generateAlgorithmSteps时添加到集合中
                    break;
                    
                case 'check_neighbor':
                    animationState.currentNode = step.currentNode;
                    break;
                    
                case 'recurse':
                    animationState.currentNode = step.to;
                    break;
                    
                case 'return':
                    animationState.currentNode = step.nodeId;
                    break;
                    
                case 'complete':
                    // 标记节点为已访问
                    const completeNode = graph.nodes.find(n => n.id === step.nodeId);
                    if (completeNode) completeNode.state = 'visited';
                    
                    // 从递归栈弹出
                    if (animationState.stack.length > 0) {
                        animationState.stack.pop();
                    }
                    
                    // 添加到访问顺序列表
                    if (!animationState.visitedOrder.includes(step.nodeId)) {
                        animationState.visitedOrder.push(step.nodeId);
                    }
                    
                    // 更新当前节点
                    if (animationState.stack.length > 0) {
                        animationState.currentNode = animationState.stack[animationState.stack.length - 1];
                    } else {
                        animationState.currentNode = null;
                    }
                    break;
                    
                case 'back_edge':
                case 'skip_neighbor':
                    animationState.currentNode = step.currentNode || step.from;
                    break;
                    
                case 'new_component':
                    animationState.currentNode = step.nodeId;
                    break;
                    
                case 'finish':
                    animationState.currentNode = null;
                    break;
            }
            
            // 重绘图
            drawGraph();
        }
        
        function undoStep(stepIndex) {
            // 重置到上一步的状态需要重新生成步骤并执行到stepIndex
            // 这里简化处理：重新生成所有步骤并执行到stepIndex-1
            generateAlgorithmSteps();
            
            // 重置状态
            graph.nodes.forEach(node => node.state = 'unvisited');
            animationState.visitedOrder = [];
            animationState.stack = [];
            animationState.currentNode = null;
            animationState.treeEdges.clear();
            
            // 执行到stepIndex-1
            for (let i = 0; i < stepIndex; i++) {
                executeStep(i);
            }
            
            // 更新当前步骤描述
            if (stepIndex > 0) {
                const step = algorithmSteps[stepIndex - 1];
                document.getElementById('currentStep').textContent = step.description;
            } else {
                document.getElementById('currentStep').textContent = "已重置到初始状态";
            }
            
            drawGraph();
        }
        
        function resetAnimation() {
            animationState.isRunning = false;
            animationState.isPaused = false;
            animationState.currentStepIndex = 0;
            animationState.visitedOrder = [];
            animationState.stack = [];
            animationState.currentNode = null;
            animationState.treeEdges.clear();
            
            algorithmSteps = [];
            
            // 重置所有节点状态
            graph.nodes.forEach(node => node.state = 'unvisited');
            
            // 更新按钮状态
            const startBtn = document.getElementById('startBtn');
            startBtn.innerHTML = '<i class="fas fa-play"></i> 开始';
            startBtn.classList.remove('warning');
            startBtn.classList.add('primary');
            
            // 更新UI
            document.getElementById('currentStep').textContent = "请点击'开始'按钮运行DFS算法";
            updateUI();
            drawGraph();
        }
        
        // ==================== UI更新函数 ====================
        function updateUI() {
            // 更新递归栈显示
            const stackContent = document.getElementById('stackContent');
            const stackCount = document.getElementById('stackCount');
            
            if (animationState.stack.length === 0) {
                stackContent.innerHTML = '<div style="color: #a0aec0; text-align: center; padding: 20px;">栈为空</div>';
                stackCount.textContent = '(0)';
            } else {
                stackContent.innerHTML = '';
                animationState.stack.slice().reverse().forEach(nodeId => {
                    const stackItem = document.createElement('div');
                    stackItem.className = 'stack-item';
                    stackItem.textContent = `节点 ${nodeId}`;
                    stackContent.appendChild(stackItem);
                });
                stackCount.textContent = `(${animationState.stack.length})`;
            }
            
            // 更新访问顺序显示
            const visitOrderElement = document.getElementById('visitOrder');
            if (animationState.visitedOrder.length === 0) {
                visitOrderElement.innerHTML = '<div style="color: #a0aec0; text-align: center; padding: 20px;">暂无节点</div>';
            } else {
                visitOrderElement.innerHTML = '';
                animationState.visitedOrder.forEach(nodeId => {
                    const nodeElement = document.createElement('span');
                    nodeElement.className = 'node-sequence';
                    nodeElement.textContent = nodeId;
                    visitOrderElement.appendChild(nodeElement);
                });
            }
            
            // 更新步骤进度
            const progressElement = document.getElementById('currentStep');
            if (animationState.currentStepIndex < algorithmSteps.length) {
                // 进度信息已经在executeStep中更新
            }
        }
        
        // ==================== 初始化调用 ====================
        // 页面加载完成后初始化
        window.addEventListener('load', init);
        
        // 初始绘制
        drawGraph();
    </script>
</body>
</html>