<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>希尔排序算法动画演示</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background-color: #f8f9fa;
            color: #495057;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        h1 {
            color: #339af0;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #868e96;
            font-size: 1.1rem;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .animation-section {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 25px;
        }

        .section-title {
            color: #4dabf7;
            margin-bottom: 20px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title i {
            font-size: 1.5rem;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #f8f9fa;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e9ecef;
        }

        #animationCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls-section {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 25px;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.95rem;
        }

        .buttons-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: #339af0;
            color: white;
        }

        .btn-primary:hover {
            background-color: #228be6;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: #e9ecef;
            color: #495057;
        }

        .btn-secondary:hover {
            background-color: #dee2e6;
            transform: translateY(-2px);
        }

        .btn-success {
            background-color: #51cf66;
            color: white;
        }

        .btn-success:hover {
            background-color: #40c057;
            transform: translateY(-2px);
        }

        .btn-warning {
            background-color: #ff922b;
            color: white;
        }

        .btn-warning:hover {
            background-color: #fd7e14;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #e9ecef;
            border-radius: 4px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #339af0;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .slider-value {
            min-width: 40px;
            text-align: center;
            font-weight: 600;
            color: #339af0;
        }

        .status-section {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 25px;
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .status-card {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #4dabf7;
        }

        .status-title {
            font-size: 0.9rem;
            color: #868e96;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #495057;
        }

        .status-value.highlight {
            color: #ff922b;
        }

        .status-value.gap {
            color: #4dabf7;
        }

        .status-value.comparisons {
            color: #ff6b6b;
        }

        .status-value.swaps {
            color: #51cf66;
        }

        .legend-section {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 25px;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .legend-text {
            font-size: 0.95rem;
            color: #495057;
        }

        .instructions {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 10px;
            border-left: 4px solid #ff922b;
        }

        .instructions h3 {
            color: #ff922b;
            margin-bottom: 10px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        @media (max-width: 768px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .buttons-row {
                justify-content: center;
            }
            
            .btn {
                flex: 1;
                min-width: 120px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="header">
        <h1><i class="fas fa-sort-amount-down"></i> 希尔排序算法动画演示</h1>
        <p class="subtitle">插入排序的升级版 - 通过间隔序列实现高效排序</p>
    </div>

    <div class="container">
        <div class="animation-section">
            <h2 class="section-title"><i class="fas fa-play-circle"></i> 算法动画演示</h2>
            <div class="canvas-container">
                <canvas id="animationCanvas"></canvas>
            </div>
        </div>

        <div class="controls-section">
            <h2 class="section-title"><i class="fas fa-sliders-h"></i> 动画控制</h2>
            
            <div class="controls-grid">
                <div class="control-group">
                    <div class="control-label">数组大小</div>
                    <div class="slider-container">
                        <input type="range" min="5" max="20" value="12" class="slider" id="arraySizeSlider">
                        <span class="slider-value" id="arraySizeValue">12</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="control-label">动画速度</div>
                    <div class="slider-container">
                        <input type="range" min="1" max="10" value="5" class="slider" id="speedSlider">
                        <span class="slider-value" id="speedValue">5</span>
                    </div>
                </div>
            </div>

            <div class="buttons-row">
                <button class="btn btn-primary" id="playPauseBtn">
                    <i class="fas fa-play"></i> 播放
                </button>
                <button class="btn btn-secondary" id="nextStepBtn">
                    <i class="fas fa-step-forward"></i> 下一步
                </button>
                <button class="btn btn-secondary" id="prevStepBtn">
                    <i class="fas fa-step-backward"></i> 上一步
                </button>
                <button class="btn btn-warning" id="resetBtn">
                    <i class="fas fa-redo"></i> 重置
                </button>
                <button class="btn btn-success" id="newArrayBtn">
                    <i class="fas fa-random"></i> 新数组
                </button>
            </div>
        </div>

        <div class="status-section">
            <h2 class="section-title"><i class="fas fa-info-circle"></i> 算法状态</h2>
            <div class="status-grid">
                <div class="status-card">
                    <div class="status-title">当前间隔 (Gap)</div>
                    <div class="status-value gap" id="currentGap">-</div>
                </div>
                <div class="status-card">
                    <div class="status-title">当前操作</div>
                    <div class="status-value highlight" id="currentOperation">等待开始</div>
                </div>
                <div class="status-card">
                    <div class="status-title">比较次数</div>
                    <div class="status-value comparisons" id="comparisonCount">0</div>
                </div>
                <div class="status-card">
                    <div class="status-title">交换次数</div>
                    <div class="status-value swaps" id="swapCount">0</div>
                </div>
            </div>
        </div>

        <div class="legend-section">
            <h2 class="section-title"><i class="fas fa-palette"></i> 颜色图例</h2>
            <div class="legend-grid">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dee2e6;"></div>
                    <div class="legend-text">默认元素</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4dabf7;"></div>
                    <div class="legend-text">当前子序列</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff922b;"></div>
                    <div class="legend-text">焦点元素 (待插入)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                    <div class="legend-text">比较中元素</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #51cf66;"></div>
                    <div class="legend-text">已排序元素</div>
                </div>
            </div>
            
            <div class="instructions">
                <h3><i class="fas fa-lightbulb"></i> 希尔排序原理</h3>
                <ul>
                    <li><strong>间隔序列</strong>: 从较大间隔开始，逐渐减小间隔直到1（普通插入排序）</li>
                    <li><strong>子序列排序</strong>: 对每个间隔形成的子序列进行插入排序</li>
                    <li><strong>效率优势</strong>: 大间隔让元素大跨度移动，提前减少逆序对数量</li>
                    <li><strong>最终排序</strong>: 当间隔为1时，数组已基本有序，最后一遍插入排序效率很高</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let canvas, ctx;
        let array = [];
        let animationId = null;
        let isPlaying = false;
        let animationSpeed = 5;
        let arraySize = 12;
        
        // 希尔排序状态变量
        let gap;
        let i, j;
        let temp;
        let currentSubArrayIndex = 0;
        let isComparing = false;
        let isSwapping = false;
        let animationStep = 0; // 0: 初始化, 1: 选择间隔, 2: 选择子序列, 3: 插入排序, 4: 完成
        let algorithmState = 'idle'; // 'idle', 'selecting_gap', 'selecting_subarray', 'insertion_sort', 'completed'
        
        // 统计变量
        let comparisonCount = 0;
        let swapCount = 0;
        
        // 颜色定义
        const colors = {
            default: '#dee2e6',
            subarray: '#4dabf7',
            focus: '#ff922b',
            comparing: '#ff6b6b',
            sorted: '#51cf66',
            background: '#f8f9fa',
            text: '#495057',
            line: '#adb5bd'
        };
        
        // 初始化
        function init() {
            canvas = document.getElementById('animationCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置Canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化数组
            generateRandomArray();
            
            // 初始化希尔排序
            initShellSort();
            
            // 设置事件监听器
            setupEventListeners();
            
            // 绘制初始状态
            draw();
        }
        
        // 调整Canvas大小
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        
        // 生成随机数组
        function generateRandomArray() {
            array = [];
            for (let i = 0; i < arraySize; i++) {
                array.push(Math.floor(Math.random() * 90) + 10); // 10-99之间的随机数
            }
            
            // 重置统计
            comparisonCount = 0;
            swapCount = 0;
            updateStatusDisplay();
        }
        
        // 初始化希尔排序状态
        function initShellSort() {
            // 初始间隔为数组长度的一半
            gap = Math.floor(arraySize / 2);
            i = gap;
            j = i;
            temp = null;
            currentSubArrayIndex = 0;
            isComparing = false;
            isSwapping = false;
            animationStep = 0;
            algorithmState = 'idle';
            
            // 更新状态显示
            updateStatusDisplay();
        }
        
        // 设置事件监听器
        function setupEventListeners() {
            // 播放/暂停按钮
            document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
            
            // 下一步按钮
            document.getElementById('nextStepBtn').addEventListener('click', nextStep);
            
            // 上一步按钮（简化实现，实际需要状态历史）
            document.getElementById('prevStepBtn').addEventListener('click', prevStep);
            
            // 重置按钮
            document.getElementById('resetBtn').addEventListener('click', resetAnimation);
            
            // 新数组按钮
            document.getElementById('newArrayBtn').addEventListener('click', () => {
                generateRandomArray();
                initShellSort();
                draw();
            });
            
            // 数组大小滑块
            const arraySizeSlider = document.getElementById('arraySizeSlider');
            const arraySizeValue = document.getElementById('arraySizeValue');
            
            arraySizeSlider.addEventListener('input', () => {
                arraySize = parseInt(arraySizeSlider.value);
                arraySizeValue.textContent = arraySize;
                generateRandomArray();
                initShellSort();
                draw();
            });
            
            // 速度滑块
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');
            
            speedSlider.addEventListener('input', () => {
                animationSpeed = parseInt(speedSlider.value);
                speedValue.textContent = animationSpeed;
            });
        }
        
        // 切换播放/暂停
        function togglePlayPause() {
            const playPauseBtn = document.getElementById('playPauseBtn');
            const icon = playPauseBtn.querySelector('i');
            
            if (isPlaying) {
                // 暂停动画
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                isPlaying = false;
                playPauseBtn.innerHTML = '<i class="fas fa-play"></i> 播放';
                algorithmState = 'idle';
            } else {
                // 开始动画
                isPlaying = true;
                playPauseBtn.innerHTML = '<i class="fas fa-pause"></i> 暂停';
                
                // 如果算法已完成，重置
                if (algorithmState === 'completed') {
                    resetAnimation();
                }
                
                // 开始动画循环
                animate();
            }
        }
        
        // 下一步
        function nextStep() {
            if (algorithmState === 'completed') return;
            
            performAlgorithmStep();
            draw();
        }
        
        // 上一步（简化版本，实际需要维护状态历史）
        function prevStep() {
            // 简化实现：重置并重新执行到上一步
            // 在实际应用中，需要维护一个状态历史栈
            alert("上一步功能需要维护状态历史，此为简化演示。请使用重置功能重新开始。");
        }
        
        // 重置动画
        function resetAnimation() {
            // 停止动画
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            isPlaying = false;
            document.getElementById('playPauseBtn').innerHTML = '<i class="fas fa-play"></i> 播放';
            
            // 重新生成数组并初始化排序
            generateRandomArray();
            initShellSort();
            draw();
        }
        
        // 执行算法步骤
        function performAlgorithmStep() {
            // 根据当前状态执行相应的步骤
            switch(algorithmState) {
                case 'idle':
                    // 开始算法，选择初始间隔
                    algorithmState = 'selecting_gap';
                    updateStatusDisplay();
                    break;
                    
                case 'selecting_gap':
                    // 如果间隔为0，算法完成
                    if (gap <= 0) {
                        algorithmState = 'completed';
                        updateStatusDisplay();
                        return;
                    }
                    
                    // 开始当前间隔的排序
                    i = gap;
                    currentSubArrayIndex = 0;
                    algorithmState = 'selecting_subarray';
                    updateStatusDisplay();
                    break;
                    
                case 'selecting_subarray':
                    // 选择当前子序列
                    if (currentSubArrayIndex >= gap) {
                        // 当前间隔的所有子序列已处理完毕，减小间隔
                        gap = Math.floor(gap / 2);
                        algorithmState = 'selecting_gap';
                        updateStatusDisplay();
                        return;
                    }
                    
                    // 开始对当前子序列进行插入排序
                    i = currentSubArrayIndex + gap;
                    j = i;
                    temp = array[i];
                    isComparing = false;
                    isSwapping = false;
                    algorithmState = 'insertion_sort';
                    updateStatusDisplay();
                    break;
                    
                case 'insertion_sort':
                    // 执行插入排序的一步
                    if (j >= gap && array[j - gap] > temp) {
                        // 需要移动元素
                        isComparing = true;
                        comparisonCount++;
                        
                        // 移动元素
                        array[j] = array[j - gap];
                        swapCount++;
                        
                        j -= gap;
                        isSwapping = true;
                    } else {
                        // 插入元素到正确位置
                        array[j] = temp;
                        isComparing = false;
                        isSwapping = false;
                        
                        // 移动到下一个元素
                        i += gap;
                        
                        if (i >= arraySize) {
                            // 当前子序列排序完成，移动到下一个子序列
                            currentSubArrayIndex++;
                            algorithmState = 'selecting_subarray';
                        } else {
                            // 继续当前子序列的下一个元素
                            j = i;
                            temp = array[i];
                        }
                    }
                    updateStatusDisplay();
                    break;
                    
                case 'completed':
                    // 算法已完成
                    break;
            }
        }
        
        // 动画循环
        function animate() {
            if (!isPlaying) return;
            
            // 根据速度执行步骤
            const stepsPerFrame = Math.max(1, Math.floor(animationSpeed / 2));
            
            for (let s = 0; s < stepsPerFrame; s++) {
                performAlgorithmStep();
                
                // 如果算法完成，停止动画
                if (algorithmState === 'completed') {
                    isPlaying = false;
                    document.getElementById('playPauseBtn').innerHTML = '<i class="fas fa-play"></i> 播放';
                    break;
                }
            }
            
            // 绘制
            draw();
            
            // 继续动画循环
            if (isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        // 更新状态显示
        function updateStatusDisplay() {
            document.getElementById('currentGap').textContent = gap > 0 ? gap : '完成';
            document.getElementById('comparisonCount').textContent = comparisonCount;
            document.getElementById('swapCount').textContent = swapCount;
            
            let operationText = '等待开始';
            
            switch(algorithmState) {
                case 'idle':
                    operationText = '等待开始';
                    break;
                case 'selecting_gap':
                    operationText = `选择间隔: ${gap}`;
                    break;
                case 'selecting_subarray':
                    operationText = `选择子序列 ${currentSubArrayIndex + 1}/${gap}`;
                    break;
                case 'insertion_sort':
                    if (isComparing) {
                        operationText = `比较: array[${j-gap}] > ${temp}`;
                    } else if (isSwapping) {
                        operationText = `移动: array[${j}] = array[${j-gap}]`;
                    } else {
                        operationText = `插入 ${temp} 到位置 ${j}`;
                    }
                    break;
                case 'completed':
                    operationText = '排序完成！';
                    break;
            }
            
            document.getElementById('currentOperation').textContent = operationText;
        }
        
        // 绘制函数
        function draw() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算元素尺寸和间距
            const elementWidth = Math.min(60, canvas.width / (arraySize * 1.5));
            const elementSpacing = elementWidth * 0.5;
            const totalWidth = arraySize * (elementWidth + elementSpacing) - elementSpacing;
            const startX = (canvas.width - totalWidth) / 2;
            const baseY = canvas.height * 0.7;
            const elementHeightMultiplier = 3;
            
            // 绘制标题
            ctx.font = 'bold 18px "Segoe UI", sans-serif';
            ctx.fillStyle = colors.text;
            ctx.textAlign = 'center';
            ctx.fillText('希尔排序算法演示', canvas.width / 2, 30);
            
            // 绘制当前间隔指示
            if (gap > 0 && algorithmState !== 'idle' && algorithmState !== 'completed') {
                ctx.font = '16px "Segoe UI", sans-serif';
                ctx.fillStyle = colors.subarray;
                ctx.textAlign = 'center';
                ctx.fillText(`当前间隔: ${gap}`, canvas.width / 2, 60);
                
                // 绘制间隔连线
                if (algorithmState === 'selecting_subarray' || algorithmState === 'insertion_sort') {
                    ctx.strokeStyle = colors.subarray;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    // 绘制当前子序列的连线
                    for (let idx = currentSubArrayIndex; idx < arraySize; idx += gap) {
                        const x = startX + idx * (elementWidth + elementSpacing) + elementWidth / 2;
                        const y1 = baseY - array[idx] * elementHeightMultiplier - 20;
                        const y2 = baseY + 30;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y1);
                        ctx.lineTo(x, y2);
                        ctx.stroke();
                    }
                    
                    ctx.setLineDash([]);
                }
            }
            
            // 绘制数组元素
            for (let idx = 0; idx < arraySize; idx++) {
                const x = startX + idx * (elementWidth + elementSpacing);
                const height = array[idx] * elementHeightMultiplier;
                const y = baseY - height;
                
                // 确定元素颜色
                let color = colors.default;
                
                // 检查元素状态
                if (algorithmState === 'completed') {
                    color = colors.sorted;
                } else if (algorithmState === 'insertion_sort') {
                    // 当前子序列元素
                    if ((idx - currentSubArrayIndex) % gap === 0) {
                        color = colors.subarray;
                    }
                    
                    // 焦点元素（待插入元素）
                    if (idx === i && !isSwapping) {
                        color = colors.focus;
                    }
                    
                    // 比较中的元素
                    if (isComparing && (idx === j || idx === j - gap)) {
                        color = colors.comparing;
                    }
                    
                    // 正在交换的元素
                    if (isSwapping && idx === j) {
                        color = colors.comparing;
                    }
                } else if (algorithmState === 'selecting_subarray') {
                    // 当前子序列元素
                    if ((idx - currentSubArrayIndex) % gap === 0) {
                        color = colors.subarray;
                    }
                }
                
                // 绘制元素矩形
                ctx.fillStyle = color;
                ctx.fillRect(x, y, elementWidth, height);
                
                // 绘制元素边框
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, elementWidth, height);
                
                // 绘制元素值
                ctx.fillStyle = colors.text;
                ctx.font = 'bold 14px "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(array[idx], x + elementWidth / 2, y + height / 2 + 5);
                
                // 绘制元素索引
                ctx.fillStyle = colors.text;
                ctx.font = '12px "Segoe UI", sans-serif';
                ctx.fillText(`[${idx}]`, x + elementWidth / 2, baseY + 20);
            }
            
            // 绘制当前操作说明
            if (algorithmState !== 'idle') {
                ctx.font = '14px "Segoe UI", sans-serif';
                ctx.fillStyle = colors.text;
                ctx.textAlign = 'left';
                
                let explanation = '';
                
                switch(algorithmState) {
                    case 'selecting_gap':
                        explanation = `当前间隔: ${gap} (数组长度/2并逐次减半)`;
                        break;
                    case 'selecting_subarray':
                        explanation = `处理子序列 ${currentSubArrayIndex + 1}/${gap}: 索引 ${currentSubArrayIndex}, ${currentSubArrayIndex+gap}, ${currentSubArrayIndex+2*gap}...`;
                        break;
                    case 'insertion_sort':
                        if (isComparing) {
                            explanation = `比较: array[${j-gap}] (${array[j-gap]}) > ${temp} ? 是，所以移动元素`;
                        } else if (isSwapping) {
                            explanation = `移动: array[${j}] = array[${j-gap}] (${array[j]})`;
                        } else {
                            explanation = `插入 ${temp} 到位置 ${j}`;
                        }
                        break;
                    case 'completed':
                        explanation = '排序完成！希尔排序通过间隔序列提前减少逆序对，比普通插入排序更高效。';
                        break;
                }
                
                // 绘制解释文本
                ctx.fillText(explanation, 20, canvas.height - 40);
            }
            
            // 绘制算法状态
            ctx.font = 'bold 16px "Segoe UI", sans-serif';
            ctx.fillStyle = colors.text;
            ctx.textAlign = 'right';
            
            let statusText = '';
            switch(algorithmState) {
                case 'idle': statusText = '就绪'; break;
                case 'selecting_gap': statusText = '选择间隔'; break;
                case 'selecting_subarray': statusText = '选择子序列'; break;
                case 'insertion_sort': statusText = '子序列插入排序'; break;
                case 'completed': statusText = '排序完成'; break;
            }
            
            ctx.fillText(`状态: ${statusText}`, canvas.width - 20, canvas.height - 40);
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>