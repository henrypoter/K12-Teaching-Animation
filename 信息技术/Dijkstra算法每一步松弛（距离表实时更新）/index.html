<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dijkstra算法松弛过程教学动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2196F3;
        }

        .header h1 {
            color: #2196F3;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            max-width: 800px;
            margin: 0 auto;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            margin-bottom: 25px;
        }

        .graph-container {
            flex: 1;
            min-width: 600px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .graph-title {
            font-size: 1.3rem;
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        #graphCanvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fff;
            flex-grow: 1;
        }

        .table-container {
            flex: 1;
            min-width: 400px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .table-title {
            font-size: 1.3rem;
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        #distanceTable {
            width: 100%;
            border-collapse: collapse;
            font-size: 1rem;
        }

        #distanceTable th {
            background-color: #607D8B;
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
        }

        #distanceTable td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.3s ease;
        }

        #distanceTable tr:last-child td {
            border-bottom: none;
        }

        .controls-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            margin-bottom: 25px;
        }

        .controls-title {
            font-size: 1.3rem;
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-btn {
            padding: 10px 20px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background-color: #0b7dda;
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(11, 125, 218, 0.2);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .control-btn:disabled {
            background-color: #BDBDBD;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .speed-control label {
            font-weight: 600;
            color: #555;
        }

        #speedSlider {
            width: 150px;
        }

        .legend-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
        }

        .legend-title {
            font-size: 1.3rem;
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .legend-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ddd;
        }

        .legend-text {
            font-size: 0.95rem;
        }

        .status-container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            margin-top: 25px;
        }

        .status-title {
            font-size: 1.3rem;
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        #statusText {
            font-size: 1.1rem;
            min-height: 60px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
        }

        .highlight {
            font-weight: 700;
            color: #2196F3;
        }

        .update-animation {
            animation: updateFlash 0.8s ease;
        }

        @keyframes updateFlash {
            0% {
                background-color: #FFF9C4;
            }

            100% {
                background-color: inherit;
            }
        }

        .current-row {
            background-color: #FFF3E0 !important;
        }

        .settled-row {
            background-color: #E3F2FD !important;
        }

        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 250px;
            display: none;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }

            .graph-container,
            .table-container {
                min-width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>Dijkstra算法：松弛操作与距离表实时更新</h1>
        <p>本动画演示Dijkstra算法寻找最短路径的过程，重点关注每一步的松弛操作和距离表的实时更新。使用控制按钮逐步执行算法，观察节点颜色、边状态和距离表的变化。</p>
    </div>

    <div class="container">
        <div class="graph-container">
            <h2 class="graph-title">图结构可视化</h2>
            <canvas id="graphCanvas" width="700" height="500"></canvas>
        </div>

        <div class="table-container">
            <h2 class="table-title">距离表（实时更新）</h2>
            <table id="distanceTable">
                <thead>
                    <tr>
                        <th>节点</th>
                        <th>最短距离</th>
                        <th>前驱节点</th>
                        <th>状态</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <!-- 表格内容将通过JavaScript动态生成 -->
                </tbody>
            </table>
        </div>
    </div>

    <div class="controls-container">
        <h2 class="controls-title">算法控制</h2>
        <div class="controls">
            <button id="resetBtn" class="control-btn">重置</button>
            <button id="prevStepBtn" class="control-btn" disabled>上一步</button>
            <button id="playPauseBtn" class="control-btn">播放</button>
            <button id="nextStepBtn" class="control-btn">下一步</button>
            <button id="autoCompleteBtn" class="control-btn">自动完成</button>

            <div class="speed-control">
                <label for="speedSlider">动画速度:</label>
                <input type="range" id="speedSlider" min="1" max="10" value="5">
            </div>
        </div>
    </div>

    <div class="legend-container">
        <h2 class="legend-title">图例说明</h2>
        <div class="legend-grid">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4CAF50;"></div>
                <div class="legend-text">源节点（起点）</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #FF9800;"></div>
                <div class="legend-text">当前处理节点</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2196F3;"></div>
                <div class="legend-text">已确定最短路径节点</div>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #E0E0E0;"></div>
                <div class="legend-text">未处理节点</div>
            </div>
            <div class="legend-item">
                <div class="legend-color"
                    style="background-color: #BDBDBD; width: 30px; height: 3px; border-radius: 0;"></div>
                <div class="legend-text">普通边</div>
            </div>
            <div class="legend-item">
                <div class="legend-color"
                    style="background-color: #FF9800; width: 30px; height: 5px; border-radius: 0;"></div>
                <div class="legend-text">当前松弛边</div>
            </div>
            <div class="legend-item">
                <div class="legend-color"
                    style="background-color: #2196F3; width: 30px; height: 5px; border-radius: 0;"></div>
                <div class="legend-text">最短路径边</div>
            </div>
        </div>
    </div>

    <div class="status-container">
        <h2 class="status-title">算法状态与步骤说明</h2>
        <div id="statusText">
            点击"下一步"开始执行Dijkstra算法。算法将从源节点A开始，逐步探索图中的最短路径。
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // 图数据结构
        const graph = {
            nodes: [
                { id: 'A', x: 150, y: 250 },
                { id: 'B', x: 300, y: 150 },
                { id: 'C', x: 300, y: 350 },
                { id: 'D', x: 450, y: 100 },
                { id: 'E', x: 450, y: 250 },
                { id: 'F', x: 450, y: 400 },
                { id: 'G', x: 600, y: 250 }
            ],
            edges: [
                { from: 'A', to: 'B', weight: 4 },
                { from: 'A', to: 'C', weight: 2 },
                { from: 'B', to: 'C', weight: 1 },
                { from: 'B', to: 'D', weight: 5 },
                { from: 'C', to: 'E', weight: 8 },
                { from: 'C', to: 'F', weight: 10 },
                { from: 'B', to: 'E', weight: 2 },
                { from: 'D', to: 'G', weight: 6 },
                { from: 'E', to: 'D', weight: 3 },
                { from: 'E', to: 'G', weight: 4 },
                { from: 'F', to: 'G', weight: 3 }
            ]
        };

        // Dijkstra算法状态
        let dijkstraState = {
            source: 'A',
            distances: {},
            previous: {},
            settled: new Set(),
            currentStep: 0,
            isPlaying: false,
            animationSpeed: 500,
            history: [],
            currentNode: null,
            relaxingEdge: null,
            stepDescriptions: [
                "初始化：设置源节点A的距离为0，其他所有节点的距离为无穷大(∞)。",
                "选择当前节点：从未处理的节点中选择距离最小的节点。",
                "标记为已处理：将当前节点标记为已确定最短路径。",
                "松弛邻居：检查当前节点的所有邻居，更新通过当前节点到达邻居的更短路径。",
                "重复步骤2-4，直到所有节点都被处理。"
            ]
        };

        // DOM元素
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const tableBody = document.getElementById('tableBody');
        const statusText = document.getElementById('statusText');
        const tooltip = document.getElementById('tooltip');

        // 控制按钮
        const resetBtn = document.getElementById('resetBtn');
        const prevStepBtn = document.getElementById('prevStepBtn');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const autoCompleteBtn = document.getElementById('autoCompleteBtn');
        const speedSlider = document.getElementById('speedSlider');

        // 初始化距离表
        function initializeDistances() {
            for (const node of graph.nodes) {
                dijkstraState.distances[node.id] = node.id === dijkstraState.source ? 0 : Infinity;
                dijkstraState.previous[node.id] = null;
            }
            dijkstraState.settled.clear();
            dijkstraState.currentStep = 0;
            dijkstraState.currentNode = null;
            dijkstraState.relaxingEdge = null;
            dijkstraState.history = [];

            // 保存初始状态到历史记录
            saveStateToHistory();

            updateDistanceTable();
            updateStatusText();
            drawGraph();
        }

        // 保存当前状态到历史记录
        function saveStateToHistory() {
            const stateCopy = {
                distances: { ...dijkstraState.distances },
                previous: { ...dijkstraState.previous },
                settled: new Set(dijkstraState.settled),
                currentNode: dijkstraState.currentNode,
                relaxingEdge: dijkstraState.relaxingEdge,
                currentStep: dijkstraState.currentStep
            };
            dijkstraState.history.push(stateCopy);
        }

        // 从历史记录恢复状态
        function restoreStateFromHistory(index) {
            if (index < 0 || index >= dijkstraState.history.length) return;

            const savedState = dijkstraState.history[index];
            dijkstraState.distances = { ...savedState.distances };
            dijkstraState.previous = { ...savedState.previous };
            dijkstraState.settled = new Set(savedState.settled);
            dijkstraState.currentNode = savedState.currentNode;
            dijkstraState.relaxingEdge = savedState.relaxingEdge;
            dijkstraState.currentStep = savedState.currentStep;

            // 移除之后的历史记录
            dijkstraState.history = dijkstraState.history.slice(0, index + 1);

            updateDistanceTable();
            updateStatusText();
            drawGraph();
            updateControlButtons();
        }

        // 更新距离表显示
        function updateDistanceTable() {
            tableBody.innerHTML = '';

            for (const node of graph.nodes) {
                const row = document.createElement('tr');
                const nodeId = node.id;
                const distance = dijkstraState.distances[nodeId];
                const prevNode = dijkstraState.previous[nodeId];
                const isSettled = dijkstraState.settled.has(nodeId);
                const isCurrent = nodeId === dijkstraState.currentNode;

                // 设置行类名
                if (isCurrent) {
                    row.classList.add('current-row');
                } else if (isSettled) {
                    row.classList.add('settled-row');
                }

                // 节点单元格
                const nodeCell = document.createElement('td');
                nodeCell.textContent = nodeId;
                if (nodeId === dijkstraState.source) {
                    nodeCell.style.fontWeight = 'bold';
                    nodeCell.style.color = '#4CAF50';
                }
                row.appendChild(nodeCell);

                // 距离单元格
                const distanceCell = document.createElement('td');
                distanceCell.textContent = distance === Infinity ? '∞' : distance;
                distanceCell.id = `dist-${nodeId}`;
                row.appendChild(distanceCell);

                // 前驱节点单元格
                const prevCell = document.createElement('td');
                prevCell.textContent = prevNode || '-';
                prevCell.id = `prev-${nodeId}`;
                row.appendChild(prevCell);

                // 状态单元格
                const statusCell = document.createElement('td');
                if (nodeId === dijkstraState.source) {
                    statusCell.textContent = '源节点';
                } else if (isSettled) {
                    statusCell.textContent = '已确定';
                    statusCell.style.color = '#2196F3';
                    statusCell.style.fontWeight = 'bold';
                } else if (isCurrent) {
                    statusCell.textContent = '处理中';
                    statusCell.style.color = '#FF9800';
                    statusCell.style.fontWeight = 'bold';
                } else {
                    statusCell.textContent = '未处理';
                }
                row.appendChild(statusCell);

                tableBody.appendChild(row);
            }
        }

        // 高亮显示表格单元格更新
        function highlightTableUpdate(nodeId, newDistance, newPrev) {
            const distanceCell = document.getElementById(`dist-${nodeId}`);
            const prevCell = document.getElementById(`prev-${nodeId}`);

            if (distanceCell) {
                distanceCell.textContent = newDistance === Infinity ? '∞' : newDistance;
                distanceCell.classList.add('update-animation');
                setTimeout(() => {
                    distanceCell.classList.remove('update-animation');
                }, 800);
            }

            if (prevCell) {
                prevCell.textContent = newPrev || '-';
                prevCell.classList.add('update-animation');
                setTimeout(() => {
                    prevCell.classList.remove('update-animation');
                }, 800);
            }
        }

        // 更新状态文本
        function updateStatusText() {
            let status = '';

            if (dijkstraState.currentStep === 0) {
                status = dijkstraState.stepDescriptions[0];
            } else if (dijkstraState.currentStep === 1) {
                const currentNode = dijkstraState.currentNode;
                status = `${dijkstraState.stepDescriptions[1]} 当前选择节点 <span class="highlight">${currentNode}</span>，距离为 <span class="highlight">${dijkstraState.distances[currentNode]}</span>。`;
            } else if (dijkstraState.currentStep === 2) {
                status = `${dijkstraState.stepDescriptions[2]} 节点 <span class="highlight">${dijkstraState.currentNode}</span> 的最短路径已确定。`;
            } else if (dijkstraState.currentStep === 3) {
                if (dijkstraState.relaxingEdge) {
                    const edge = dijkstraState.relaxingEdge;
                    const fromDist = dijkstraState.distances[edge.from];
                    const toDist = dijkstraState.distances[edge.to];
                    const newDist = fromDist + edge.weight;

                    status = `${dijkstraState.stepDescriptions[3]} 正在检查边 <span class="highlight">${edge.from}→${edge.to}</span> (权重=${edge.weight})。<br>`;
                    status += `当前距离: dist[${edge.to}] = ${toDist === Infinity ? '∞' : toDist}<br>`;
                    status += `经过${edge.from}的距离: dist[${edge.from}] + ${edge.weight} = ${fromDist} + ${edge.weight} = ${newDist}<br>`;

                    if (newDist < toDist) {
                        status += `<span class="highlight">${newDist} < ${toDist === Infinity ? '∞' : toDist}，更新距离表！</span>`;
                    } else {
                        status += `${newDist} ≥ ${toDist === Infinity ? '∞' : toDist}，无需更新。`;
                    }
                } else {
                    status = `${dijkstraState.stepDescriptions[3]} 正在松弛节点 <span class="highlight">${dijkstraState.currentNode}</span> 的所有邻居。`;
                }
            } else if (dijkstraState.currentStep === 4) {
                status = dijkstraState.stepDescriptions[4];
            }

            statusText.innerHTML = status;
        }

        // 绘制图
        function drawGraph() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 绘制边
            for (const edge of graph.edges) {
                const fromNode = graph.nodes.find(n => n.id === edge.from);
                const toNode = graph.nodes.find(n => n.id === edge.to);

                // 确定边的颜色和宽度
                let edgeColor = '#BDBDBD';
                let edgeWidth = 1;

                // 检查是否是最短路径边
                const isShortestPathEdge = dijkstraState.previous[toNode.id] === fromNode.id ||
                    dijkstraState.previous[fromNode.id] === toNode.id;

                // 检查是否是当前正在松弛的边
                const isRelaxingEdge = dijkstraState.relaxingEdge &&
                    ((dijkstraState.relaxingEdge.from === edge.from &&
                        dijkstraState.relaxingEdge.to === edge.to) ||
                        (dijkstraState.relaxingEdge.from === edge.to &&
                            dijkstraState.relaxingEdge.to === edge.from));

                if (isRelaxingEdge) {
                    edgeColor = '#FF9800';
                    edgeWidth = 4;
                } else if (isShortestPathEdge && dijkstraState.settled.has(toNode.id) && dijkstraState.settled.has(fromNode.id)) {
                    edgeColor = '#2196F3';
                    edgeWidth = 3;
                }

                // 绘制边
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.strokeStyle = edgeColor;
                ctx.lineWidth = edgeWidth;
                ctx.stroke();

                // 绘制边的权重
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;

                // 绘制权重背景
                ctx.fillStyle = 'white';
                ctx.fillRect(midX - 15, midY - 10, 30, 20);

                // 绘制权重文本
                ctx.fillStyle = '#333';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(edge.weight.toString(), midX, midY);
            }

            // 绘制节点
            for (const node of graph.nodes) {
                // 确定节点颜色
                let nodeColor = '#E0E0E0'; // 默认：未处理

                if (node.id === dijkstraState.source) {
                    nodeColor = '#4CAF50'; // 源节点
                } else if (dijkstraState.settled.has(node.id)) {
                    nodeColor = '#2196F3'; // 已确定
                } else if (node.id === dijkstraState.currentNode) {
                    nodeColor = '#FF9800'; // 当前节点
                }

                // 绘制节点
                ctx.beginPath();
                ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = nodeColor;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // 绘制节点标签
                ctx.fillStyle = 'white';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, node.x, node.y);

                // 如果节点有距离值且不是无穷大，在节点下方显示
                if (dijkstraState.distances[node.id] !== Infinity) {
                    ctx.fillStyle = '#333';
                    ctx.font = '14px Arial';
                    ctx.fillText(`d=${dijkstraState.distances[node.id]}`, node.x, node.y + 35);
                }
            }
        }

        // 执行Dijkstra算法的下一步
        function nextStep() {
            saveStateToHistory();

            // 步骤1: 选择当前节点（如果还没有当前节点）
            if (dijkstraState.currentNode === null) {
                dijkstraState.currentStep = 1;

                // 找到未处理节点中距离最小的节点
                let minDistance = Infinity;
                let minNode = null;

                for (const node of graph.nodes) {
                    if (!dijkstraState.settled.has(node.id) && dijkstraState.distances[node.id] < minDistance) {
                        minDistance = dijkstraState.distances[node.id];
                        minNode = node.id;
                    }
                }

                if (minNode !== null) {
                    dijkstraState.currentNode = minNode;
                } else {
                    // 所有节点都已处理
                    dijkstraState.currentStep = 4;
                    updateStatusText();
                    updateControlButtons();
                    return;
                }

                updateStatusText();
                drawGraph();
                return;
            }

            // 步骤2: 标记当前节点为已处理
            if (!dijkstraState.settled.has(dijkstraState.currentNode)) {
                dijkstraState.currentStep = 2;
                dijkstraState.settled.add(dijkstraState.currentNode);
                updateStatusText();
                updateDistanceTable();
                drawGraph();
                return;
            }

            // 步骤3: 松弛当前节点的邻居
            dijkstraState.currentStep = 3;

            // 找到当前节点的所有出边
            const outgoingEdges = graph.edges.filter(edge => edge.from === dijkstraState.currentNode);

            // 如果还有未松弛的边
            for (const edge of outgoingEdges) {
                // 如果邻居节点还未确定最短路径
                if (!dijkstraState.settled.has(edge.to)) {
                    dijkstraState.relaxingEdge = edge;
                    updateStatusText();
                    drawGraph();

                    // 执行松弛操作
                    const newDistance = dijkstraState.distances[edge.from] + edge.weight;
                    if (newDistance < dijkstraState.distances[edge.to]) {
                        dijkstraState.distances[edge.to] = newDistance;
                        dijkstraState.previous[edge.to] = edge.from;
                        highlightTableUpdate(edge.to, newDistance, edge.from);
                    }

                    // 短暂延迟后继续
                    setTimeout(() => {
                        dijkstraState.relaxingEdge = null;

                        // 检查是否所有邻居都已松弛
                        const nextEdgeIndex = outgoingEdges.indexOf(edge) + 1;
                        if (nextEdgeIndex < outgoingEdges.length) {
                            // 还有更多边要松弛
                            updateStatusText();
                            drawGraph();
                        } else {
                            // 所有邻居都已松弛，准备选择下一个节点
                            dijkstraState.currentNode = null;
                            nextStep();
                        }
                    }, dijkstraState.animationSpeed);

                    return;
                }
            }

            // 如果没有未松弛的边，准备选择下一个节点
            dijkstraState.currentNode = null;
            nextStep();
        }

        // 上一步
        function prevStep() {
            if (dijkstraState.history.length > 1) {
                restoreStateFromHistory(dijkstraState.history.length - 2);
                updateControlButtons();
            }
        }

        // 自动完成算法
        function autoComplete() {
            if (dijkstraState.isPlaying) return;

            dijkstraState.isPlaying = true;
            playPauseBtn.textContent = '暂停';
            nextStepBtn.disabled = true;
            prevStepBtn.disabled = true;
            autoCompleteBtn.disabled = true;

            function continueAutoComplete() {
                if (!dijkstraState.isPlaying) return;

                // 检查算法是否完成
                const allSettled = graph.nodes.every(node => dijkstraState.settled.has(node.id));
                if (allSettled) {
                    dijkstraState.isPlaying = false;
                    playPauseBtn.textContent = '播放';
                    nextStepBtn.disabled = false;
                    prevStepBtn.disabled = false;
                    autoCompleteBtn.disabled = false;
                    updateControlButtons();
                    return;
                }

                nextStep();
                setTimeout(continueAutoComplete, dijkstraState.animationSpeed);
            }

            continueAutoComplete();
        }

        // 更新控制按钮状态
        function updateControlButtons() {
            prevStepBtn.disabled = dijkstraState.history.length <= 1;

            // 检查算法是否完成
            const allSettled = graph.nodes.every(node => dijkstraState.settled.has(node.id));
            nextStepBtn.disabled = allSettled;
            autoCompleteBtn.disabled = allSettled;

            if (allSettled) {
                playPauseBtn.disabled = true;
            }
        }

        // 事件监听器
        resetBtn.addEventListener('click', () => {
            dijkstraState.isPlaying = false;
            playPauseBtn.textContent = '播放';
            initializeDistances();
            updateControlButtons();
        });

        prevStepBtn.addEventListener('click', prevStep);

        playPauseBtn.addEventListener('click', () => {
            if (dijkstraState.isPlaying) {
                dijkstraState.isPlaying = false;
                playPauseBtn.textContent = '播放';
                nextStepBtn.disabled = false;
                prevStepBtn.disabled = false;
                autoCompleteBtn.disabled = false;
            } else {
                dijkstraState.isPlaying = true;
                playPauseBtn.textContent = '暂停';
                nextStepBtn.disabled = true;
                prevStepBtn.disabled = true;
                autoCompleteBtn.disabled = true;

                function continuePlay() {
                    if (!dijkstraState.isPlaying) return;

                    // 检查算法是否完成
                    const allSettled = graph.nodes.every(node => dijkstraState.settled.has(node.id));
                    if (allSettled) {
                        dijkstraState.isPlaying = false;
                        playPauseBtn.textContent = '播放';
                        nextStepBtn.disabled = false;
                        prevStepBtn.disabled = false;
                        autoCompleteBtn.disabled = false;
                        updateControlButtons();
                        return;
                    }

                    nextStep();
                    setTimeout(continuePlay, dijkstraState.animationSpeed);
                }

                continuePlay();
            }
        });

        nextStepBtn.addEventListener('click', () => {
            if (!dijkstraState.isPlaying) {
                nextStep();
                updateControlButtons();
            }
        });

        autoCompleteBtn.addEventListener('click', autoComplete);

        speedSlider.addEventListener('input', () => {
            // 速度值从1-10，对应延迟1000ms到100ms
            dijkstraState.animationSpeed = 1100 - (speedSlider.value * 100);
        });

        // 画布悬停提示
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 检查是否悬停在节点上
            let hoveredNode = null;
            for (const node of graph.nodes) {
                const distance = Math.sqrt((x - node.x) ** 2 + (y - node.y) ** 2);
                if (distance <= 20) {
                    hoveredNode = node;
                    break;
                }
            }

            // 检查是否悬停在边上
            let hoveredEdge = null;
            if (!hoveredNode) {
                for (const edge of graph.edges) {
                    const fromNode = graph.nodes.find(n => n.id === edge.from);
                    const toNode = graph.nodes.find(n => n.id === edge.to);

                    // 计算点到线段的距离
                    const A = { x: fromNode.x, y: fromNode.y };
                    const B = { x: toNode.x, y: toNode.y };
                    const P = { x, y };

                    const AB = { x: B.x - A.x, y: B.y - A.y };
                    const AP = { x: P.x - A.x, y: P.y - A.y };
                    const BP = { x: P.x - B.x, y: P.y - B.y };

                    const dotABAP = AB.x * AP.x + AB.y * AP.y;
                    const dotABAB = AB.x * AB.x + AB.y * AB.y;

                    let distance;
                    if (dotABAP <= 0) {
                        distance = Math.sqrt(AP.x * AP.x + AP.y * AP.y);
                    } else if (dotABAP >= dotABAB) {
                        distance = Math.sqrt(BP.x * BP.x + BP.y * BP.y);
                    } else {
                        const modAB = Math.sqrt(dotABAB);
                        distance = Math.abs(AB.x * AP.y - AB.y * AP.x) / modAB;
                    }

                    if (distance <= 5) {
                        hoveredEdge = edge;
                        break;
                    }
                }
            }

            // 显示提示
            if (hoveredNode) {
                tooltip.style.display = 'block';
                tooltip.style.left = `${e.clientX + 10}px`;
                tooltip.style.top = `${e.clientY + 10}px`;

                let tooltipText = `节点 ${hoveredNode.id}`;
                tooltipText += `<br>距离: ${dijkstraState.distances[hoveredNode.id] === Infinity ? '∞' : dijkstraState.distances[hoveredNode.id]}`;
                tooltipText += `<br>前驱: ${dijkstraState.previous[hoveredNode.id] || '无'}`;

                if (hoveredNode.id === dijkstraState.source) {
                    tooltipText += `<br>状态: 源节点`;
                } else if (dijkstraState.settled.has(hoveredNode.id)) {
                    tooltipText += `<br>状态: 已确定最短路径`;
                } else if (hoveredNode.id === dijkstraState.currentNode) {
                    tooltipText += `<br>状态: 当前处理节点`;
                } else {
                    tooltipText += `<br>状态: 未处理`;
                }

                tooltip.innerHTML = tooltipText;
            } else if (hoveredEdge) {
                tooltip.style.display = 'block';
                tooltip.style.left = `${e.clientX + 10}px`;
                tooltip.style.top = `${e.clientY + 10}px`;

                let tooltipText = `边 ${hoveredEdge.from} → ${hoveredEdge.to}`;
                tooltipText += `<br>权重: ${hoveredEdge.weight}`;

                // 检查是否是最短路径的一部分
                if (dijkstraState.previous[hoveredEdge.to] === hoveredEdge.from ||
                    dijkstraState.previous[hoveredEdge.from] === hoveredEdge.to) {
                    tooltipText += `<br>状态: 最短路径的一部分`;
                } else if (dijkstraState.relaxingEdge &&
                    ((dijkstraState.relaxingEdge.from === hoveredEdge.from &&
                        dijkstraState.relaxingEdge.to === hoveredEdge.to) ||
                        (dijkstraState.relaxingEdge.from === hoveredEdge.to &&
                            dijkstraState.relaxingEdge.to === hoveredEdge.from))) {
                    tooltipText += `<br>状态: 当前正在松弛`;
                } else {
                    tooltipText += `<br>状态: 普通边`;
                }

                tooltip.innerHTML = tooltipText;
            } else {
                tooltip.style.display = 'none';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
        });

        // 初始化
        initializeDistances();
        updateControlButtons();

        // 窗口大小调整时重新绘制
        window.addEventListener('resize', () => {
            drawGraph();
        });
    </script>
</body>

</html>