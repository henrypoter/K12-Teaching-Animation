<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å †æ’åºç®—æ³•å¯è§†åŒ– | Heap Sort Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #2c3e50;
            color: #ecf0f1;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        header {
            text-align: center;
            padding: 15px;
            border-bottom: 2px solid #3498db;
            margin-bottom: 10px;
        }
        
        h1 {
            color: #3498db;
            font-size: 2.5rem;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: #bdc3c7;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .visualization-section {
            flex: 2;
            min-width: 300px;
            background-color: rgba(44, 62, 80, 0.8);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .control-section {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .panel {
            background-color: rgba(44, 62, 80, 0.8);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .panel-title {
            color: #3498db;
            font-size: 1.3rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #3498db;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            border: 2px solid #34495e;
            border-radius: 8px;
            overflow: hidden;
            background-color: #1a252f;
        }
        
        #treeCanvas, #arrayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        
        .btn-secondary {
            background-color: #7f8c8d;
            color: white;
        }
        
        .btn-success {
            background-color: #2ecc71;
            color: white;
        }
        
        .btn-warning {
            background-color: #f1c40f;
            color: #2c3e50;
        }
        
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        
        .config-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .option-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .option-label {
            font-weight: bold;
            color: #bdc3c7;
        }
        
        .radio-group {
            display: flex;
            gap: 15px;
        }
        
        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        input[type="radio"] {
            accent-color: #3498db;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            accent-color: #3498db;
        }
        
        .status-display {
            background-color: rgba(26, 37, 47, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #34495e;
        }
        
        .status-item:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }
        
        .status-label {
            color: #bdc3c7;
        }
        
        .status-value {
            font-weight: bold;
            color: #3498db;
        }
        
        .step-description {
            background-color: rgba(26, 37, 47, 0.8);
            border-radius: 8px;
            padding: 15px;
            min-height: 120px;
            line-height: 1.6;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .legend-text {
            font-size: 0.9rem;
            color: #bdc3c7;
        }
        
        .code-panel {
            font-family: 'Consolas', 'Monaco', monospace;
            background-color: #1a252f;
            border-radius: 8px;
            padding: 15px;
            overflow-x: auto;
            line-height: 1.5;
        }
        
        .code-line {
            padding: 2px 5px;
            margin: 2px 0;
            border-radius: 3px;
            transition: background-color 0.3s;
        }
        
        .code-line.active {
            background-color: rgba(52, 152, 219, 0.3);
            color: #3498db;
            font-weight: bold;
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #34495e;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å †æ’åºç®—æ³•å¯è§†åŒ–</h1>
            <p class="subtitle">Heap Sort Visualization | å»ºå † â†’ å–æ ¹ â†’ è°ƒæ•´ â†’ æ’åºå®Œæˆ</p>
        </header>
        
        <div class="main-content">
            <section class="visualization-section">
                <h2 class="panel-title">å †æ’åºè¿‡ç¨‹å¯è§†åŒ–</h2>
                <div class="canvas-container">
                    <canvas id="treeCanvas"></canvas>
                    <canvas id="arrayCanvas"></canvas>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ecf0f1;"></div>
                        <span class="legend-text">é»˜è®¤èŠ‚ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #3498db;"></div>
                        <span class="legend-text">å½“å‰æ“ä½œèŠ‚ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f1c40f;"></div>
                        <span class="legend-text">æ¯”è¾ƒèŠ‚ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e74c3c;"></div>
                        <span class="legend-text">äº¤æ¢èŠ‚ç‚¹</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #2ecc71;"></div>
                        <span class="legend-text">å·²æ’åºå…ƒç´ </span>
                    </div>
                </div>
            </section>
            
            <section class="control-section">
                <div class="panel">
                    <h2 class="panel-title">åŠ¨ç”»æ§åˆ¶</h2>
                    <div class="control-buttons">
                        <button id="playPauseBtn" class="btn-primary">â–¶ æ’­æ”¾</button>
                        <button id="nextStepBtn" class="btn-secondary">â­ ä¸‹ä¸€æ­¥</button>
                        <button id="prevStepBtn" class="btn-secondary">â® ä¸Šä¸€æ­¥</button>
                        <button id="resetBtn" class="btn-warning">â†º é‡ç½®</button>
                        <button id="randomizeBtn" class="btn-success">ğŸ² éšæœºæ•°æ®</button>
                    </div>
                    
                    <div class="config-options">
                        <div class="option-group">
                            <div class="option-label">æ’åºæ¨¡å¼</div>
                            <div class="radio-group">
                                <label class="radio-option">
                                    <input type="radio" name="sortMode" value="max" checked>
                                    <span>å¤§é¡¶å † (å‡åºæ’åº)</span>
                                </label>
                                <label class="radio-option">
                                    <input type="radio" name="sortMode" value="min">
                                    <span>å°é¡¶å † (é™åºæ’åº)</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="option-group">
                            <div class="option-label">åŠ¨ç”»é€Ÿåº¦</div>
                            <div class="slider-container">
                                <span>æ…¢</span>
                                <input type="range" id="speedSlider" min="1" max="10" value="5">
                                <span>å¿«</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="status-display">
                        <div class="status-item">
                            <span class="status-label">å½“å‰æ­¥éª¤:</span>
                            <span id="currentStep" class="status-value">å‡†å¤‡å¼€å§‹</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">å †å¤§å°:</span>
                            <span id="heapSize" class="status-value">10</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">å·²æ’åº:</span>
                            <span id="sortedCount" class="status-value">0</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">æ¯”è¾ƒæ¬¡æ•°:</span>
                            <span id="comparisonCount" class="status-value">0</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">äº¤æ¢æ¬¡æ•°:</span>
                            <span id="swapCount" class="status-value">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel">
                    <h2 class="panel-title">æ­¥éª¤è¯´æ˜</h2>
                    <div class="step-description" id="stepDescription">
                        ç‚¹å‡»"æ’­æ”¾"æŒ‰é’®å¼€å§‹å †æ’åºå¯è§†åŒ–æ¼”ç¤ºã€‚ç®—æ³•åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼š1) å»ºå †é˜¶æ®µï¼šä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œè‡ªåº•å‘ä¸Šè°ƒæ•´ï¼Œæ„å»ºå¤§é¡¶å †/å°é¡¶å †ï¼›2) æ’åºé˜¶æ®µï¼šåå¤å°†å †é¡¶å…ƒç´ ä¸æœ«å°¾å…ƒç´ äº¤æ¢ï¼Œç„¶åè°ƒæ•´å †ç»“æ„ã€‚
                    </div>
                </div>
            </section>
        </div>
        
        <div class="panel">
            <h2 class="panel-title">ç®—æ³•ä¼ªä»£ç </h2>
            <div class="code-panel">
                <div id="codeLine1" class="code-line">function heapSort(arr):</div>
                <div id="codeLine2" class="code-line">    n = arr.length</div>
                <div id="codeLine3" class="code-line">    # 1. å»ºå †é˜¶æ®µ</div>
                <div id="codeLine4" class="code-line">    for i = n/2 - 1 down to 0:</div>
                <div id="codeLine5" class="code-line">        heapify(arr, n, i)</div>
                <div id="codeLine6" class="code-line">    # 2. æ’åºé˜¶æ®µ</div>
                <div id="codeLine7" class="code-line">    for i = n-1 down to 1:</div>
                <div id="codeLine8" class="code-line">        swap(arr[0], arr[i])</div>
                <div id="codeLine9" class="code-line">        heapify(arr, i, 0)</div>
                <div id="codeLine10" class="code-line"></div>
                <div id="codeLine11" class="code-line">function heapify(arr, n, i):</div>
                <div id="codeLine12" class="code-line">    largest = i  # æˆ– smallest å¯¹äºå°é¡¶å †</div>
                <div id="codeLine13" class="code-line">    left = 2*i + 1</div>
                <div id="codeLine14" class="code-line">    right = 2*i + 2</div>
                <div id="codeLine15" class="code-line">    </div>
                <div id="codeLine16" class="code-line">    if left < n and arr[left] > arr[largest]:</div>
                <div id="codeLine17" class="code-line">        largest = left</div>
                <div id="codeLine18" class="code-line">    </div>
                <div id="codeLine19" class="code-line">    if right < n and arr[right] > arr[largest]:</div>
                <div id="codeLine20" class="code-line">        largest = right</div>
                <div id="codeLine21" class="code-line">    </div>
                <div id="codeLine22" class="code-line">    if largest != i:</div>
                <div id="codeLine23" class="code-line">        swap(arr[i], arr[largest])</div>
                <div id="codeLine24" class="code-line">        heapify(arr, n, largest)</div>
            </div>
        </div>
        
        <footer class="footer">
            <p>å †æ’åºç®—æ³•å¯è§†åŒ– | æ—¶é—´å¤æ‚åº¦: O(n log n) | ç©ºé—´å¤æ‚åº¦: O(1) | ä¸ç¨³å®šæ’åº</p>
            <p>äº¤äº’å¼æ•™å­¦åŠ¨ç”»è®¾è®¡ | ä½¿ç”¨HTML5 Canvaså®ç°</p>
        </footer>
    </div>

    <script>
        // å †æ’åºå¯è§†åŒ–ä¸»ç¨‹åº
        document.addEventListener('DOMContentLoaded', function() {
            // å¸¸é‡å®šä¹‰
            const TREE_CANVAS = document.getElementById('treeCanvas');
            const ARRAY_CANVAS = document.getElementById('arrayCanvas');
            const TREE_CTX = TREE_CANVAS.getContext('2d');
            const ARRAY_CTX = ARRAY_CANVAS.getContext('2d');
            
            // çŠ¶æ€å˜é‡
            let data = [];
            let heapSize = 0;
            let sortedElements = [];
            let animationState = {
                phase: 'idle', // 'idle', 'building', 'sorting', 'heapifying'
                stepIndex: 0,
                currentIndex: -1,
                comparingIndex: -1,
                swappingIndex: -1,
                heapifyRoot: -1,
                heapifyTarget: -1,
                isMaxHeap: true,
                isPlaying: false,
                speed: 500,
                comparisonCount: 0,
                swapCount: 0,
                steps: []
            };
            
            // åˆå§‹åŒ–æ•°æ®
            function initializeData() {
                data = [];
                const size = 10;
                for (let i = 0; i < size; i++) {
                    data.push(Math.floor(Math.random() * 90) + 10); // 10-99ä¹‹é—´çš„éšæœºæ•°
                }
                heapSize = data.length;
                sortedElements = [];
                animationState.stepIndex = 0;
                animationState.currentIndex = -1;
                animationState.comparingIndex = -1;
                animationState.swappingIndex = -1;
                animationState.heapifyRoot = -1;
                animationState.heapifyTarget = -1;
                animationState.comparisonCount = 0;
                animationState.swapCount = 0;
                animationState.steps = [];
                animationState.phase = 'idle';
                
                updateStatusDisplay();
                updateStepDescription('å·²ç”Ÿæˆæ–°çš„éšæœºæ•°æ®ã€‚ç‚¹å‡»"æ’­æ”¾"æŒ‰é’®å¼€å§‹å †æ’åºæ¼”ç¤ºã€‚');
                highlightCodeLine(1);
                drawVisualization();
            }
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            function updateStatusDisplay() {
                document.getElementById('heapSize').textContent = heapSize;
                document.getElementById('sortedCount').textContent = sortedElements.length;
                document.getElementById('comparisonCount').textContent = animationState.comparisonCount;
                document.getElementById('swapCount').textContent = animationState.swapCount;
                
                const modeRadios = document.getElementsByName('sortMode');
                animationState.isMaxHeap = modeRadios[0].checked;
                document.getElementById('currentStep').textContent = 
                    animationState.phase === 'idle' ? 'å‡†å¤‡å¼€å§‹' :
                    animationState.phase === 'building' ? 'å»ºå †é˜¶æ®µ' :
                    animationState.phase === 'sorting' ? 'æ’åºé˜¶æ®µ' :
                    animationState.phase === 'heapifying' ? 'è°ƒæ•´å †' : 'å®Œæˆ';
            }
            
            // æ›´æ–°æ­¥éª¤è¯´æ˜
            function updateStepDescription(text) {
                document.getElementById('stepDescription').textContent = text;
            }
            
            // é«˜äº®ä»£ç è¡Œ
            function highlightCodeLine(lineNumber) {
                // æ¸…é™¤æ‰€æœ‰é«˜äº®
                for (let i = 1; i <= 24; i++) {
                    const lineElement = document.getElementById(`codeLine${i}`);
                    if (lineElement) {
                        lineElement.classList.remove('active');
                    }
                }
                
                // é«˜äº®æŒ‡å®šè¡Œ
                const activeLine = document.getElementById(`codeLine${lineNumber}`);
                if (activeLine) {
                    activeLine.classList.add('active');
                }
            }
            
            // ç»˜åˆ¶æ ‘å½¢è§†å›¾
            function drawTree() {
                TREE_CTX.clearRect(0, 0, TREE_CANVAS.width, TREE_CANVAS.height);
                
                // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                TREE_CANVAS.width = TREE_CANVAS.parentElement.clientWidth;
                TREE_CANVAS.height = TREE_CANVAS.parentElement.clientHeight;
                
                const nodeRadius = 25;
                const levelHeight = 80;
                const canvasWidth = TREE_CANVAS.width;
                
                // è®¡ç®—æ ‘çš„æ·±åº¦
                const treeDepth = Math.floor(Math.log2(heapSize)) + 1;
                
                // é€’å½’ç»˜åˆ¶èŠ‚ç‚¹
                function drawNode(index, x, y, level) {
                    if (index >= heapSize) return;
                    
                    // ç¡®å®šèŠ‚ç‚¹é¢œè‰²
                    let nodeColor = '#ecf0f1'; // é»˜è®¤
                    if (index === animationState.currentIndex) {
                        nodeColor = '#3498db'; // å½“å‰æ“ä½œèŠ‚ç‚¹
                    } else if (index === animationState.comparingIndex) {
                        nodeColor = '#f1c40f'; // æ¯”è¾ƒèŠ‚ç‚¹
                    } else if (index === animationState.swappingIndex) {
                        nodeColor = '#e74c3c'; // äº¤æ¢èŠ‚ç‚¹
                    } else if (index === animationState.heapifyRoot || index === animationState.heapifyTarget) {
                        nodeColor = '#3498db'; // å †åŒ–ç›¸å…³èŠ‚ç‚¹
                    }
                    
                    // ç»˜åˆ¶è¿æ¥çº¿åˆ°å­èŠ‚ç‚¹
                    const leftChildIndex = 2 * index + 1;
                    const rightChildIndex = 2 * index + 2;
                    
                    if (leftChildIndex < heapSize) {
                        const childX = x - (canvasWidth / Math.pow(2, level + 2));
                        const childY = y + levelHeight;
                        
                        TREE_CTX.beginPath();
                        TREE_CTX.moveTo(x, y + nodeRadius);
                        TREE_CTX.lineTo(childX, childY - nodeRadius);
                        TREE_CTX.strokeStyle = '#7f8c8d';
                        TREE_CTX.lineWidth = 2;
                        TREE_CTX.stroke();
                        
                        drawNode(leftChildIndex, childX, childY, level + 1);
                    }
                    
                    if (rightChildIndex < heapSize) {
                        const childX = x + (canvasWidth / Math.pow(2, level + 2));
                        const childY = y + levelHeight;
                        
                        TREE_CTX.beginPath();
                        TREE_CTX.moveTo(x, y + nodeRadius);
                        TREE_CTX.lineTo(childX, childY - nodeRadius);
                        TREE_CTX.strokeStyle = '#7f8c8d';
                        TREE_CTX.lineWidth = 2;
                        TREE_CTX.stroke();
                        
                        drawNode(rightChildIndex, childX, childY, level + 1);
                    }
                    
                    // ç»˜åˆ¶èŠ‚ç‚¹
                    TREE_CTX.beginPath();
                    TREE_CTX.arc(x, y, nodeRadius, 0, Math.PI * 2);
                    TREE_CTX.fillStyle = nodeColor;
                    TREE_CTX.fill();
                    TREE_CTX.strokeStyle = '#34495e';
                    TREE_CTX.lineWidth = 2;
                    TREE_CTX.stroke();
                    
                    // ç»˜åˆ¶èŠ‚ç‚¹å€¼
                    TREE_CTX.fillStyle = '#2c3e50';
                    TREE_CTX.font = 'bold 16px Arial';
                    TREE_CTX.textAlign = 'center';
                    TREE_CTX.textBaseline = 'middle';
                    TREE_CTX.fillText(data[index], x, y);
                    
                    // ç»˜åˆ¶èŠ‚ç‚¹ç´¢å¼•
                    TREE_CTX.fillStyle = '#7f8c8d';
                    TREE_CTX.font = '12px Arial';
                    TREE_CTX.fillText(`[${index}]`, x, y + nodeRadius + 15);
                }
                
                // ä»æ ¹èŠ‚ç‚¹å¼€å§‹ç»˜åˆ¶
                const rootX = canvasWidth / 2;
                const rootY = nodeRadius + 30;
                drawNode(0, rootX, rootY, 1);
                
                // ç»˜åˆ¶å·²æ’åºå…ƒç´ 
                const sortedStartY = TREE_CANVAS.height - 60;
                const sortedSpacing = 40;
                
                TREE_CTX.fillStyle = '#bdc3c7';
                TREE_CTX.font = '14px Arial';
                TREE_CTX.textAlign = 'left';
                TREE_CTX.fillText('å·²æ’åºå…ƒç´ :', 20, sortedStartY - 20);
                
                for (let i = 0; i < sortedElements.length; i++) {
                    const x = 30 + i * sortedSpacing;
                    const y = sortedStartY;
                    
                    TREE_CTX.beginPath();
                    TREE_CTX.arc(x, y, 15, 0, Math.PI * 2);
                    TREE_CTX.fillStyle = '#2ecc71';
                    TREE_CTX.fill();
                    TREE_CTX.strokeStyle = '#27ae60';
                    TREE_CTX.lineWidth = 2;
                    TREE_CTX.stroke();
                    
                    TREE_CTX.fillStyle = '#2c3e50';
                    TREE_CTX.font = 'bold 14px Arial';
                    TREE_CTX.textAlign = 'center';
                    TREE_CTX.textBaseline = 'middle';
                    TREE_CTX.fillText(sortedElements[i], x, y);
                }
            }
            
            // ç»˜åˆ¶æ•°ç»„è§†å›¾
            function drawArray() {
                ARRAY_CTX.clearRect(0, 0, ARRAY_CANVAS.width, ARRAY_CANVAS.height);
                
                // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                ARRAY_CANVAS.width = ARRAY_CANVAS.parentElement.clientWidth;
                ARRAY_CANVAS.height = ARRAY_CANVAS.parentElement.clientHeight;
                
                const cellWidth = 50;
                const cellHeight = 40;
                const startX = (ARRAY_CANVAS.width - (data.length * cellWidth)) / 2;
                const startY = 50;
                
                // ç»˜åˆ¶æ•°ç»„æ ‡é¢˜
                ARRAY_CTX.fillStyle = '#bdc3c7';
                ARRAY_CTX.font = 'bold 18px Arial';
                ARRAY_CTX.textAlign = 'center';
                ARRAY_CTX.fillText('æ•°ç»„è¡¨ç¤º', ARRAY_CANVAS.width / 2, 30);
                
                // ç»˜åˆ¶å †èŒƒå›´æŒ‡ç¤º
                if (heapSize < data.length) {
                    ARRAY_CTX.fillStyle = 'rgba(52, 152, 219, 0.2)';
                    ARRAY_CTX.fillRect(
                        startX + heapSize * cellWidth, 
                        startY - 5, 
                        (data.length - heapSize) * cellWidth, 
                        cellHeight + 10
                    );
                    
                    ARRAY_CTX.fillStyle = '#3498db';
                    ARRAY_CTX.font = '14px Arial';
                    ARRAY_CTX.textAlign = 'center';
                    ARRAY_CTX.fillText(
                        `å †èŒƒå›´: 0-${heapSize-1}`, 
                        startX + (heapSize + (data.length - heapSize) / 2) * cellWidth, 
                        startY + cellHeight + 25
                    );
                }
                
                // ç»˜åˆ¶æ•°ç»„å…ƒç´ 
                for (let i = 0; i < data.length; i++) {
                    const x = startX + i * cellWidth;
                    const y = startY;
                    
                    // ç¡®å®šå•å…ƒæ ¼é¢œè‰²
                    let cellColor = '#ecf0f1'; // é»˜è®¤
                    if (i === animationState.currentIndex) {
                        cellColor = '#3498db'; // å½“å‰æ“ä½œèŠ‚ç‚¹
                    } else if (i === animationState.comparingIndex) {
                        cellColor = '#f1c40f'; // æ¯”è¾ƒèŠ‚ç‚¹
                    } else if (i === animationState.swappingIndex) {
                        cellColor = '#e74c3c'; // äº¤æ¢èŠ‚ç‚¹
                    } else if (i === animationState.heapifyRoot || i === animationState.heapifyTarget) {
                        cellColor = '#3498db'; // å †åŒ–ç›¸å…³èŠ‚ç‚¹
                    } else if (i >= heapSize) {
                        cellColor = '#2ecc71'; // å·²æ’åºå…ƒç´ 
                    }
                    
                    // ç»˜åˆ¶å•å…ƒæ ¼
                    ARRAY_CTX.fillStyle = cellColor;
                    ARRAY_CTX.fillRect(x, y, cellWidth, cellHeight);
                    ARRAY_CTX.strokeStyle = '#34495e';
                    ARRAY_CTX.lineWidth = 2;
                    ARRAY_CTX.strokeRect(x, y, cellWidth, cellHeight);
                    
                    // ç»˜åˆ¶å€¼
                    ARRAY_CTX.fillStyle = '#2c3e50';
                    ARRAY_CTX.font = 'bold 16px Arial';
                    ARRAY_CTX.textAlign = 'center';
                    ARRAY_CTX.textBaseline = 'middle';
                    ARRAY_CTX.fillText(data[i], x + cellWidth / 2, y + cellHeight / 2);
                    
                    // ç»˜åˆ¶ç´¢å¼•
                    ARRAY_CTX.fillStyle = '#7f8c8d';
                    ARRAY_CTX.font = '12px Arial';
                    ARRAY_CTX.fillText(`[${i}]`, x + cellWidth / 2, y + cellHeight + 15);
                }
            }
            
            // ç»˜åˆ¶å¯è§†åŒ–
            function drawVisualization() {
                drawTree();
                drawArray();
            }
            
            // æ‰§è¡Œå»ºå †é˜¶æ®µ
            async function buildHeap() {
                animationState.phase = 'building';
                updateStatusDisplay();
                
                // ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹
                const startIdx = Math.floor(heapSize / 2) - 1;
                
                for (let i = startIdx; i >= 0; i--) {
                    await heapify(i, heapSize);
                }
                
                updateStepDescription(`å»ºå †å®Œæˆï¼ç°åœ¨å †é¡¶å…ƒç´ æ˜¯${animationState.isMaxHeap ? 'æœ€å¤§' : 'æœ€å°'}å€¼: ${data[0]}`);
                highlightCodeLine(6);
                
                // å»ºå †å®Œæˆåè¿›å…¥æ’åºé˜¶æ®µ
                animationState.phase = 'sorting';
                updateStatusDisplay();
            }
            
            // å †åŒ–å‡½æ•°
            async function heapify(rootIndex, size) {
                animationState.heapifyRoot = rootIndex;
                animationState.phase = 'heapifying';
                updateStatusDisplay();
                highlightCodeLine(11);
                
                let largestOrSmallest = rootIndex;
                const leftChildIndex = 2 * rootIndex + 1;
                const rightChildIndex = 2 * rootIndex + 2;
                
                // ä¸å·¦å­èŠ‚ç‚¹æ¯”è¾ƒ
                if (leftChildIndex < size) {
                    animationState.comparingIndex = leftChildIndex;
                    animationState.currentIndex = largestOrSmallest;
                    updateStepDescription(`æ¯”è¾ƒèŠ‚ç‚¹[${largestOrSmallest}](${data[largestOrSmallest]})å’Œå·¦å­èŠ‚ç‚¹[${leftChildIndex}](${data[leftChildIndex]})`);
                    drawVisualization();
                    animationState.comparisonCount++;
                    updateStatusDisplay();
                    highlightCodeLine(16);
                    
                    await sleep(animationState.speed);
                    
                    const shouldUpdate = animationState.isMaxHeap ? 
                        data[leftChildIndex] > data[largestOrSmallest] : 
                        data[leftChildIndex] < data[largestOrSmallest];
                    
                    if (shouldUpdate) {
                        largestOrSmallest = leftChildIndex;
                        highlightCodeLine(17);
                    }
                }
                
                // ä¸å³å­èŠ‚ç‚¹æ¯”è¾ƒ
                if (rightChildIndex < size) {
                    animationState.comparingIndex = rightChildIndex;
                    animationState.currentIndex = largestOrSmallest;
                    updateStepDescription(`æ¯”è¾ƒèŠ‚ç‚¹[${largestOrSmallest}](${data[largestOrSmallest]})å’Œå³å­èŠ‚ç‚¹[${rightChildIndex}](${data[rightChildIndex]})`);
                    drawVisualization();
                    animationState.comparisonCount++;
                    updateStatusDisplay();
                    highlightCodeLine(19);
                    
                    await sleep(animationState.speed);
                    
                    const shouldUpdate = animationState.isMaxHeap ? 
                        data[rightChildIndex] > data[largestOrSmallest] : 
                        data[rightChildIndex] < data[largestOrSmallest];
                    
                    if (shouldUpdate) {
                        largestOrSmallest = rightChildIndex;
                        highlightCodeLine(20);
                    }
                }
                
                // å¦‚æœéœ€è¦äº¤æ¢
                if (largestOrSmallest !== rootIndex) {
                    animationState.heapifyTarget = largestOrSmallest;
                    animationState.swappingIndex = rootIndex;
                    updateStepDescription(`äº¤æ¢èŠ‚ç‚¹[${rootIndex}](${data[rootIndex]})å’ŒèŠ‚ç‚¹[${largestOrSmallest}](${data[largestOrSmallest]})`);
                    highlightCodeLine(22);
                    
                    drawVisualization();
                    await sleep(animationState.speed);
                    
                    // æ‰§è¡Œäº¤æ¢
                    [data[rootIndex], data[largestOrSmallest]] = [data[largestOrSmallest], data[rootIndex]];
                    animationState.swapCount++;
                    updateStatusDisplay();
                    highlightCodeLine(23);
                    
                    drawVisualization();
                    await sleep(animationState.speed);
                    
                    // é€’å½’å †åŒ–å—å½±å“çš„å­æ ‘
                    highlightCodeLine(24);
                    await heapify(largestOrSmallest, size);
                }
                
                animationState.heapifyRoot = -1;
                animationState.heapifyTarget = -1;
                animationState.comparingIndex = -1;
                animationState.currentIndex = -1;
                animationState.swappingIndex = -1;
            }
            
            // æ‰§è¡Œæ’åºé˜¶æ®µ
            async function sortHeap() {
                for (let i = data.length - 1; i > 0; i--) {
                    // äº¤æ¢å †é¡¶å’Œå½“å‰æœ«å°¾å…ƒç´ 
                    animationState.currentIndex = 0;
                    animationState.swappingIndex = i;
                    updateStepDescription(`äº¤æ¢å †é¡¶å…ƒç´ [0](${data[0]})å’Œæœ«å°¾å…ƒç´ [${i}](${data[i]})ï¼Œå°†${animationState.isMaxHeap ? 'æœ€å¤§' : 'æœ€å°'}å€¼æ”¾åˆ°æ­£ç¡®ä½ç½®`);
                    highlightCodeLine(8);
                    
                    drawVisualization();
                    await sleep(animationState.speed);
                    
                    // æ‰§è¡Œäº¤æ¢
                    [data[0], data[i]] = [data[i], data[0]];
                    animationState.swapCount++;
                    updateStatusDisplay();
                    
                    drawVisualization();
                    await sleep(animationState.speed);
                    
                    // å°†äº¤æ¢åçš„å…ƒç´ æ ‡è®°ä¸ºå·²æ’åº
                    sortedElements.unshift(data[i]);
                    heapSize--;
                    
                    // è°ƒæ•´å †
                    highlightCodeLine(9);
                    if (heapSize > 1) {
                        await heapify(0, heapSize);
                    }
                    
                    updateStatusDisplay();
                    drawVisualization();
                    
                    if (i > 1) {
                        await sleep(animationState.speed);
                    }
                }
                
                // æœ€åä¸€ä¸ªå…ƒç´ 
                sortedElements.unshift(data[0]);
                heapSize = 0;
                
                animationState.phase = 'idle';
                updateStatusDisplay();
                updateStepDescription(`æ’åºå®Œæˆï¼${animationState.isMaxHeap ? 'å‡åº' : 'é™åº'}æ’åºç»“æœ: ${sortedElements.join(', ')}`);
                highlightCodeLine(1);
                
                // æ›´æ–°æ’­æ”¾æŒ‰é’®çŠ¶æ€
                const playPauseBtn = document.getElementById('playPauseBtn');
                playPauseBtn.textContent = 'â–¶ æ’­æ”¾';
                playPauseBtn.classList.remove('btn-danger');
                playPauseBtn.classList.add('btn-primary');
                animationState.isPlaying = false;
            }
            
            // æ‰§è¡Œä¸‹ä¸€æ­¥
            async function nextStep() {
                if (animationState.phase === 'idle') {
                    // å¼€å§‹å»ºå †
                    await buildHeap();
                } else if (animationState.phase === 'building' || animationState.phase === 'heapifying') {
                    // å»ºå †é˜¶æ®µ - ç»§ç»­æ‰§è¡Œ
                    // åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œéœ€è¦æ›´ç²¾ç»†çš„æ­¥éª¤æ§åˆ¶
                    // ä¸ºç®€åŒ–ï¼Œæˆ‘ä»¬ç›´æ¥æ‰§è¡Œå®Œæ•´å»ºå †
                    if (heapSize === data.length) {
                        await buildHeap();
                    }
                } else if (animationState.phase === 'sorting') {
                    // æ’åºé˜¶æ®µ - ç»§ç»­æ‰§è¡Œ
                    if (heapSize > 0) {
                        await sortHeap();
                    }
                }
            }
            
            // ç¡çœ å‡½æ•°ï¼ˆç”¨äºåŠ¨ç”»å»¶è¿Ÿï¼‰
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            // å¼€å§‹/æš‚åœåŠ¨ç”»
            async function togglePlayPause() {
                const playPauseBtn = document.getElementById('playPauseBtn');
                
                if (animationState.isPlaying) {
                    // æš‚åœ
                    animationState.isPlaying = false;
                    playPauseBtn.textContent = 'â–¶ æ’­æ”¾';
                    playPauseBtn.classList.remove('btn-danger');
                    playPauseBtn.classList.add('btn-primary');
                } else {
                    // å¼€å§‹æ’­æ”¾
                    animationState.isPlaying = true
<!--æ£€æµ‹åˆ°ä»£ç æˆªæ–­ï¼Œè‡ªåŠ¨ç»­å†™ä¸­...-->
playPauseBtn.textContent = 'â¸ æš‚åœ';
                    playPauseBtn.classList.remove('btn-primary');
                    playPauseBtn.classList.add('btn-danger');
                    
                    // å¦‚æœè¿˜æ²¡å¼€å§‹ï¼Œå…ˆå»ºå †
                    if (animationState.phase === 'idle') {
                        await buildHeap();
                    }
                    
                    // ç„¶åæ‰§è¡Œæ’åº
                    await sortHeap();
                    
                    // å®Œæˆåé‡ç½®æŒ‰é’®çŠ¶æ€
                    playPauseBtn.textContent = 'â–¶ æ’­æ”¾';
                    playPauseBtn.classList.remove('btn-danger');
                    playPauseBtn.classList.add('btn-primary');
                    animationState.isPlaying = false;
                }
            }
            
            // ä¸Šä¸€æ­¥ï¼ˆç®€åŒ–å®ç°ï¼Œé‡ç½®åˆ°åˆå§‹çŠ¶æ€ï¼‰
            function prevStep() {
                if (animationState.stepIndex > 0) {
                    animationState.stepIndex--;
                    // åœ¨å®é™…å®Œæ•´å®ç°ä¸­ï¼Œè¿™é‡Œåº”è¯¥æ¢å¤ä¹‹å‰çš„çŠ¶æ€
                    // ä¸ºç®€åŒ–ï¼Œæˆ‘ä»¬æç¤ºç”¨æˆ·ä½¿ç”¨é‡ç½®åŠŸèƒ½
                    updateStepDescription('ä¸Šä¸€æ­¥åŠŸèƒ½éœ€è¦å®Œæ•´çš„çŠ¶æ€å†å²è®°å½•ã€‚è¯·ä½¿ç”¨"é‡ç½®"æŒ‰é’®é‡æ–°å¼€å§‹ã€‚');
                }
            }
            
            // é‡ç½®åŠ¨ç”»
            function resetAnimation() {
                // åœæ­¢ä»»ä½•æ­£åœ¨è¿›è¡Œçš„åŠ¨ç”»
                animationState.isPlaying = false;
                const playPauseBtn = document.getElementById('playPauseBtn');
                playPauseBtn.textContent = 'â–¶ æ’­æ”¾';
                playPauseBtn.classList.remove('btn-danger');
                playPauseBtn.classList.add('btn-primary');
                
                // é‡æ–°åˆå§‹åŒ–æ•°æ®
                initializeData();
            }
            
            // éšæœºç”Ÿæˆæ–°æ•°æ®
            function randomizeData() {
                resetAnimation();
                initializeData();
            }
            
            // æ›´æ–°åŠ¨ç”»é€Ÿåº¦
            function updateSpeed() {
                const speedSlider = document.getElementById('speedSlider');
                // å°†æ»‘å—å€¼ï¼ˆ1-10ï¼‰è½¬æ¢ä¸ºå»¶è¿Ÿæ—¶é—´ï¼ˆ1000ms-100msï¼‰
                animationState.speed = 1100 - (speedSlider.value * 100);
            }
            
            // äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
            document.getElementById('nextStepBtn').addEventListener('click', async () => {
                if (!animationState.isPlaying) {
                    await nextStep();
                }
            });
            document.getElementById('prevStepBtn').addEventListener('click', prevStep);
            document.getElementById('resetBtn').addEventListener('click', resetAnimation);
            document.getElementById('randomizeBtn').addEventListener('click', randomizeData);
            
            // æ’åºæ¨¡å¼åˆ‡æ¢
            const modeRadios = document.getElementsByName('sortMode');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    if (!animationState.isPlaying) {
                        animationState.isMaxHeap = this.value === 'max';
                        resetAnimation();
                    }
                });
            });
            
            // é€Ÿåº¦æ»‘å—
            const speedSlider = document.getElementById('speedSlider');
            speedSlider.addEventListener('input', updateSpeed);
            
            // çª—å£å¤§å°å˜åŒ–æ—¶é‡ç»˜
            window.addEventListener('resize', drawVisualization);
            
            // åˆå§‹åŒ–
            initializeData();
            
            // åˆå§‹ç»˜åˆ¶
            drawVisualization();
        });
    </script>
</body>
</html>