<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>队列数据结构教学动画：排队买饭</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #faf8f0;
            color: #333;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        h1 {
            color: #2196f3;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .subtitle {
            color: #666;
            font-size: 1.1rem;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .queue-container {
            flex: 1;
            min-width: 500px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            display: flex;
            flex-direction: column;
        }
        
        .queue-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .queue-title .badge {
            background-color: #4fc3f7;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .queue-visualization {
            flex-grow: 1;
            position: relative;
            margin: 20px 0;
            min-height: 300px;
        }
        
        canvas {
            display: block;
            margin: 0 auto;
        }
        
        .queue-status {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #4fc3f7;
        }
        
        .status-item {
            display: flex;
            margin-bottom: 8px;
        }
        
        .status-label {
            font-weight: 600;
            min-width: 120px;
        }
        
        .status-value {
            color: #2196f3;
            font-weight: 600;
        }
        
        .status-value.full {
            color: #f44336;
        }
        
        .status-value.empty {
            color: #ff9800;
        }
        
        .controls {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .controls h2 {
            color: #2196f3;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        
        .control-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background-color: #2196f3;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #0b7dda;
            transform: translateY(-2px);
        }
        
        .btn-secondary {
            background-color: #81c784;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #66bb6a;
            transform: translateY(-2px);
        }
        
        .btn-warning {
            background-color: #ff9800;
            color: white;
        }
        
        .btn-warning:hover {
            background-color: #f57c00;
            transform: translateY(-2px);
        }
        
        .btn-reset {
            background-color: #9e9e9e;
            color: white;
        }
        
        .btn-reset:hover {
            background-color: #757575;
            transform: translateY(-2px);
        }
        
        .demo-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .log-container {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
        }
        
        .log-container h2 {
            color: #2196f3;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .log {
            height: 150px;
            overflow-y: auto;
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #e0e0e0;
        }
        
        .log-entry:last-child {
            border-bottom: none;
        }
        
        .log-normal {
            color: #333;
        }
        
        .log-highlight {
            color: #2196f3;
            font-weight: 600;
        }
        
        .log-warning {
            color: #f44336;
            font-weight: 600;
        }
        
        .log-success {
            color: #4caf50;
            font-weight: 600;
        }
        
        .explanation {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            margin-top: 30px;
        }
        
        .explanation h2 {
            color: #2196f3;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .explanation p {
            margin-bottom: 15px;
        }
        
        .key-point {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .legend-text {
            font-size: 0.9rem;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e0e0e0;
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 1100px) {
            .content {
                flex-direction: column;
            }
            
            .queue-container {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>队列数据结构教学动画</h1>
            <p class="subtitle">排队买饭：先进先出，循环队列更精彩</p>
        </header>
        
        <div class="content">
            <div class="queue-container">
                <div class="queue-title">
                    <span>普通队列</span>
                    <span class="badge">线性结构</span>
                </div>
                <div class="queue-visualization">
                    <canvas id="linearCanvas" width="500" height="300"></canvas>
                </div>
                <div class="queue-status">
                    <div class="status-item">
                        <span class="status-label">队列状态:</span>
                        <span id="linearStatus" class="status-value">空</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">队头(Front):</span>
                        <span id="linearFront" class="status-value">-1</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">队尾(Rear):</span>
                        <span id="linearRear" class="status-value">-1</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">队列长度:</span>
                        <span id="linearLength" class="status-value">0</span>
                    </div>
                </div>
            </div>
            
            <div class="queue-container">
                <div class="queue-title">
                    <span>循环队列</span>
                    <span class="badge">环形结构</span>
                </div>
                <div class="queue-visualization">
                    <canvas id="circularCanvas" width="500" height="300"></canvas>
                </div>
                <div class="queue-status">
                    <div class="status-item">
                        <span class="status-label">队列状态:</span>
                        <span id="circularStatus" class="status-value">空</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">队头(Front):</span>
                        <span id="circularFront" class="status-value">-1</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">队尾(Rear):</span>
                        <span id="circularRear" class="status-value">-1</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">队列长度:</span>
                        <span id="circularLength" class="status-value">0</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <h2>队列操作控制</h2>
            <div class="control-buttons">
                <button id="enqueueBtn" class="btn btn-primary">
                    <span>入队(Enqueue)</span>
                </button>
                <button id="dequeueBtn" class="btn btn-secondary">
                    <span>出队(Dequeue)</span>
                </button>
                <button id="resetBtn" class="btn btn-reset">
                    <span>重置(Reset)</span>
                </button>
            </div>
            
            <div class="demo-controls">
                <button id="demoBtn" class="btn btn-warning">
                    <span>演示假溢出问题</span>
                </button>
                <div class="speed-control">
                    <label for="speedSlider">演示速度:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                    <span id="speedValue">中速</span>
                </div>
            </div>
        </div>
        
        <div class="log-container">
            <h2>操作日志</h2>
            <div id="log" class="log">
                <div class="log-entry log-normal">系统就绪。点击"入队"按钮添加顾客，或点击"出队"按钮移除顾客。</div>
                <div class="log-entry log-highlight">提示：观察普通队列的"假溢出"问题，以及循环队列如何解决它。</div>
            </div>
        </div>
        
        <div class="explanation">
            <h2>队列概念说明</h2>
            <p><strong>队列(Queue)</strong>是一种先进先出(FIFO)的数据结构，就像食堂排队买饭：先来的人先买到饭，后来的人排在队尾。</p>
            
            <div class="key-point">
                <p><strong>普通队列的问题：</strong>当队尾指针到达数组末尾，即使数组前面有空位，也无法继续入队，这种现象称为"假溢出"。</p>
            </div>
            
            <div class="key-point">
                <p><strong>循环队列的解决方案：</strong>将数组在逻辑上首尾相连，形成一个环。当队尾指针到达数组末尾时，可以"绕回"到数组开头，从而复用空间。</p>
            </div>
            
            <p>在动画中，您可以观察到：</p>
            <ul>
                <li>普通队列在连续入队和出队后，队尾到达数组末端，即使前面有空位也无法继续入队</li>
                <li>循环队列通过"绕回"机制，可以继续使用前面的空位，解决了假溢出问题</li>
                <li>红色箭头表示队头(Front)，蓝色箭头表示队尾(Rear)</li>
            </ul>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f44336;"></div>
                    <div class="legend-text">队头指针(Front)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2196f3;"></div>
                    <div class="legend-text">队尾指针(Rear)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4fc3f7;"></div>
                    <div class="legend-text">队列中的顾客</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e0e0e0;"></div>
                    <div class="legend-text">空闲位置</div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>数据结构教学动画 | 队列(Queue) | 设计：熊猫老师</p>
        </footer>
    </div>

    <script>
        // 队列配置
        const QUEUE_SIZE = 8;
        const CUSTOMER_COLORS = ['#4fc3f7', '#81c784', '#ffb74d', '#ba68c8', '#4db6ac', '#ff8a65', '#7986cb', '#a1887f'];
        
        // 队列数据结构
        let linearQueue = {
            items: new Array(QUEUE_SIZE).fill(null),
            front: -1,
            rear: -1,
            size: QUEUE_SIZE,
            isFull: function() {
                return this.rear === this.size - 1;
            },
            isEmpty: function() {
                return this.front === -1 || this.front > this.rear;
            },
            enqueue: function(value) {
                if (this.isFull()) {
                    return false;
                }
                
                if (this.front === -1) {
                    this.front = 0;
                }
                
                this.rear++;
                this.items[this.rear] = value;
                return true;
            },
            dequeue: function() {
                if (this.isEmpty()) {
                    return null;
                }
                
                const value = this.items[this.front];
                this.items[this.front] = null;
                
                if (this.front === this.rear) {
                    this.front = -1;
                    this.rear = -1;
                } else {
                    this.front++;
                }
                
                return value;
            },
            length: function() {
                if (this.isEmpty()) return 0;
                return this.rear - this.front + 1;
            }
        };
        
        let circularQueue = {
            items: new Array(QUEUE_SIZE).fill(null),
            front: -1,
            rear: -1,
            size: QUEUE_SIZE,
            isFull: function() {
                return (this.rear + 1) % this.size === this.front;
            },
            isEmpty: function() {
                return this.front === -1;
            },
            enqueue: function(value) {
                if (this.isFull()) {
                    return false;
                }
                
                if (this.isEmpty()) {
                    this.front = 0;
                }
                
                this.rear = (this.rear + 1) % this.size;
                this.items[this.rear] = value;
                return true;
            },
            dequeue: function() {
                if (this.isEmpty()) {
                    return null;
                }
                
                const value = this.items[this.front];
                this.items[this.front] = null;
                
                if (this.front === this.rear) {
                    this.front = -1;
                    this.rear = -1;
                } else {
                    this.front = (this.front + 1) % this.size;
                }
                
                return value;
            },
            length: function() {
                if (this.isEmpty()) return 0;
                if (this.rear >= this.front) {
                    return this.rear - this.front + 1;
                } else {
                    return this.size - this.front + this.rear + 1;
                }
            }
        };
        
        // 顾客ID计数器
        let customerId = 1;
        
        // 获取Canvas元素和上下文
        const linearCanvas = document.getElementById('linearCanvas');
        const circularCanvas = document.getElementById('circularCanvas');
        const linearCtx = linearCanvas.getContext('2d');
        const circularCtx = circularCanvas.getContext('2d');
        
        // 获取状态显示元素
        const linearStatus = document.getElementById('linearStatus');
        const linearFront = document.getElementById('linearFront');
        const linearRear = document.getElementById('linearRear');
        const linearLength = document.getElementById('linearLength');
        
        const circularStatus = document.getElementById('circularStatus');
        const circularFront = document.getElementById('circularFront');
        const circularRear = document.getElementById('circularRear');
        const circularLength = document.getElementById('circularLength');
        
        // 获取按钮元素
        const enqueueBtn = document.getElementById('enqueueBtn');
        const dequeueBtn = document.getElementById('dequeueBtn');
        const resetBtn = document.getElementById('resetBtn');
        const demoBtn = document.getElementById('demoBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        
        // 获取日志元素
        const logElement = document.getElementById('log');
        
        // 动画状态
        let isAnimating = false;
        let demoInterval = null;
        let demoStep = 0;
        const demoSteps = [
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'dequeue', queue: 'both'},
            {action: 'dequeue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'},
            {action: 'enqueue', queue: 'both'}, // 这里普通队列应该会假溢出
            {action: 'enqueue', queue: 'circular'}, // 只有循环队列能继续入队
            {action: 'dequeue', queue: 'both'},
            {action: 'enqueue', queue: 'circular'}, // 循环队列可以继续入队
        ];
        
        // 添加日志
        function addLog(message, type = 'normal') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(logEntry);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // 绘制普通队列
        function drawLinearQueue() {
            linearCtx.clearRect(0, 0, linearCanvas.width, linearCanvas.height);
            
            const cellWidth = 50;
            const cellHeight = 60;
            const startX = 50;
            const startY = 150;
            const spacing = 10;
            
            // 绘制队列标题
            linearCtx.font = '16px Arial';
            linearCtx.fillStyle = '#333';
            linearCtx.fillText('普通队列 (线性结构)', startX, 40);
            
            // 绘制队列单元格
            for (let i = 0; i < QUEUE_SIZE; i++) {
                const x = startX + i * (cellWidth + spacing);
                const y = startY;
                
                // 绘制单元格背景
                linearCtx.fillStyle = linearQueue.items[i] ? CUSTOMER_COLORS[i % CUSTOMER_COLORS.length] : '#e0e0e0';
                linearCtx.fillRect(x, y, cellWidth, cellHeight);
                
                // 绘制单元格边框
                linearCtx.strokeStyle = '#999';
                linearCtx.lineWidth = 2;
                linearCtx.strokeRect(x, y, cellWidth, cellHeight);
                
                // 绘制索引
                linearCtx.font = '12px Arial';
                linearCtx.fillStyle = '#666';
                linearCtx.fillText(`[${i}]`, x + cellWidth/2 - 8, y + cellHeight + 15);
                
                // 绘制顾客
                if (linearQueue.items[i]) {
                    // 绘制顾客图标
                    linearCtx.fillStyle = '#333';
                    linearCtx.beginPath();
                    linearCtx.arc(x + cellWidth/2, y + 20, 10, 0, Math.PI * 2);
                    linearCtx.fill();
                    
                    // 绘制身体
                    linearCtx.fillRect(x + cellWidth/2 - 8, y + 30, 16, 20);
                    
                    // 绘制顾客ID
                    linearCtx.font = 'bold 14px Arial';
                    linearCtx.fillStyle = '#fff';
                    linearCtx.textAlign = 'center';
                    linearCtx.fillText(linearQueue.items[i], x + cellWidth/2, y + 45);
                    linearCtx.textAlign = 'left';
                }
            }
            
            // 绘制队头指针
            if (linearQueue.front !== -1) {
                const frontX = startX + linearQueue.front * (cellWidth + spacing) + cellWidth/2;
                const frontY = startY - 40;
                
                linearCtx.fillStyle = '#f44336';
                linearCtx.beginPath();
                linearCtx.moveTo(frontX, frontY);
                linearCtx.lineTo(frontX - 10, frontY + 20);
                linearCtx.lineTo(frontX + 10, frontY + 20);
                linearCtx.closePath();
                linearCtx.fill();
                
                linearCtx.font = 'bold 14px Arial';
                linearCtx.fillStyle = '#f44336';
                linearCtx.fillText('Front', frontX - 15, frontY - 10);
            }
            
            // 绘制队尾指针
            if (linearQueue.rear !== -1) {
                const rearX = startX + linearQueue.rear * (cellWidth + spacing) + cellWidth/2;
                const rearY = startY + cellHeight + 40;
                
                linearCtx.fillStyle = '#2196f3';
                linearCtx.beginPath();
                linearCtx.moveTo(rearX, rearY);
                linearCtx.lineTo(rearX - 10, rearY - 20);
                linearCtx.lineTo(rearX + 10, rearY - 20);
                linearCtx.closePath();
                linearCtx.fill();
                
                linearCtx.font = 'bold 14px Arial';
                linearCtx.fillStyle = '#2196f3';
                linearCtx.fillText('Rear', rearX - 15, rearY + 25);
            }
            
            // 更新状态显示
            updateLinearStatus();
        }
        
        // 绘制循环队列
        function drawCircularQueue() {
            circularCtx.clearRect(0, 0, circularCanvas.width, circularCanvas.height);
            
            const cellWidth = 50;
            const cellHeight = 60;
            const centerX = circularCanvas.width / 2;
            const centerY = circularCanvas.height / 2;
            const radius = 120;
            
            // 绘制队列标题
            circularCtx.font = '16px Arial';
            circularCtx.fillStyle = '#333';
            circularCtx.fillText('循环队列 (环形结构)', 50, 40);
            
            // 绘制环形连接线
            circularCtx.strokeStyle = '#ccc';
            circularCtx.lineWidth = 2;
            circularCtx.setLineDash([5, 5]);
            circularCtx.beginPath();
            circularCtx.arc(centerX, centerY, radius + 35, 0, Math.PI * 2);
            circularCtx.stroke();
            circularCtx.setLineDash([]);
            
            // 绘制队列单元格
            for (let i = 0; i < QUEUE_SIZE; i++) {
                const angle = (i * 2 * Math.PI) / QUEUE_SIZE - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle) - cellWidth/2;
                const y = centerY + radius * Math.sin(angle) - cellHeight/2;
                
                // 绘制单元格背景
                circularCtx.fillStyle = circularQueue.items[i] ? CUSTOMER_COLORS[i % CUSTOMER_COLORS.length] : '#e0e0e0';
                circularCtx.fillRect(x, y, cellWidth, cellHeight);
                
                // 绘制单元格边框
                circularCtx.strokeStyle = '#999';
                circularCtx.lineWidth = 2;
                circularCtx.strokeRect(x, y, cellWidth, cellHeight);
                
                // 绘制索引
                circularCtx.font = '12px Arial';
                circularCtx.fillStyle = '#666';
                const textX = centerX + (radius + 25) * Math.cos(angle);
                const textY = centerY + (radius + 25) * Math.sin(angle);
                circularCtx.textAlign = 'center';
                circularCtx.fillText(`[${i}]`, textX, textY);
                circularCtx.textAlign = 'left';
                
                // 绘制顾客
                if (circularQueue.items[i]) {
                    // 绘制顾客图标
                    circularCtx.fillStyle = '#333';
                    circularCtx.beginPath();
                    circularCtx.arc(x + cellWidth/2, y + 20, 10, 0, Math.PI * 2);
                    circularCtx.fill();
                    
                    // 绘制身体
                    circularCtx.fillRect(x + cellWidth/2 - 8, y + 30, 16, 20);
                    
                    // 绘制顾客ID
                    circularCtx.font = 'bold 14px Arial';
                    circularCtx.fillStyle = '#fff';
                    circularCtx.textAlign = 'center';
                    circularCtx.fillText(circularQueue.items[i], x + cellWidth/2, y + 45);
                    circularCtx.textAlign = 'left';
                }
            }
            
            // 绘制队头指针
            if (circularQueue.front !== -1) {
                const frontAngle = (circularQueue.front * 2 * Math.PI) / QUEUE_SIZE - Math.PI / 2;
                const frontX = centerX + (radius + 60) * Math.cos(frontAngle);
                const frontY = centerY + (radius + 60) * Math.sin(frontAngle);
                
                circularCtx.fillStyle = '#f44336';
                circularCtx.beginPath();
                circularCtx.arc(frontX, frontY, 8, 0, Math.PI * 2);
                circularCtx.fill();
                
                circularCtx.font = 'bold 14px Arial';
                circularCtx.fillStyle = '#f44336';
                circularCtx.textAlign = 'center';
                circularCtx.fillText('F', frontX, frontY + 4);
                circularCtx.textAlign = 'left';
            }
            
            // 绘制队尾指针
            if (circularQueue.rear !== -1) {
                const rearAngle = (circularQueue.rear * 2 * Math.PI) / QUEUE_SIZE - Math.PI / 2;
                const rearX = centerX + (radius + 60) * Math.cos(rearAngle);
                const rearY = centerY + (radius + 60) * Math.sin(rearAngle);
                
                circularCtx.fillStyle = '#2196f3';
                circularCtx.beginPath();
                circularCtx.arc(rearX, rearY, 8, 0, Math.PI * 2);
                circularCtx.fill();
                
                circularCtx.font = 'bold 14px Arial';
                circularCtx.fillStyle = '#2196f3';
                circularCtx.textAlign = 'center';
                circularCtx.fillText('R', rearX, rearY + 4);
                circularCtx.textAlign = 'left';
            }
            
            // 更新状态显示
            updateCircularStatus();
        }
        
        // 更新普通队列状态显示
        function updateLinearStatus() {
            if (linearQueue.isEmpty()) {
                linearStatus.textContent = '空';
                linearStatus.className = 'status-value empty';
            } else if (linearQueue.isFull()) {
                linearStatus.textContent = '满';
                linearStatus.className = 'status-value full';
            } else {
                linearStatus.textContent = '正常';
                linearStatus.className = 'status-value';
            }
            
            linearFront.textContent = linearQueue.front;
            linearRear.textContent = linearQueue.rear;
            linearLength.textContent = linearQueue.length();
        }
        
        // 更新循环队列状态显示
        function updateCircularStatus() {
            if (circularQueue.isEmpty()) {
                circularStatus.textContent = '空';
                circularStatus.className = 'status-value empty';
            } else if (circularQueue.isFull()) {
                circularStatus.textContent = '满';
                circularStatus.className = 'status-value full';
            } else {
                circularStatus.textContent = '正常';
                circularStatus.className = 'status-value';
            }
            
            circularFront.textContent = circularQueue.front;
            circularRear.textContent = circularQueue.rear;
            circularLength.textContent = circularQueue.length();
        }
        
        // 入队操作
        function enqueue() {
            if (isAnimating) return;
            
            const customer = `C${customerId++}`;
            let linearSuccess = false;
            let circularSuccess = false;
            
            // 尝试向普通队列添加
            if (!linearQueue.isFull()) {
                linearSuccess = linearQueue.enqueue(customer);
                if (linearSuccess) {
                    addLog(`顾客 ${customer} 加入普通队列`, 'highlight');
                }
            } else {
                addLog('普通队列已满，无法入队！', 'warning');
            }
            
            // 尝试向循环队列添加
            if (!circularQueue.isFull()) {
                circularSuccess = circularQueue.enqueue(customer);
                if (circularSuccess) {
                    addLog(`顾客 ${customer} 加入循环队列`, 'highlight');
                }
            } else {
                addLog('循环队列已满，无法入队！', 'warning');
            }
            
            // 如果两个队列都满了，显示特殊提示
            if (linearQueue.isFull() && circularQueue.isFull()) {
                addLog('两个队列都已满！', 'warning');
            }
            
            // 重绘队列
            drawLinearQueue();
            drawCircularQueue();
            
            return linearSuccess || circularSuccess;
        }
        
        // 出队操作
        function dequeue() {
            if (isAnimating) return;
            
            let linearCustomer = null;
            let circularCustomer = null;
            
            // 从普通队列移除
            if (!linearQueue.isEmpty()) {
                linearCustomer = linearQueue.dequeue();
                if (linearCustomer) {
                    addLog(`顾客 ${linearCustomer} 从普通队列离开`, 'success');
                }
            } else {
                addLog('普通队列为空，无法出队！', 'warning');
            }
            
            // 从循环队列移除
            if (!circularQueue.isEmpty()) {
                circularCustomer = circularQueue.dequeue();
                if (circularCustomer) {
                    addLog(`顾客 ${circularCustomer} 从循环队列离开`, 'success');
                }
            } else {
                addLog('循环队列为空，无法出队！', 'warning');
            }
            
            // 重绘队列
            drawLinearQueue();
            drawCircularQueue();
            
            return linearCustomer || circularCustomer;
        }
        
        // 重置队列
        function resetQueues() {
            if (isAnimating) {
                stopDemo();
            }
            
            linearQueue.items.fill(null);
            linearQueue.front = -1;
            linearQueue.rear = -1;
            
            circularQueue.items.fill(null);
            circularQueue.front = -1;
            circularQueue.rear = -1;
            
            customerId = 1;
            
            addLog('队列已重置', 'normal');
            
            drawLinearQueue();
            drawCircularQueue();
        }
        
        // 开始演示
        function startDemo() {
            if (isAnimating) {
                stopDemo();
                return;
            }
            
            isAnimating = true;
            demoStep = 0;
            demoBtn.textContent = '停止演示';
            
            addLog('开始演示假溢出问题...', 'highlight');
            
            const speed = parseInt(speedSlider.value);
            const delay = 1100 - (speed * 100); // 速度越快，延迟越短
            
            demoInterval = setInterval(() => {
                if (demoStep >= demoSteps.length) {
                    stopDemo();
                    addLog('演示结束。观察到了吗？普通队列发生了假溢出，而循环队列可以继续工作！', 'highlight');
                    return;
                }
                
                const step = demoSteps[demoStep];
                
                if (step.action === 'enqueue') {
                    if (step.queue === 'both') {
                        enqueue();
                    } else if (step.queue === 'circular') {
                        // 只向循环队列添加
                        const customer = `C${customerId++}`;
                        if (!circularQueue.isFull()) {
                            circularQueue.enqueue(customer);
                            addLog(`顾客 ${customer} 加入循环队列（普通队列已满）`, 'highlight');
                            drawCircularQueue();
                        }
                    }
                } else if (step.action === 'dequeue') {
                    dequeue();
                }
                
                demoStep++;
            }, delay);
        }
        
        // 停止演示
        function stopDemo() {
            if (demoInterval) {
                clearInterval(demoInterval);
                demoInterval = null;
            }
            
            isAnimating = false;
            demoBtn.textContent = '演示假溢出问题';
        }
        
        // 更新速度显示
        function updateSpeedDisplay() {
            const speed = parseInt(speedSlider.value);
            const speedText = ['极慢', '很慢', '慢', '较慢', '中速', '较快', '快', '很快', '极快', '最快'];
            speedValue.textContent = speedText[speed - 1] || '中速';
        }
        
        // 初始化
        function init() {
            // 绘制初始队列
            drawLinearQueue();
            drawCircularQueue();
            
            // 添加事件监听器
            enqueueBtn.addEventListener('click', en
<!--检测到代码截断，自动续写中...-->
queue);
            dequeueBtn.addEventListener('click', dequeue);
            resetBtn.addEventListener('click', resetQueues);
            demoBtn.addEventListener('click', startDemo);
            speedSlider.addEventListener('input', updateSpeedDisplay);
            
            // 初始速度显示
            updateSpeedDisplay();
            
            // 初始日志
            addLog('教学动画已初始化。点击"入队"添加顾客，点击"出队"移除顾客。', 'normal');
            addLog('点击"演示假溢出问题"按钮观看自动演示。', 'highlight');
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
        
        // 添加键盘快捷键支持
        document.addEventListener('keydown', (e) => {
            if (isAnimating) return;
            
            switch(e.key) {
                case 'e':
                case 'E':
                    enqueue();
                    break;
                case 'd':
                case 'D':
                    dequeue();
                    break;
                case 'r':
                case 'R':
                    resetQueues();
                    break;
                case ' ':
                    startDemo();
                    break;
            }
        });
        
        // 添加触摸设备支持
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        
        document.addEventListener('touchstart', (e) => {
            touchStartTime = Date.now();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });
        
        document.addEventListener('touchend', (e) => {
            if (isAnimating) return;
            
            const touchEndTime = Date.now();
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const duration = touchEndTime - touchStartTime;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // 短时间点击视为点击操作
            if (duration < 300 && Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
                // 检查点击位置
                const target = e.target;
                
                if (target === enqueueBtn || target.closest('#enqueueBtn')) {
                    enqueue();
                } else if (target === dequeueBtn || target.closest('#dequeueBtn')) {
                    dequeue();
                } else if (target === resetBtn || target.closest('#resetBtn')) {
                    resetQueues();
                } else if (target === demoBtn || target.closest('#demoBtn')) {
                    startDemo();
                }
            }
        });
        
        // 添加Canvas点击交互
        linearCanvas.addEventListener('click', () => {
            if (!isAnimating) {
                addLog('点击了普通队列区域。提示：观察队尾指针到达数组末端后的假溢出问题。', 'normal');
            }
        });
        
        circularCanvas.addEventListener('click', () => {
            if (!isAnimating) {
                addLog('点击了循环队列区域。提示：观察队尾指针如何"绕回"到数组开头复用空间。', 'normal');
            }
        });
        
        // 添加窗口大小调整响应
        window.addEventListener('resize', () => {
            // 重新绘制队列以适应可能的布局变化
            drawLinearQueue();
            drawCircularQueue();
        });
        
        // 添加帮助提示
        setTimeout(() => {
            if (linearQueue.isEmpty() && circularQueue.isEmpty()) {
                addLog('提示：您可以使用键盘快捷键 - E:入队, D:出队, R:重置, 空格:演示', 'highlight');
            }
        }, 3000);
    </script>
</body>
</html>