<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>链表反转算法可视化 - 三种方法</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4a90e2;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }

        .container {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
        }

        .visualization-section {
            flex: 3;
            min-width: 300px;
        }

        .code-section {
            flex: 2;
            min-width: 300px;
        }

        .panel {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            margin-bottom: 20px;
        }

        h2 {
            color: #4a90e2;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        /* 方法选择器 */
        .method-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .method-btn {
            padding: 12px 24px;
            background-color: #eef2f7;
            border: 2px solid #d1d9e6;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #5a6c7d;
            transition: all 0.3s ease;
            flex: 1;
            text-align: center;
            min-width: 120px;
        }

        .method-btn:hover {
            background-color: #e1e8f0;
        }

        .method-btn.active {
            background-color: #4a90e2;
            color: white;
            border-color: #4a90e2;
        }

        /* 控制面板 */
        .control-panel {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
        }

        .control-btn {
            padding: 10px 20px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-btn:hover {
            background-color: #3a7bc8;
        }

        .control-btn:disabled {
            background-color: #a0b9d9;
            cursor: not-allowed;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .speed-slider {
            width: 150px;
        }

        /* 画布区域 */
        .canvas-container {
            position: relative;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #e1e8f0;
            height: 400px;
            margin-bottom: 20px;
        }

        #animationCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* 递归栈区域 */
        .recursion-stack-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 1px dashed #d1d9e6;
            height: 150px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .stack-frame {
            background-color: white;
            border-left: 4px solid #9933cc;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            font-family: monospace;
        }

        .stack-frame.active {
            background-color: #f3e6ff;
            font-weight: bold;
        }

        /* 代码区域 */
        .code-container {
            background-color: #2c3e50;
            color: #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            height: 400px;
        }

        .code-line {
            padding: 2px 0;
            white-space: pre;
        }

        .code-line.highlighted {
            background-color: rgba(255, 250, 205, 0.3);
            color: #ffd700;
        }

        /* 变量状态表 */
        .variables-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .variables-table th, .variables-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e1e8f0;
        }

        .variables-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #4a90e2;
        }

        .variables-table tr:hover {
            background-color: #f8f9fa;
        }

        .pointer-value {
            font-weight: bold;
            font-family: monospace;
        }

        .pointer-prev { color: #3366cc; }
        .pointer-curr { color: #cc3333; }
        .pointer-next { color: #33cc66; }
        .pointer-newhead { color: #9933cc; }

        /* 步骤说明 */
        .step-description {
            background-color: #f0f7ff;
            border-left: 4px solid #4a90e2;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-size: 1.05em;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #e1e8f0;
            color: #7f8c8d;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .control-panel {
                justify-content: center;
            }
            
            .speed-control {
                margin-left: 0;
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>链表反转算法可视化</h1>
        <p class="subtitle">三种方法：迭代法、递归法、头插法</p>
    </header>

    <div class="container">
        <div class="panel">
            <h2>算法方法选择</h2>
            <div class="method-selector">
                <button class="method-btn active" data-method="iterative">迭代法（三指针）</button>
                <button class="method-btn" data-method="recursive">递归法</button>
                <button class="method-btn" data-method="headInsert">头插法</button>
            </div>

            <div class="control-panel">
                <button id="resetBtn" class="control-btn">
                    <span>↺</span> 重置
                </button>
                <button id="prevBtn" class="control-btn" disabled>
                    <span>←</span> 上一步
                </button>
                <button id="playPauseBtn" class="control-btn">
                    <span>▶</span> 播放
                </button>
                <button id="nextBtn" class="control-btn">
                    <span>→</span> 下一步
                </button>
                
                <div class="speed-control">
                    <span>速度:</span>
                    <input type="range" id="speedSlider" class="speed-slider" min="1" max="10" value="5">
                    <span id="speedValue">中</span>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="animationCanvas"></canvas>
            </div>

            <div id="recursionStackContainer" class="recursion-stack-container" style="display: none;">
                <h3>递归调用栈</h3>
                <div id="stackFrames"></div>
            </div>

            <div class="step-description" id="stepDescription">
                点击"播放"或"下一步"开始动画演示。初始链表: 1 → 2 → 3 → 4 → 5
            </div>
        </div>

        <div class="main-content">
            <div class="visualization-section">
                <div class="panel">
                    <h2>变量状态</h2>
                    <table class="variables-table">
                        <thead>
                            <tr>
                                <th>指针变量</th>
                                <th>指向节点值</th>
                                <th>说明</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><span class="pointer-prev pointer-value">prev</span></td>
                                <td id="prevValue">null</td>
                                <td>前一个节点</td>
                            </tr>
                            <tr>
                                <td><span class="pointer-curr pointer-value">curr</span></td>
                                <td id="currValue">1</td>
                                <td>当前节点</td>
                            </tr>
                            <tr>
                                <td><span class="pointer-next pointer-value">next</span></td>
                                <td id="nextValue">2</td>
                                <td>下一个节点（临时）</td>
                            </tr>
                            <tr id="newHeadRow" style="display: none;">
                                <td><span class="pointer-newhead pointer-value">newHead</span></td>
                                <td id="newHeadValue">null</td>
                                <td>新链表头</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="panel">
                    <h2>图例说明</h2>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4a90e2;"></div>
                            <span>链表节点（默认）</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ffd700;"></div>
                            <span>当前节点 (curr)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #98fb98;"></div>
                            <span>已处理节点</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #3366cc;"></div>
                            <span>prev 指针</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #cc3333;"></div>
                            <span>curr 指针</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #33cc66;"></div>
                            <span>next 指针</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #9933cc;"></div>
                            <span>newHead 指针（头插法）</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="code-section">
                <div class="panel">
                    <h2>算法代码</h2>
                    <div class="code-container" id="codeContainer">
                        <!-- 代码将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>链表反转算法可视化 | 使用HTML5 Canvas实现 | 设计用于教学演示</p>
    </footer>

    <script>
        // 全局变量和配置
        const CONFIG = {
            NODE_RADIUS: 28,
            NODE_SPACING: 120,
            VERTICAL_SPACING: 100,
            ANIMATION_DURATION: 800,
            COLORS: {
                NODE_DEFAULT: '#4a90e2',
                NODE_CURRENT: '#ffd700',
                NODE_PROCESSED: '#98fb98',
                POINTER_PREV: '#3366cc',
                POINTER_CURR: '#cc3333',
                POINTER_NEXT: '#33cc66',
                POINTER_NEWHEAD: '#9933cc',
                LINK_DEFAULT: '#333',
                BACKGROUND: '#f5f7fa',
                CODE_HIGHLIGHT: 'rgba(255, 250, 205, 0.3)'
            }
        };

        // 算法步骤定义
        const ALGORITHMS = {
            iterative: {
                name: '迭代法（三指针）',
                steps: [
                    { 
                        desc: '初始化: prev = null, curr = head, next = null',
                        codeLine: 0,
                        action: 'init'
                    },
                    { 
                        desc: '循环开始: 当 curr ≠ null 时',
                        codeLine: 1,
                        action: 'loop_start'
                    },
                    { 
                        desc: '保存下一个节点: next = curr.next',
                        codeLine: 2,
                        action: 'save_next'
                    },
                    { 
                        desc: '反转指针: curr.next = prev',
                        codeLine: 3,
                        action: 'reverse_link'
                    },
                    { 
                        desc: '移动指针: prev = curr, curr = next',
                        codeLine: 4,
                        action: 'move_pointers'
                    },
                    { 
                        desc: '循环结束，返回 prev 作为新头节点',
                        codeLine: 5,
                        action: 'return'
                    }
                ],
                code: [
                    'function reverseIterative(head) {',
                    '  let prev = null;',
                    '  let curr = head;',
                    '  let next = null;',
                    '  ',
                    '  while (curr !== null) {',
                    '    next = curr.next;    // 保存下一个节点',
                    '    curr.next = prev;    // 反转指针',
                    '    prev = curr;         // prev前进',
                    '    curr = next;         // curr前进',
                    '  }',
                    '  ',
                    '  return prev; // 新头节点',
                    '}'
                ]
            },
            recursive: {
                name: '递归法',
                steps: [
                    { 
                        desc: '递归基: 如果 head 为空或 head.next 为空，返回 head',
                        codeLine: 0,
                        action: 'base_case_check'
                    },
                    { 
                        desc: '递归调用: newHead = reverseRecursive(head.next)',
                        codeLine: 1,
                        action: 'recursive_call'
                    },
                    { 
                        desc: '反转指针: head.next.next = head',
                        codeLine: 2,
                        action: 'reverse_link'
                    },
                    { 
                        desc: '断开原链接: head.next = null',
                        codeLine: 3,
                        action: 'break_link'
                    },
                    { 
                        desc: '返回新头节点: return newHead',
                        codeLine: 4,
                        action: 'return_newhead'
                    }
                ],
                code: [
                    'function reverseRecursive(head) {',
                    '  // 递归基',
                    '  if (head === null || head.next === null) {',
                    '    return head;',
                    '  }',
                    '  ',
                    '  // 递归调用，直到链表末尾',
                    '  let newHead = reverseRecursive(head.next);',
                    '  ',
                    '  // 反转指针',
                    '  head.next.next = head;',
                    '  ',
                    '  // 断开原链接',
                    '  head.next = null;',
                    '  ',
                    '  // 返回新头节点',
                    '  return newHead;',
                    '}'
                ]
            },
            headInsert: {
                name: '头插法',
                steps: [
                    { 
                        desc: '初始化: newHead = null, curr = head',
                        codeLine: 0,
                        action: 'init'
                    },
                    { 
                        desc: '循环开始: 当 curr ≠ null 时',
                        codeLine: 1,
                        action: 'loop_start'
                    },
                    { 
                        desc: '保存下一个节点: next = curr.next',
                        codeLine: 2,
                        action: 'save_next'
                    },
                    { 
                        desc: '头插操作: curr.next = newHead',
                        codeLine: 3,
                        action: 'insert_at_head'
                    },
                    { 
                        desc: '更新新头: newHead = curr',
                        codeLine: 4,
                        action: 'update_newhead'
                    },
                    { 
                        desc: '移动指针: curr = next',
                        codeLine: 5,
                        action: 'move_curr'
                    },
                    { 
                        desc: '循环结束，返回 newHead',
                        codeLine: 6,
                        action: 'return'
                    }
                ],
                code: [
                    'function reverseHeadInsert(head) {',
                    '  let newHead = null;',
                    '  let curr = head;',
                    '  let next = null;',
                    '  ',
                    '  while (curr !== null) {',
                    '    next = curr.next;      // 保存下一个节点',
                    '    curr.next = newHead;   // 头插操作',
                    '    newHead = curr;        // 更新新头',
                    '    curr = next;           // 移动到下一个节点',
                    '  }',
                    '  ',
                    '  return newHead;',
                    '}'
                ]
            }
        };

        // 链表节点类
        class ListNode {
            constructor(value, x, y) {
                this.value = value;
                this.x = x;
                this.y = y;
                this.next = null;
                this.color = CONFIG.COLORS.NODE_DEFAULT;
                this.processed = false;
                this.isCurrent = false;
            }

            draw(ctx) {
                // 绘制节点
                ctx.beginPath();
                ctx.arc(this.x, this.y, CONFIG.NODE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 2;
                ctx.stroke();

                // 绘制节点值
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.value.toString(), this.x, this.y);

                // 绘制next指针标签
                ctx.fillStyle = '#7f8c8d';
                ctx.font = '12px Arial';
                ctx.fillText('next', this.x, this.y + CONFIG.NODE_RADIUS + 15);
            }

            drawLink(ctx, targetNode) {
                if (!targetNode) return;

                // 计算箭头起点和终点
                const dx = targetNode.x - this.x;
                const dy = targetNode.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / distance;
                const unitY = dy / distance;

                const startX = this.x + unitX * CONFIG.NODE_RADIUS;
                const startY = this.y + unitY * CONFIG.NODE_RADIUS;
                const endX = targetNode.x - unitX * CONFIG.NODE_RADIUS;
                const endY = targetNode.y - unitY * CONFIG.NODE_RADIUS;

                // 绘制连线
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = CONFIG.COLORS.LINK_DEFAULT;
                ctx.lineWidth = 2;
                ctx.stroke();

                // 绘制箭头
                const arrowSize = 8;
                const angle = Math.atan2(dy, dx);
                
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fillStyle = CONFIG.COLORS.LINK_DEFAULT;
                ctx.fill();
            }
        }

        // 指针指示器类
        class PointerIndicator {
            constructor(name, color, label) {
                this.name = name;
                this.color = color;
                this.label = label;
                this.targetNode = null;
                this.x = 0;
                this.y = 0;
            }

            updatePosition(targetNode, offsetX = 0, offsetY = 0) {
                this.targetNode = targetNode;
                if (targetNode) {
                    this.x = targetNode.x + offsetX;
                    this.y = targetNode.y + offsetY;
                }
            }

            draw(ctx) {
                if (!this.targetNode) return;

                // 绘制指针线
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.targetNode.x, this.targetNode.y);
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 3]);
                ctx.stroke();
                ctx.setLineDash([]);

                // 绘制指针标签
                ctx.fillStyle = this.color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(this.label, this.x, this.y - 10);

                // 绘制指针点
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // 主应用类
        class LinkedListAnimation {
            constructor() {
                this.canvas = document.getElementById('animationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.method = 'iterative';
                this.currentStep = 0;
                this.isPlaying = false;
                this.animationSpeed = 5;
                this.animationStartTime = 0;
                this.nodes = [];
                this.pointers = {
                    prev: new PointerIndicator('prev', CONFIG.COLORS.POINTER_PREV, 'prev'),
                    curr: new PointerIndicator('curr', CONFIG.COLORS.POINTER_CURR, 'curr'),
                    next: new PointerIndicator('next', CONFIG.COLORS.POINTER_NEXT, 'next'),
                    newHead: new PointerIndicator('newHead', CONFIG.COLORS.POINTER_NEWHEAD, 'newHead')
                };
                this.recursionStack = [];
                this.originalList = [];
                this.init();
            }

            init() {
                this.setupCanvas();
                this.createLinkedList();
                this.setupEventListeners();
                this.renderCode();
                this.updateVariableDisplay();
                this.draw();
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = container.clientWidth;
                    this.canvas.height = container.clientHeight;
                    this.createLinkedList(); // 重新计算节点位置
                    this.draw();
                });
            }

            createLinkedList() {
                this.nodes = [];
                this.originalList = [];
                
                const values = [1, 2, 3, 4, 5];
                const startX = 100;
                const startY = this.canvas.height / 2;
                
                // 创建节点并设置位置
                for (let i = 0; i < values.length; i++) {
                    const node = new ListNode(
                        values[i],
                        startX + i * CONFIG.NODE_SPACING,
                        startY
                    );
                    this.nodes.push(node);
                    this.originalList.push({...node});
                }
                
                // 设置next指针
                for (let i = 0; i < this.nodes.length - 1; i++) {
                    this.nodes[i].next = this.nodes[i + 1];
                }
                
                // 初始化指针位置
                this.pointers.curr.updatePosition(this.nodes[0], -60, -80);
                this.pointers.next.updatePosition(this.nodes[1] || null, -60, -80);
                this.pointers.prev.updatePosition(null, -60, -80);
                this.pointers.newHead.updatePosition(null, -60, -80);
                
                // 重置节点状态
                this.nodes.forEach(node => {
                    node.color = CONFIG.COLORS.NODE_DEFAULT;
                    node.processed = false;
                    node.isCurrent = false;
                });
                
                // 设置第一个节点为当前节点
                if (this.nodes[0]) {
                    this.nodes[0].isCurrent = true;
                    this.nodes[0].color = CONFIG.COLORS.NODE_CURRENT;
                }
                
                this.currentStep = 0;
                this.recursionStack = [];
                this.updateRecursionStackDisplay();
            }

            setupEventListeners() {
                // 方法选择按钮
                document.querySelectorAll('.method-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.method = btn.dataset.method;
                        this.resetAnimation();
                        this.renderCode();
                        this.updateVariableDisplay();
                        
                        // 显示/隐藏递归栈区域
                        const stackContainer = document.getElementById('recursionStackContainer');
                        stackContainer.style.display = this.method === 'recursive' ? 'block' : 'none';
                        
                        // 显示/隐藏newHead行
                        const newHeadRow = document.getElementById('newHeadRow');
                        newHeadRow.style.display = this.method === 'headInsert' ? 'table-row' : 'none';
                    });
                });

                // 控制按钮
                document.getElementById('resetBtn').addEventListener('click', () => this.resetAnimation());
                document.getElementById('prevBtn').addEventListener('click', () => this.prevStep());
                document.getElementById('nextBtn').addEventListener('click', () => this.nextStep());
                document.getElementById('playPauseBtn').addEventListener('click', () => this.togglePlay());

                // 速度滑块
                const speedSlider = document.getElementById('speedSlider');
                const speedValue = document.getElementById('speedValue');
                
                speedSlider.addEventListener('input', () => {
                    this.animationSpeed = parseInt(speedSlider.value);
                    const speedLabels = ['很慢', '慢', '较慢', '中慢', '中', '中快', '较快', '快', '很快', '极快'];
                    speedValue.textContent = speedLabels[this.animationSpeed - 1];
                });
            }

            renderCode() {
                const codeContainer = document.getElementById('codeContainer');
                const algorithm = ALGORITHMS[this.method];
                
                codeContainer.innerHTML = '';
                algorithm.code.forEach((line, index) => {
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'code-line';
                    lineDiv.textContent = line;
                    lineDiv.dataset.line = index;
                    codeContainer.appendChild(lineDiv);
                });
                
                this.highlightCodeLine(0);
            }

            highlightCodeLine(lineNumber) {
                document.querySelectorAll('.code-line').forEach(line => {
                    line.classList.remove('highlighted');
                });
                
                const targetLine = document.querySelector(`.code-line[data-line="${lineNumber}"]`);
                if (targetLine) {
                    targetLine.classList.add('highlighted');
                    targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            updateVariableDisplay() {
                const prevNode = this.pointers.prev.targetNode;
                const currNode = this.pointers.curr.targetNode;
                const nextNode = this.pointers.next.targetNode;
                const newHeadNode = this.pointers.newHead.targetNode;
                
                document.getElementById('prevValue').textContent = prevNode ? prevNode.value : 'null';
                document.getElementById('currValue').textContent = currNode ? currNode.value : 'null';
                document.getElementById('nextValue').textContent = nextNode ? nextNode.value : 'null';
                document.getElementById('newHeadValue').textContent = newHeadNode ? newHeadNode.value : 'null';
            }

            updateRecursionStackDisplay() {
                const stackFrames = document.getElementById('stackFrames');
                stackFrames.innerHTML = '';
                
                this.recursionStack.forEach((frame, index) => {
                    const frameDiv = document.createElement('div');
                    frameDiv.className = `stack-frame ${index === this.recursionStack.length - 1 ? 'active' : ''}`;
                    frameDiv.textContent = `reverseRecursive(node=${frame.node ? frame.node.value : 'null'}) - 深度: ${frame.depth}`;
                    stackFrames.appendChild(frameDiv);
                });
                
                // 滚动到底部
                stackFrames.scrollTop = stackFrames.scrollHeight;
            }

            updateStepDescription() {
                const algorithm = ALGORITHMS[this.method];
                const step = algorithm.steps[this.currentStep];
                const descElement = document.getElementById('stepDescription');
                
                if (step) {
                    descElement.textContent = `步骤 ${this.currentStep + 1}/${algorithm.steps.length}: ${step.desc}`;
                    this.highlightCodeLine(step.codeLine);
                }
            }

            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制所有连线
                this.nodes.forEach(node => {
                    if (node.next) {
                        node.drawLink(this.ctx, node.next);
                    }
                });
                
                // 绘制所有节点
                this.nodes.forEach(node => {
                    node.draw(this.ctx);
                });
                
                // 绘制所有指针
                Object.values(this.pointers).forEach(pointer => {
                    pointer.draw(this.ctx);
                });
            }

            resetAnimation() {
                this.isPlaying = false;
                this.currentStep = 0;
                this.createLinkedList();
                this.updateVariableDisplay();
                this.updateStepDescription();
                this.updateRecursionStackDisplay();
                
                const playBtn = document.getElementById('playPauseBtn');
                playBtn.innerHTML = '<span>▶</span> 播放';
                document.getElementById('prevBtn').disabled = true;
                
                this.draw();
            }

            prevStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.executeStep(false); // 反向执行
                    this.updateStepDescription();
                    document.getElementById('nextBtn').disabled = false;
                }
                
                document.getElementById('prevBtn').disabled = this.currentStep === 0;
            }

            nextStep() {
                const algorithm = ALGORITHMS[this.method];
                
                if (this.currentStep < algorithm.steps.length) {
                    this.executeStep(true); // 正向执行
                    this.currentStep++;
                    this.updateStepDescription();
                    document.getElementById('prevBtn').disabled = false;
                }
                
                if (this.currentStep >= algorithm.steps.length) {
                    document.getElementById('nextBtn').disabled = true;
                    this.isPlaying = false;
                    const playBtn = document.getElementById('playPauseBtn');
                    playBtn.innerHTML = '<span>▶</span> 播放';
                }
            }

            executeStep(forward = true) {
                const algorithm = ALGORITHMS[this.method];
                const step = algorithm.steps[forward ? this.currentStep : this.currentStep - 1];
                
                if (!step) return;
                
                switch (this.method) {
                    case 'iterative':
                        this.executeIterativeStep(step.action, forward);
                        break;
                    case 'recursive':
                        this.executeRecursiveStep(step.action, forward);
                        break;
                    case 'headInsert':
                        this.executeHeadInsertStep(step.action, forward);
                        break;
                }
                
                this.updateVariableDisplay();
                this.draw();
            }

            executeIterativeStep(action, forward) {
                const currNode = this.pointers.curr.targetNode;
                const prevNode = this.pointers.prev.targetNode;
                const nextNode = this.pointers.next.targetNode;
                
                if (!forward) {
                    // 反向执行（撤销操作）
                    switch (action) {
                        case 'move_pointers':
                            this.pointers.curr.updatePosition(prevNode, -60, -80);
                            this.pointers.prev.updatePosition(this.findPrevNode(prevNode), -60, -80);
                            if (currNode) {
                                currNode.next = nextNode;
                                currNode.color = CONFIG.COLORS.NODE_CURRENT;
                                currNode.isCurrent = true;
                            }
                            if (prevNode) {
                                prevNode.color = CONFIG.COLORS.NODE_PROCESSED;
                                prevNode.isCurrent = false;
                            }
                            break;
                        case 'reverse_link':
                            if (currNode) {
                                currNode.next = nextNode;
                            }
                            break;
                        case 'save_next':
                            this.pointers.next.updatePosition(currNode ? currNode.next : null, -60, -80);
                            break;
                        case 'init':
                            this.pointers.prev.updatePosition(null, -60, -80);
                            this.pointers.curr.updatePosition(this.nodes[0], -60, -80);
                            this.pointers.next.updatePosition(this.nodes[1] || null, -60, -80);
                            this.nodes.forEach(node => {
                                node.color = CONFIG.COLORS.NODE_DEFAULT;
                                node.processed = false;
                                node.isCurrent = false;
                            });
                            if (this.nodes[0]) {
                                this.nodes[0].isCurrent = true;
                                this.nodes[0].color = CONFIG.COLORS.NODE_CURRENT;
                            }
                            break;
                    }
                    return;
                }
                
                // 正向执行
                switch (action) {
                    case 'init':
                        this.pointers.prev.updatePosition(null, -60, -80);
                        this.pointers.curr.updatePosition(this.nodes[0], -60, -80);
                        this.pointers.next.updatePosition(this.nodes[1] || null, -60, -80);
                        break;
                        
                    case 'save_next':
                        if (currNode) {
                            this.pointers.next.updatePosition(currNode.next, -60, -80);
                        }
                        break
<!--检测到代码截断，自动续写中...-->
                    case 'reverse_link':
                        if (currNode) {
                            currNode.next = prevNode;
                        }
                        break;
                        
                    case 'move_pointers':
                        if (currNode) {
                            currNode.color = CONFIG.COLORS.NODE_PROCESSED;
                            currNode.processed = true;
                            currNode.isCurrent = false;
                        }
                        
                        this.pointers.prev.updatePosition(currNode, -60, -80);
                        this.pointers.curr.updatePosition(nextNode, -60, -80);
                        
                        if (nextNode) {
                            nextNode.color = CONFIG.COLORS.NODE_CURRENT;
                            nextNode.isCurrent = true;
                            this.pointers.next.updatePosition(nextNode.next, -60, -80);
                        } else {
                            this.pointers.next.updatePosition(null, -60, -80);
                        }
                        break;
                }
            }

            executeRecursiveStep(action, forward) {
                const currNode = this.pointers.curr.targetNode;
                
                if (!forward) {
                    // 反向执行（撤销操作）
                    switch (action) {
                        case 'return_newhead':
                            // 从栈中弹出
                            if (this.recursionStack.length > 0) {
                                const frame = this.recursionStack.pop();
                                this.pointers.curr.updatePosition(frame.node, -60, -80);
                                if (frame.node) {
                                    frame.node.color = CONFIG.COLORS.NODE_CURRENT;
                                    frame.node.isCurrent = true;
                                }
                                this.updateRecursionStackDisplay();
                            }
                            break;
                        case 'break_link':
                            if (currNode && currNode.next) {
                                currNode.next.next = currNode;
                            }
                            break;
                        case 'reverse_link':
                            if (currNode && currNode.next) {
                                currNode.next.next = null;
                            }
                            break;
                        case 'recursive_call':
                            if (currNode && currNode.next) {
                                // 恢复next指针
                                const nextNode = currNode.next;
                                nextNode.color = CONFIG.COLORS.NODE_DEFAULT;
                                nextNode.isCurrent = false;
                                nextNode.processed = false;
                            }
                            break;
                        case 'base_case_check':
                            // 重置到初始状态
                            this.pointers.curr.updatePosition(this.nodes[0], -60, -80);
                            this.recursionStack = [];
                            this.updateRecursionStackDisplay();
                            this.nodes.forEach(node => {
                                node.color = CONFIG.COLORS.NODE_DEFAULT;
                                node.processed = false;
                                node.isCurrent = false;
                            });
                            if (this.nodes[0]) {
                                this.nodes[0].isCurrent = true;
                                this.nodes[0].color = CONFIG.COLORS.NODE_CURRENT;
                            }
                            break;
                    }
                    return;
                }
                
                // 正向执行
                switch (action) {
                    case 'base_case_check':
                        // 检查是否到达递归基
                        if (!currNode || !currNode.next) {
                            // 到达递归基，直接返回
                            this.currentStep = ALGORITHMS.recursive.steps.length - 1;
                        }
                        break;
                        
                    case 'recursive_call':
                        if (currNode) {
                            // 将当前调用压入栈
                            this.recursionStack.push({
                                node: currNode,
                                depth: this.recursionStack.length + 1
                            });
                            
                            // 移动到下一个节点
                            const nextNode = currNode.next;
                            if (nextNode) {
                                currNode.color = CONFIG.COLORS.NODE_PROCESSED;
                                currNode.isCurrent = false;
                                currNode.processed = true;
                                
                                nextNode.color = CONFIG.COLORS.NODE_CURRENT;
                                nextNode.isCurrent = true;
                                this.pointers.curr.updatePosition(nextNode, -60, -80);
                            }
                            this.updateRecursionStackDisplay();
                        }
                        break;
                        
                    case 'reverse_link':
                        if (currNode && currNode.next) {
                            currNode.next.next = currNode;
                        }
                        break;
                        
                    case 'break_link':
                        if (currNode) {
                            currNode.next = null;
                        }
                        break;
                        
                    case 'return_newhead':
                        // 从栈中弹出
                        if (this.recursionStack.length > 0) {
                            const frame = this.recursionStack.pop();
                            if (frame.node) {
                                frame.node.color = CONFIG.COLORS.NODE_PROCESSED;
                                frame.node.processed = true;
                                frame.node.isCurrent = false;
                            }
                            
                            // 如果栈中还有元素，回到上一层
                            if (this.recursionStack.length > 0) {
                                const prevFrame = this.recursionStack[this.recursionStack.length - 1];
                                this.pointers.curr.updatePosition(prevFrame.node, -60, -80);
                                if (prevFrame.node) {
                                    prevFrame.node.color = CONFIG.COLORS.NODE_CURRENT;
                                    prevFrame.node.isCurrent = true;
                                }
                            } else {
                                // 递归结束，newHead指向最后一个节点
                                const lastNode = this.nodes[this.nodes.length - 1];
                                this.pointers.newHead.updatePosition(lastNode, -60, -80);
                                this.pointers.curr.updatePosition(null, -60, -80);
                            }
                            this.updateRecursionStackDisplay();
                        }
                        break;
                }
            }

            executeHeadInsertStep(action, forward) {
                const currNode = this.pointers.curr.targetNode;
                const newHeadNode = this.pointers.newHead.targetNode;
                const nextNode = this.pointers.next.targetNode;
                
                if (!forward) {
                    // 反向执行（撤销操作）
                    switch (action) {
                        case 'move_curr':
                            this.pointers.curr.updatePosition(newHeadNode, -60, -80);
                            if (currNode) {
                                currNode.color = CONFIG.COLORS.NODE_CURRENT;
                                currNode.isCurrent = true;
                            }
                            if (newHeadNode) {
                                newHeadNode.color = CONFIG.COLORS.NODE_PROCESSED;
                                newHeadNode.isCurrent = false;
                            }
                            break;
                        case 'update_newhead':
                            this.pointers.newHead.updatePosition(this.findPrevNode(newHeadNode), -60, -80);
                            if (currNode) {
                                currNode.next = nextNode;
                            }
                            break;
                        case 'insert_at_head':
                            if (currNode) {
                                currNode.next = nextNode;
                            }
                            break;
                        case 'save_next':
                            this.pointers.next.updatePosition(currNode ? currNode.next : null, -60, -80);
                            break;
                        case 'init':
                            this.pointers.newHead.updatePosition(null, -60, -80);
                            this.pointers.curr.updatePosition(this.nodes[0], -60, -80);
                            this.pointers.next.updatePosition(this.nodes[1] || null, -60, -80);
                            this.nodes.forEach(node => {
                                node.color = CONFIG.COLORS.NODE_DEFAULT;
                                node.processed = false;
                                node.isCurrent = false;
                                // 恢复原始链接
                                const index = this.nodes.indexOf(node);
                                if (index < this.nodes.length - 1) {
                                    node.next = this.nodes[index + 1];
                                } else {
                                    node.next = null;
                                }
                            });
                            if (this.nodes[0]) {
                                this.nodes[0].isCurrent = true;
                                this.nodes[0].color = CONFIG.COLORS.NODE_CURRENT;
                            }
                            break;
                    }
                    return;
                }
                
                // 正向执行
                switch (action) {
                    case 'init':
                        this.pointers.newHead.updatePosition(null, -60, -80);
                        this.pointers.curr.updatePosition(this.nodes[0], -60, -80);
                        this.pointers.next.updatePosition(this.nodes[1] || null, -60, -80);
                        break;
                        
                    case 'save_next':
                        if (currNode) {
                            this.pointers.next.updatePosition(currNode.next, -60, -80);
                        }
                        break;
                        
                    case 'insert_at_head':
                        if (currNode) {
                            currNode.next = newHeadNode;
                        }
                        break;
                        
                    case 'update_newhead':
                        this.pointers.newHead.updatePosition(currNode, -60, -80);
                        if (currNode) {
                            currNode.color = CONFIG.COLORS.NODE_PROCESSED;
                            currNode.processed = true;
                            currNode.isCurrent = false;
                        }
                        break;
                        
                    case 'move_curr':
                        this.pointers.curr.updatePosition(nextNode, -60, -80);
                        if (nextNode) {
                            nextNode.color = CONFIG.COLORS.NODE_CURRENT;
                            nextNode.isCurrent = true;
                            this.pointers.next.updatePosition(nextNode.next, -60, -80);
                        } else {
                            this.pointers.next.updatePosition(null, -60, -80);
                        }
                        break;
                }
            }

            findPrevNode(node) {
                if (!node) return null;
                for (let i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i].next === node) {
                        return this.nodes[i];
                    }
                }
                return null;
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                const playBtn = document.getElementById('playPauseBtn');
                
                if (this.isPlaying) {
                    playBtn.innerHTML = '<span>⏸</span> 暂停';
                    this.playAnimation();
                } else {
                    playBtn.innerHTML = '<span>▶</span> 播放';
                }
            }

            playAnimation() {
                if (!this.isPlaying) return;
                
                const algorithm = ALGORITHMS[this.method];
                const speedFactor = this.animationSpeed / 5; // 1-10 映射到 0.2-2
                const stepDuration = CONFIG.ANIMATION_DURATION / speedFactor;
                
                if (this.currentStep < algorithm.steps.length) {
                    this.nextStep();
                    
                    // 设置下一个步骤的延迟
                    setTimeout(() => {
                        this.playAnimation();
                    }, stepDuration);
                } else {
                    this.isPlaying = false;
                    const playBtn = document.getElementById('playPauseBtn');
                    playBtn.innerHTML = '<span>▶</span> 播放';
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                // 这里可以添加更复杂的动画逻辑
            }
        }

        // 初始化应用
        document.addEventListener('DOMContentLoaded', () => {
            const app = new LinkedListAnimation();
            app.animate();
        });
    </script>
</body>
</html>