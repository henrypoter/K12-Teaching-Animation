<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最小生成树：Kruskal算法教学动画</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background-color: #f8f9fa;
            color: #2c3e50;
            line-height: 1.6;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #3498db;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }

        .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .main-view {
            flex: 3;
            min-width: 300px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .side-panel {
            flex: 2;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: white;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            padding: 20px;
        }

        .panel h2 {
            color: #3498db;
            margin-bottom: 15px;
            font-size: 1.4rem;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        #graphCanvas {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fdfdfd;
            flex-grow: 1;
            width: 100%;
            cursor: pointer;
        }

        .canvas-container {
            position: relative;
            flex-grow: 1;
            min-height: 400px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: #ecf0f1;
            color: #2c3e50;
        }

        .btn-secondary:hover {
            background-color: #d5dbdb;
        }

        .btn-success {
            background-color: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background-color: #27ae60;
        }

        .btn-warning {
            background-color: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background-color: #d68910;
        }

        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }

        .speed-control label {
            font-weight: 600;
            color: #7f8c8d;
        }

        #speedSlider {
            width: 120px;
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            background-color: #2c3e50;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-top: 10px;
            font-weight: 600;
        }

        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status-value {
            font-size: 1.4rem;
            color: #3498db;
        }

        .status-label {
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        #edgeList {
            list-style-type: none;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 10px;
        }

        .edge-item {
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            transition: all 0.2s ease;
        }

        .edge-item.current {
            background-color: #fff9e6;
            border-left: 4px solid #f39c12;
            font-weight: 600;
        }

        .edge-item.selected {
            background-color: #e8f6f3;
            border-left: 4px solid #2ecc71;
        }

        .edge-item.rejected {
            background-color: #fdedec;
            border-left: 4px solid #e74c3c;
        }

        .edge-weight {
            font-weight: 600;
            color: #3498db;
        }

        #unionFindView {
            height: 200px;
            border: 1px solid #eee;
            border-radius: 6px;
            background-color: #fdfdfd;
            position: relative;
            overflow: auto;
        }

        .uf-node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.5s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .uf-edge {
            position: absolute;
            transition: all 0.5s ease;
        }

        #pseudocode {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            white-space: pre;
            overflow-x: auto;
            max-height: 300px;
            overflow-y: auto;
        }

        .code-line {
            padding: 2px 5px;
            border-radius: 3px;
            transition: background-color 0.3s ease;
        }

        .code-line.active {
            background-color: #3498db;
            color: white;
        }

        #logPanel {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 6px;
            padding: 10px;
            background-color: #f9f9f9;
            font-size: 0.9rem;
        }

        .log-entry {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            border-left: 4px solid #3498db;
            background-color: white;
        }

        .log-entry.success {
            border-left-color: #2ecc71;
        }

        .log-entry.warning {
            border-left-color: #f39c12;
        }

        .log-entry.error {
            border-left-color: #e74c3c;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .instructions {
            background-color: #e8f4fc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            border-left: 4px solid #3498db;
        }

        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .controls {
                justify-content: center;
            }
            
            .speed-control {
                margin-left: 0;
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>最小生成树：Kruskal算法教学动画</h1>
        <p class="subtitle">并查集 + 边排序加入 | 贪心算法可视化</p>
    </header>

    <div class="container">
        <div class="main-view">
            <h2>图可视化</h2>
            <div class="canvas-container">
                <canvas id="graphCanvas" width="800" height="500"></canvas>
            </div>
            
            <div class="controls">
                <button id="resetBtn" class="btn btn-secondary">重置</button>
                <button id="prevBtn" class="btn btn-secondary">上一步</button>
                <button id="nextBtn" class="btn btn-primary">下一步</button>
                <button id="playBtn" class="btn btn-success">播放</button>
                <button id="skipToEndBtn" class="btn btn-warning">跳到结束</button>
                
                <div class="speed-control">
                    <label for="speedSlider">速度:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                </div>
            </div>
            
            <div class="status-bar">
                <div class="status-item">
                    <span class="status-value" id="selectedEdgesCount">0</span>
                    <span class="status-label">已选边数</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="totalWeight">0</span>
                    <span class="status-label">总权值</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="currentStep">0</span>
                    <span class="status-label">当前步骤</span>
                </div>
                <div class="status-item">
                    <span class="status-value" id="edgesProcessed">0</span>
                    <span class="status-label">已处理边</span>
                </div>
            </div>
        </div>
        
        <div class="side-panel">
            <div class="panel">
                <h2>边列表（已排序）</h2>
                <ul id="edgeList"></ul>
            </div>
            
            <div class="panel">
                <h2>并查集可视化</h2>
                <div id="unionFindView"></div>
            </div>
            
            <div class="panel">
                <h2>算法伪代码</h2>
                <div id="pseudocode"></div>
            </div>
            
            <div class="panel">
                <h2>操作日志</h2>
                <div id="logPanel"></div>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: #95a5a6;"></div>
            <span>未处理边</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e67e22;"></div>
            <span>当前处理边</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #2ecc71;"></div>
            <span>已选入生成树</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c;"></div>
            <span>拒绝（成环）</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #9b59b6;"></div>
            <span>并查集集合</span>
        </div>
    </div>
    
    <div class="instructions">
        <h3>使用说明</h3>
        <ul>
            <li>点击<b>下一步</b>按钮逐步执行Kruskal算法</li>
            <li>使用<b>播放</b>按钮自动执行算法，可使用滑块调整速度</li>
            <li>观察并查集如何判断是否形成环</li>
            <li>已排序的边列表显示当前处理的边状态</li>
            <li>伪代码区域高亮显示当前执行的代码行</li>
            <li>操作日志记录算法的每一步决策</li>
        </ul>
    </div>

    <script>
        // 初始化图数据
        const graph = {
            vertices: ['A', 'B', 'C', 'D', 'E', 'F'],
            edges: [
                {from: 'A', to: 'B', weight: 4},
                {from: 'A', to: 'C', weight: 4},
                {from: 'B', to: 'C', weight: 2},
                {from: 'C', to: 'D', weight: 3},
                {from: 'C', to: 'E', weight: 2},
                {from: 'C', to: 'F', weight: 4},
                {from: 'D', to: 'F', weight: 3},
                {from: 'E', to: 'F', weight: 3}
            ]
        };

        // 算法状态
        let state = {
            currentStep: 0,
            selectedEdges: [],
            unionFind: {},
            sortedEdges: [],
            processedEdges: 0,
            totalWeight: 0,
            isPlaying: false,
            playSpeed: 500,
            history: [],
            currentEdgeIndex: 0
        };

        // 伪代码定义
        const pseudocode = [
            "function Kruskal(G):",
            "    // 初始化并查集，每个顶点单独一个集合",
            "    for each vertex v in G.vertices:",
            "        makeSet(v)",
            "    ",
            "    // 将所有边按权值从小到大排序",
            "    edges = sort(G.edges by weight)",
            "    ",
            "    // 初始化最小生成树",
            "    MST = []",
            "    ",
            "    // 遍历所有边",
            "    for each edge (u, v, weight) in edges:",
            "        // 如果u和v不在同一集合（不会形成环）",
            "        if find(u) != find(v):",
            "            // 将边加入最小生成树",
            "            MST.add(edge)",
            "            // 合并两个集合",
            "            union(u, v)",
            "    ",
            "    return MST"
        ];

        // 初始化函数
        function init() {
            // 初始化并查集
            state.unionFind = {};
            graph.vertices.forEach(v => {
                state.unionFind[v] = {parent: v, rank: 0};
            });
            
            // 边排序
            state.sortedEdges = [...graph.edges].sort((a, b) => a.weight - b.weight);
            
            // 重置状态
            state.currentStep = 0;
            state.selectedEdges = [];
            state.processedEdges = 0;
            state.totalWeight = 0;
            state.currentEdgeIndex = 0;
            state.history = [];
            
            // 更新UI
            updateEdgeList();
            updatePseudocode();
            updateUnionFindView();
            updateStatus();
            clearLog();
            addLog("初始化完成。图有 " + graph.vertices.length + " 个顶点和 " + graph.edges.length + " 条边。", "info");
            addLog("边已按权值排序完成。", "info");
            
            // 绘制初始图
            drawGraph();
        }

        // 绘制图
        function drawGraph() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 计算顶点位置（圆形布局）
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.35;
            const vertexPositions = {};
            
            // 绘制边
            graph.edges.forEach(edge => {
                const fromIdx = graph.vertices.indexOf(edge.from);
                const toIdx = graph.vertices.indexOf(edge.to);
                
                const angleFrom = (fromIdx / graph.vertices.length) * 2 * Math.PI;
                const angleTo = (toIdx / graph.vertices.length) * 2 * Math.PI;
                
                const x1 = centerX + radius * Math.cos(angleFrom - Math.PI/2);
                const y1 = centerY + radius * Math.sin(angleFrom - Math.PI/2);
                const x2 = centerX + radius * Math.cos(angleTo - Math.PI/2);
                const y2 = centerY + radius * Math.sin(angleTo - Math.PI/2);
                
                // 保存顶点位置
                if (!vertexPositions[edge.from]) {
                    vertexPositions[edge.from] = {x: x1, y: y1};
                }
                if (!vertexPositions[edge.to]) {
                    vertexPositions[edge.to] = {x: x2, y: y2};
                }
                
                // 确定边的颜色和宽度
                let color = '#95a5a6'; // 默认灰色
                let width = 1;
                
                // 检查是否是当前处理的边
                if (state.currentEdgeIndex < state.sortedEdges.length) {
                    const currentEdge = state.sortedEdges[state.currentEdgeIndex];
                    if (edge.from === currentEdge.from && edge.to === currentEdge.to && 
                        edge.weight === currentEdge.weight) {
                        color = '#e67e22'; // 当前处理边 - 橙色
                        width = 3;
                    }
                }
                
                // 检查是否已选入生成树
                const isSelected = state.selectedEdges.some(e => 
                    (e.from === edge.from && e.to === edge.to) || 
                    (e.from === edge.to && e.to === edge.from));
                
                if (isSelected) {
                    color = '#2ecc71'; // 已选边 - 绿色
                    width = 4;
                }
                
                // 绘制边
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.stroke();
                
                // 绘制权值
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(edge.weight, midX, midY - 5);
            });
            
            // 绘制顶点
            graph.vertices.forEach((vertex, idx) => {
                const angle = (idx / graph.vertices.length) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle - Math.PI/2);
                const y = centerY + radius * Math.sin(angle - Math.PI/2);
                
                // 保存位置
                vertexPositions[vertex] = {x, y};
                
                // 绘制顶点圆圈
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 绘制顶点标签
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(vertex, x, y);
                
                // 绘制并查集父节点（如果不同）
                if (state.unionFind[vertex] && state.unionFind[vertex].parent !== vertex) {
                    ctx.fillStyle = '#9b59b6';
                    ctx.font = '12px Arial';
                    ctx.fillText('→' + state.unionFind[vertex].parent, x, y + 25);
                }
            });
            
            // 保存顶点位置供其他函数使用
            window.vertexPositions = vertexPositions;
        }

        // 更新边列表
        function updateEdgeList() {
            const edgeList = document.getElementById('edgeList');
            edgeList.innerHTML = '';
            
            state.sortedEdges.forEach((edge, idx) => {
                const li = document.createElement('li');
                li.className = 'edge-item';
                
                // 设置状态类
                if (idx === state.currentEdgeIndex) {
                    li.classList.add('current');
                } else if (idx < state.currentEdgeIndex) {
                    const isSelected = state.selectedEdges.some(e => 
                        (e.from === edge.from && e.to === edge.to) || 
                        (e.from === edge.to && e.to === edge.from));
                    
                    if (isSelected) {
                        li.classList.add('selected');
                    } else {
                        li.classList.add('rejected');
                    }
                }
                
                li.innerHTML = `
                    <span>${edge.from} ↔ ${edge.to}</span>
                    <span class="edge-weight">权值: ${edge.weight}</span>
                `;
                
                edgeList.appendChild(li);
            });
        }

        // 更新并查集可视化
        function updateUnionFindView() {
            const container = document.getElementById('unionFindView');
            container.innerHTML = '';
            
            // 找出所有集合的代表元
            const sets = {};
            graph.vertices.forEach(v => {
                const root = find(v);
                if (!sets[root]) {
                    sets[root] = [];
                }
                sets[root].push(v);
            });
            
            // 计算布局
            const setKeys = Object.keys(sets);
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const setWidth = containerWidth / Math.max(setKeys.length, 1);
            
            // 绘制每个集合
            setKeys.forEach((root, setIndex) => {
                const vertices = sets[root];
                const setX = setIndex * setWidth + setWidth / 2;
                
                // 绘制集合标题
                const title = document.createElement('div');
                title.style.position = 'absolute';
                title.style.left = (setX - 30) + 'px';
                title.style.top = '10px';
                title.style.color = '#9b59b6';
                title.style.fontWeight = 'bold';
                title.textContent = `集合 ${root}`;
                container.appendChild(title);
                
                // 绘制集合中的顶点
                vertices.forEach((vertex, vertexIndex) => {
                    const node = document.createElement('div');
                    node.className = 'uf-node';
                    node.textContent = vertex;
                    node.style.left = (setX - 20 + (vertexIndex - vertices.length/2) * 50) + 'px';
                    node.style.top = (60 + vertexIndex * 10) + 'px';
                    
                    // 设置颜色
                    if (vertex === root) {
                        node.style.backgroundColor = '#9b59b6'; // 集合代表元
                        node.style.color = 'white';
                    } else {
                        node.style.backgroundColor = '#e8d4f4'; // 集合成员
                        node.style.color = '#2c3e50';
                    }
                    
                    // 如果当前正在处理这个顶点，添加高亮
                    if (state.currentEdgeIndex < state.sortedEdges.length) {
                        const currentEdge = state.sortedEdges[state.currentEdgeIndex];
                        if (vertex === currentEdge.from || vertex === currentEdge.to) {
                            node.style.boxShadow = '0 0 0 3px #f39c12';
                        }
                    }
                    
                    // 显示父节点（如果不是代表元）
                    if (state.unionFind[vertex].parent !== vertex) {
                        const parentLabel = document.createElement('div');
                        parentLabel.style.position = 'absolute';
                        parentLabel.style.left = '0';
                        parentLabel.style.bottom = '-20px';
                        parentLabel.style.fontSize = '10px';
                        parentLabel.style.color = '#7f8c8d';
                        parentLabel.textContent = `→${state.unionFind[vertex].parent}`;
                        node.appendChild(parentLabel);
                    }
                    
                    container.appendChild(node);
                });
            });
        }

        // 更新伪代码高亮
        function updatePseudocode() {
            const pseudocodeDiv = document.getElementById('pseudocode');
            pseudocodeDiv.innerHTML = '';
            
            // 确定当前高亮的行
            let highlightLine = -1;
            if (state.currentStep === 0) {
                highlightLine = 0; // 初始化
            } else if (state.currentStep === 1) {
                highlightLine = 1; // 初始化并查集
            } else if (state.currentStep === 2) {
                highlightLine = 4; // 排序边
            } else if (state.currentStep >= 3) {
                // 处理边的循环
                if (state.currentEdgeIndex < state.sortedEdges.length) {
                    highlightLine = 9; // for循环
                    
                    const currentEdge = state.sortedEdges[state.currentEdgeIndex];
                    const root1 = find(currentEdge.from);
                    const root2 = find(currentEdge.to);
                    
                    if (root1 === root2) {
                        highlightLine = 10; // if条件（不成立）
                    } else {
                        highlightLine = 11; // if条件（成立）
                    }
                } else {
                    highlightLine = 15; // 返回结果
                }
            }
            
            // 渲染伪代码
            pseudocode.forEach((line, index) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'code-line';
                lineDiv.textContent = line;
                
                if (index === highlightLine) {
                    lineDiv.classList.add('active');
                }
                
                pseudocodeDiv.appendChild(lineDiv);
            });
        }

        // 更新状态栏
        function updateStatus() {
            document.getElementById('selectedEdgesCount').textContent = state.selectedEdges.length;
            document.getElementById('totalWeight').textContent = state.totalWeight;
            document.getElementById('currentStep').textContent = state.currentStep;
            document.getElementById('edgesProcessed').textContent = state.processedEdges;
        }

        // 添加日志
        function addLog(message, type = 'info') {
            const logPanel = document.getElementById('logPanel');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
            
            logPanel.appendChild(logEntry);
            logPanel.scrollTop = logPanel.scrollHeight;
        }

        // 清除日志
        function clearLog() {
            document.getElementById('logPanel').innerHTML = '';
        }

        // 并查集操作：查找
        function find(vertex) {
            if (state.unionFind[vertex].parent !== vertex) {
                // 路径压缩（简化可视化，实际算法中常用）
                state.unionFind[vertex].parent = find(state.unionFind[vertex].parent);
            }
            return state.unionFind[vertex].parent;
        }

        // 并查集操作：合并
        function union(vertex1, vertex2) {
            const root1 = find(vertex1);
            const root2 = find(vertex2);
            
            if (root1 !== root2) {
                // 按秩合并
                if (state.unionFind[root1].rank < state.unionFind[root2].rank) {
                    state.unionFind[root1].parent = root2;
                } else if (state.unionFind[root1].rank > state.unionFind[root2].rank) {
                    state.unionFind[root2].parent = root1;
                } else {
                    state.unionFind[root2].parent = root1;
                    state.unionFind[root1].rank++;
                }
                return true;
            }
            return false;
        }

        // 执行下一步
        function nextStep() {
            // 保存当前状态到历史记录
            state.history.push({
                selectedEdges: [...state.selectedEdges],
                unionFind: JSON.parse(JSON.stringify(state.unionFind)),
                currentEdgeIndex: state.currentEdgeIndex,
                processedEdges: state.processedEdges,
                totalWeight: state.totalWeight
            });
            
            state.currentStep++;
            
            // 算法步骤
            if (state.currentStep === 1) {
                addLog("步骤 1: 初始化并查集，每个顶点单独一个集合", "info");
            } else if (state.currentStep === 2) {
                addLog("步骤 2: 将所有边按权值从小到大排序", "info");
            } else if (state.currentStep >= 3) {
                // 处理边
                if (state.currentEdgeIndex < state.sortedEdges.length) {
                    const edge = state.sortedEdges[state.currentEdgeIndex];
                    addLog(`步骤 ${state.currentStep}: 处理边 ${edge.from}-${edge.to} (权值: ${edge.weight})`, "warning");
                    
                    // 查找两个顶点的根节点
                    const root1 = find(edge.from);
                    const root2 = find(edge.to);
                    
                    addLog(`查找 ${edge.from} 的根节点: ${root1}, 查找 ${edge.to} 的根节点: ${root2}`, "info");
                    
                    if (root1 === root2) {
                        addLog(`${edge.from} 和 ${edge.to} 在同一集合中，加入此边会形成环，跳过此边`, "error");
                    } else {
                        // 加入边到最小生成树
                        state.selectedEdges.push(edge);
                        state.totalWeight += edge.weight;
                        union(edge.from, edge.to);
                        addLog(`将边 ${edge.from}-${edge.to} 加入最小生成树，合并集合 ${root1} 和 ${root2}`, "success");
                    }
                    
                    state.processedEdges++;
                    state.currentEdgeIndex++;
                    
                    // 检查是否完成
                    if (state.selectedEdges.length === graph.vertices.length - 1) {
                        addLog(`算法完成！找到最小生成树，包含 ${state.selectedEdges.length} 条边，总权值: ${state.totalWeight}`, "success");
                    }
                } else {
                    addLog("所有边已处理完毕", "info");
                }
            }
            
            // 更新UI
            updateEdgeList();
            updatePseudocode();
            updateUnionFindView();
            updateStatus();
            drawGraph();
            
            // 如果正在播放且未完成，继续下一步
            if (state.isPlaying && state.currentEdgeIndex < state.sortedEdges.length && 
                state.selectedEdges.length < graph.vertices.length - 1) {
                setTimeout(nextStep, 1000 - (state.playSpeed * 100));
            } else if (state.isPlaying) {
                // 算法完成，停止播放
                state.isPlaying = false;
                document.getElementById('playBtn').textContent = '播放';
                addLog("算法执行完成，自动播放停止", "info");
            }
        }

        // 执行上一步
        function prevStep() {
            if (state.history.length > 0) {
                const prevState = state.history.pop();
                state.selectedEdges = prevState.selectedEdges;
                state.unionFind = prevState.unionFind;
                state.currentEdgeIndex = prevState.currentEdgeIndex;
                state.processedEdges = prevState.processedEdges;
                state.totalWeight = prevState.totalWeight;
                state.currentStep--;
                
                // 更新UI
                updateEdgeList();
                updatePseudocode();
                updateUnionFindView();
                updateStatus();
                drawGraph();
                
                addLog("回退到上一步", "info");
            } else {
                addLog("已在第一步，无法回退", "error");
            }
        }

        // 事件监听器
        document.getElementById('resetBtn').addEventListener('click', () => {
            init();
            addLog("重置算法", "info");
        });

        document.getElementById('prevBtn').addEventListener('click', prevStep);

        document.getElementById('nextBtn').addEventListener('click', nextStep);

        document.getElementById('playBtn').addEventListener('click', () => {
            if (state.isPlaying) {
                state.isPlaying = false;
                document.getElementById('playBtn').textContent = '播放';
                addLog("暂停播放", "info");
            } else {
                state.isPlaying = true;
                document.getElementById('playBtn').textContent = '暂停';
                addLog("开始自动播放", "info");
                nextStep();
            }
        });

        document.getElementById('skipToEndBtn').addEventListener('click', () => {
            addLog("快速执行到算法结束", "warning");
            while (state.currentEdgeIndex < state.sortedEdges.length && 
                   state.selectedEdges.length < graph.vertices.length - 1) {
                // 这里简化处理，直接执行算法而不记录每一步历史
                const edge = state.sortedEdges[state.currentEdgeIndex];
                const root1 = find(edge.from);
                const root2 = find(edge.to);
                
                if (root1 !== root2) {
                    state.selectedEdges.push(edge);
                    state.totalWeight += edge.weight;
                    union(edge.from, edge.to);
                }
                
                state.processedEdges++;
                state.currentEdgeIndex++;
                state.currentStep++;
            }
            
            // 更新UI
            updateEdgeList();
            updatePseudocode();
            updateUnionFindView();
            updateStatus();
            drawGraph();
            
            addLog(`算法快速执行完成！最小生成树包含 ${state.selectedEdges.length} 条边，总权值: ${state.totalWeight}`, "success");
            
            // 如果正在播放，停止
            if (state.isPlaying) {
                state.isPlaying = false;
                document.getElementById('playBtn').textContent = '播放';
            }
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            state.playSpeed = parseInt(e.target.value);
        });

        // 初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>