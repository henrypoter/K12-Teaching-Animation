<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>堆排序建堆与下沉调整动画教学</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #f8f9fa;
            color: #2c3e50;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #3498db;
        }
        
        h1 {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        
        .control-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .data-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            flex: 1;
        }
        
        .control-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            flex: 1;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background-color: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #2980b9;
        }
        
        .btn-secondary {
            background-color: #ecf0f1;
            color: #2c3e50;
        }
        
        .btn-secondary:hover {
            background-color: #d5dbdb;
        }
        
        .btn-success {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-success:hover {
            background-color: #219653;
        }
        
        .btn-warning {
            background-color: #e67e22;
            color: white;
        }
        
        .btn-warning:hover {
            background-color: #d35400;
        }
        
        .btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .input-array {
            padding: 8px 12px;
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            width: 200px;
            font-size: 1em;
        }
        
        .input-array:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .speed-slider {
            width: 120px;
        }
        
        .visualization-area {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
        }
        
        .visualization-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            flex: 1;
            min-width: 300px;
        }
        
        .panel-title {
            color: #3498db;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #ecf0f1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .array-container {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            min-height: 120px;
        }
        
        .array-element {
            width: 70px;
            height: 70px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .element-value {
            font-size: 1.4em;
        }
        
        .element-index {
            font-size: 0.8em;
            position: absolute;
            top: 5px;
            left: 5px;
            color: #7f8c8d;
        }
        
        .tree-container {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            min-height: 300px;
            position: relative;
        }
        
        .tree-svg {
            width: 100%;
            height: 300px;
        }
        
        .info-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
        .step-info {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        
        .step-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .step-desc {
            color: #34495e;
            line-height: 1.5;
        }
        
        .counters {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        
        .counter {
            text-align: center;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 6px;
            flex: 1;
        }
        
        .counter-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #3498db;
        }
        
        .counter-label {
            font-size: 0.9em;
            color: #7f8c8d;
            margin-top: 5px;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #ecf0f1;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        @media (max-width: 768px) {
            .visualization-area {
                flex-direction: column;
            }
            
            .control-panel {
                flex-direction: column;
                align-items: stretch;
            }
            
            .data-section, .control-section {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>堆排序：建堆与下沉调整动画教学</h1>
        <p class="subtitle">可视化演示堆排序的建堆过程与下沉调整算法</p>
    </div>
    
    <div class="container">
        <div class="control-panel">
            <div class="data-section">
                <h3>数据输入:</h3>
                <input type="text" class="input-array" id="arrayInput" value="3,9,2,5,7,1,8">
                <button class="btn btn-primary" id="generateBtn">生成数组</button>
                <button class="btn btn-secondary" id="exampleBtn">示例数组</button>
            </div>
            
            <div class="control-section">
                <h3>动画控制:</h3>
                <button class="btn btn-success" id="playBtn">开始建堆</button>
                <button class="btn btn-warning" id="nextBtn">下一步</button>
                <button class="btn btn-secondary" id="prevBtn">上一步</button>
                <button class="btn btn-secondary" id="resetBtn">重置</button>
                
                <div class="speed-control">
                    <span>速度:</span>
                    <input type="range" min="1" max="10" value="5" class="speed-slider" id="speedSlider">
                </div>
            </div>
        </div>
        
        <div class="visualization-area">
            <div class="visualization-panel">
                <div class="panel-title">
                    <h2>数组视图</h2>
                    <span id="arrayStatus">初始数组</span>
                </div>
                <div class="array-container" id="arrayContainer">
                    <!-- 数组元素将通过JS动态生成 -->
                </div>
            </div>
            
            <div class="visualization-panel">
                <div class="panel-title">
                    <h2>二叉树视图</h2>
                    <span id="treeStatus">初始状态</span>
                </div>
                <div class="tree-container">
                    <svg class="tree-svg" id="treeSvg">
                        <!-- 二叉树将通过JS动态绘制 -->
                    </svg>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="step-info">
                <div class="step-title">
                    <span id="stepTitle">准备开始</span>
                    <span id="stepCounter">步骤: 0/0</span>
                </div>
                <div class="step-desc" id="stepDesc">
                    请点击"开始建堆"按钮或"下一步"按钮开始动画演示。
                </div>
            </div>
            
            <div class="counters">
                <div class="counter">
                    <div class="counter-value" id="compareCount">0</div>
                    <div class="counter-label">比较次数</div>
                </div>
                <div class="counter">
                    <div class="counter-value" id="swapCount">0</div>
                    <div class="counter-label">交换次数</div>
                </div>
                <div class="counter">
                    <div class="counter-value" id="stepCount">0</div>
                    <div class="counter-label">总步骤数</div>
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ffffff; border: 2px solid #bdc3c7;"></div>
                    <span>默认节点</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e67e22;"></div>
                    <span>当前操作节点</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #aed6f1;"></div>
                    <span>待比较子节点</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #d5f4e6;"></div>
                    <span>已就位节点</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 堆排序动画状态管理
        class HeapSortAnimation {
            constructor() {
                this.array = [3, 9, 2, 5, 7, 1, 8];
                this.originalArray = [...this.array];
                this.steps = [];
                this.currentStep = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.speed = 5;
                this.compareCount = 0;
                this.swapCount = 0;
                this.stepCount = 0;
                
                // 节点状态常量
                this.NODE_STATE = {
                    DEFAULT: 0,
                    CURRENT: 1,
                    COMPARE: 2,
                    SWAPPING: 3,
                    IN_PLACE: 4
                };
                
                // 初始化节点状态
                this.nodeStates = this.array.map(() => this.NODE_STATE.DEFAULT);
                
                // 初始化UI
                this.initUI();
                this.renderArray();
                this.renderTree();
                this.updateInfo();
            }
            
            initUI() {
                // 获取DOM元素
                this.arrayInput = document.getElementById('arrayInput');
                this.generateBtn = document.getElementById('generateBtn');
                this.exampleBtn = document.getElementById('exampleBtn');
                this.playBtn = document.getElementById('playBtn');
                this.nextBtn = document.getElementById('nextBtn');
                this.prevBtn = document.getElementById('prevBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.speedSlider = document.getElementById('speedSlider');
                
                // 绑定事件
                this.generateBtn.addEventListener('click', () => this.generateArray());
                this.exampleBtn.addEventListener('click', () => this.loadExample());
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.nextBtn.addEventListener('click', () => this.nextStep());
                this.prevBtn.addEventListener('click', () => this.prevStep());
                this.resetBtn.addEventListener('click', () => this.reset());
                this.speedSlider.addEventListener('input', () => this.updateSpeed());
                
                // 初始化速度
                this.updateSpeed();
            }
            
            generateArray() {
                const input = this.arrayInput.value.trim();
                if (!input) return;
                
                try {
                    const newArray = input.split(',').map(num => parseInt(num.trim()));
                    if (newArray.some(isNaN)) {
                        alert('请输入有效的数字，用逗号分隔');
                        return;
                    }
                    
                    this.array = [...newArray];
                    this.originalArray = [...newArray];
                    this.resetState();
                    this.renderArray();
                    this.renderTree();
                    this.updateInfo();
                } catch (e) {
                    alert('输入格式错误，请使用逗号分隔的数字，如: 3,9,2,5,7,1,8');
                }
            }
            
            loadExample() {
                this.arrayInput.value = '3,9,2,5,7,1,8';
                this.generateArray();
            }
            
            updateSpeed() {
                this.speed = parseInt(this.speedSlider.value);
                if (this.isPlaying) {
                    this.stopPlay();
                    this.startPlay();
                }
            }
            
            resetState() {
                this.steps = [];
                this.currentStep = 0;
                this.compareCount = 0;
                this.swapCount = 0;
                this.stepCount = 0;
                this.nodeStates = this.array.map(() => this.NODE_STATE.DEFAULT);
                this.isPlaying = false;
                this.playBtn.textContent = '开始建堆';
                this.playBtn.classList.remove('btn-warning');
                this.playBtn.classList.add('btn-success');
                
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }
            
            reset() {
                this.array = [...this.originalArray];
                this.resetState();
                this.renderArray();
                this.renderTree();
                this.updateInfo();
            }
            
            togglePlay() {
                if (this.isPlaying) {
                    this.stopPlay();
                } else {
                    this.startPlay();
                }
            }
            
            startPlay() {
                if (this.steps.length === 0) {
                    this.buildHeap();
                }
                
                if (this.currentStep >= this.steps.length) {
                    this.currentStep = 0;
                }
                
                this.isPlaying = true;
                this.playBtn.textContent = '暂停';
                this.playBtn.classList.remove('btn-success');
                this.playBtn.classList.add('btn-warning');
                
                const intervalTime = 1100 - (this.speed * 100);
                this.playInterval = setInterval(() => {
                    if (this.currentStep < this.steps.length) {
                        this.executeStep(this.currentStep);
                        this.currentStep++;
                    } else {
                        this.stopPlay();
                    }
                }, intervalTime);
            }
            
            stopPlay() {
                this.isPlaying = false;
                this.playBtn.textContent = '继续建堆';
                this.playBtn.classList.remove('btn-warning');
                this.playBtn.classList.add('btn-success');
                
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }
            
            nextStep() {
                if (this.steps.length === 0) {
                    this.buildHeap();
                }
                
                if (this.currentStep < this.steps.length) {
                    this.executeStep(this.currentStep);
                    this.currentStep++;
                }
            }
            
            prevStep() {
                if (this.currentStep > 0) {
                    this.currentStep--;
                    this.undoStep(this.currentStep);
                }
            }
            
            buildHeap() {
                this.resetState();
                const n = this.array.length;
                const steps = [];
                
                // 从最后一个非叶子节点开始，向前遍历
                for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                    this.heapify(steps, n, i);
                }
                
                this.steps = steps;
                this.stepCount = steps.length;
                document.getElementById('stepCount').textContent = this.stepCount;
            }
            
            heapify(steps, n, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;
                
                // 步骤1: 标记当前节点
                steps.push({
                    type: 'mark_current',
                    index: i,
                    description: `开始调整节点[${i}] (值: ${this.array[i]})`
                });
                
                // 步骤2: 比较左子节点
                if (left < n) {
                    steps.push({
                        type: 'compare_left',
                        index: i,
                        leftIndex: left,
                        description: `比较节点[${i}] (值: ${this.array[i]}) 与左子节点[${left}] (值: ${this.array[left]})`
                    });
                    
                    if (this.array[left] > this.array[largest]) {
                        largest = left;
                        steps.push({
                            type: 'left_larger',
                            index: i,
                            leftIndex: left,
                            description: `左子节点[${left}] (值: ${this.array[left]}) 更大，记录为最大节点`
                        });
                    }
                }
                
                // 步骤3: 比较右子节点
                if (right < n) {
                    steps.push({
                        type: 'compare_right',
                        index: i,
                        rightIndex: right,
                        description: `比较节点[${i}] (值: ${this.array[i]}) 与右子节点[${right}] (值: ${this.array[right]})`
                    });
                    
                    if (this.array[right] > this.array[largest]) {
                        largest = right;
                        steps.push({
                            type: 'right_larger',
                            index: i,
                            rightIndex: right,
                            description: `右子节点[${right}] (值: ${this.array[right]}) 更大，记录为最大节点`
                        });
                    }
                }
                
                // 步骤4: 如果需要交换
                if (largest !== i) {
                    steps.push({
                        type: 'swap',
                        index1: i,
                        index2: largest,
                        description: `节点[${i}] (值: ${this.array[i]}) 小于子节点[${largest}] (值: ${this.array[largest]})，需要交换`
                    });
                    
                    // 交换数组元素
                    [this.array[i], this.array[largest]] = [this.array[largest], this.array[i]];
                    
                    // 递归调整
                    this.heapify(steps, n, largest);
                } else {
                    steps.push({
                        type: 'in_place',
                        index: i,
                        description: `节点[${i}] (值: ${this.array[i]}) 已满足堆性质，调整完成`
                    });
                }
                
                // 恢复原始数组状态用于动画
                this.array = [...this.originalArray];
            }
            
            executeStep(stepIndex) {
                const step = this.steps[stepIndex];
                
                // 重置所有节点状态为默认
                this.nodeStates = this.nodeStates.map(() => this.NODE_STATE.DEFAULT);
                
                // 根据步骤类型执行操作
                switch (step.type) {
                    case 'mark_current':
                        this.nodeStates[step.index] = this.NODE_STATE.CURRENT;
                        break;
                        
                    case 'compare_left':
                        this.nodeStates[step.index] = this.NODE_STATE.CURRENT;
                        this.nodeStates[step.leftIndex] = this.NODE_STATE.COMPARE;
                        this.compareCount++;
                        break;
                        
                    case 'compare_right':
                        this.nodeStates[step.index] = this.NODE_STATE.CURRENT;
                        this.nodeStates[step.rightIndex] = this.NODE_STATE.COMPARE;
                        this.compareCount++;
                        break;
                        
                    case 'left_larger':
                    case 'right_larger':
                        this.nodeStates[step.index] = this.NODE_STATE.CURRENT;
                        break;
                        
                    case 'swap':
                        this.nodeStates[step.index] = this.NODE_STATE.CURRENT;
                        this.nodeStates[step.index2] = this.NODE_STATE.COMPARE;
                        
                        // 执行交换
                        [this.array[step.index1], this.array[step.index2]] = 
                        [this.array[step.index2], this.array[step.index1]];
                        this.swapCount++;
                        break;
                        
                    case 'in_place':
                        this.nodeStates[step.index] = this.NODE_STATE.IN_PLACE;
                        break;
                }
                
                // 更新UI
                this.renderArray();
                this.renderTree();
                this.updateInfo(step);
                
                // 更新计数器显示
                document.getElementById('compareCount').textContent = this.compareCount;
                document.getElementById('swapCount').textContent = this.swapCount;
                document.getElementById('stepCounter').textContent = `步骤: ${stepIndex + 1}/${this.steps.length}`;
            }
            
            undoStep(stepIndex) {
                // 重新执行到上一步
                this.compareCount = 0;
                this.swapCount = 0;
                this.array = [...this.originalArray];
                this.nodeStates = this.array.map(() => this.NODE_STATE.DEFAULT);
                
                for (let i = 0; i <= stepIndex; i++) {
                    const step = this.steps[i];
                    
                    // 根据步骤类型更新状态
                    switch (step.type) {
                        case 'compare_left':
                        case 'compare_right':
                            this.compareCount++;
                            break;
                            
                        case 'swap':
                            // 执行交换
                            [this.array[step.index1], this.array[step.index2]] = 
                            [this.array[step.index2], this.array[step.index1]];
                            this.swapCount++;
                            break;
                    }
                }
                
                // 执行当前步骤以更新状态
                if (stepIndex >= 0) {
                    this.executeStep(stepIndex);
                } else {
                    this.renderArray();
                    this.renderTree();
                    this.updateInfo();
                }
                
                // 更新计数器显示
                document.getElementById('compareCount').textContent = this.compareCount;
                document.getElementById('swapCount').textContent = this.swapCount;
                document.getElementById('stepCounter').textContent = `步骤: ${stepIndex + 1}/${this.steps.length}`;
            }
            
            renderArray() {
                const container = document.getElementById('arrayContainer');
                container.innerHTML = '';
                
                // 更新状态显示
                const arrayStatus = document.getElementById('arrayStatus');
                const isHeap = this.isMaxHeap();
                arrayStatus.textContent = isHeap ? '已建堆完成' : '建堆中...';
                arrayStatus.style.color = isHeap ? '#27ae60' : '#e67e22';
                
                // 创建数组元素
                this.array.forEach((value, index) => {
                    const element = document.createElement('div');
                    element.className = 'array-element';
                    element.dataset.index = index;
                    
                    // 根据节点状态设置样式
                    let bgColor, borderColor, textColor;
                    
                    switch (this.nodeStates[index]) {
                        case this.NODE_STATE.CURRENT:
                            bgColor = '#e67e22';
                            borderColor = '#e67e22';
                            textColor = 'white';
                            break;
                        case this.NODE_STATE.COMPARE:
                            bgColor = '#aed6f1';
                            borderColor = '#3498db';
                            textColor = '#2c3e50';
                            break;
                        case this.NODE_STATE.IN_PLACE:
                            bgColor = '#d5f4e6';
                            borderColor = '#27ae60';
                            textColor = '#2c3e50';
                            break;
                        default:
                            bgColor = 'white';
                            borderColor = '#bdc3c7';
                            textColor = '#2c3e50';
                    }
                    
                    element.style.backgroundColor = bgColor;
                    element.style.border = `2px solid ${borderColor}`;
                    element.style.color = textColor;
                    
                    // 添加索引和值
                    const indexSpan = document.createElement('span');
                    indexSpan.className = 'element-index';
                    indexSpan.textContent = `[${index}]`;
                    
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'element-value';
                    valueSpan.textContent = value;
                    
                    element.appendChild(indexSpan);
                    element.appendChild(valueSpan);
                    container.appendChild(element);
                });
            }
            
            renderTree() {
                const svg = document.getElementById('treeSvg');
                svg.innerHTML = '';
                
                // 更新状态显示
                const treeStatus = document.getElementById('treeStatus');
                const isHeap = this.isMaxHeap();
                treeStatus.textContent = isHeap ? '大顶堆已建立' : '构建大顶堆中';
                treeStatus.style.color = isHeap ? '#27ae60' : '#e67e22';
                
                const width = svg.clientWidth;
                const height = svg.clientHeight;
                const nodeRadius = 25;
                const levelHeight = 80;
                
                // 计算树的高度
                const treeHeight = Math.floor(Math.log2(this.array.length)) + 1;
                
                // 绘制树节点和连线
                for (let i = 0; i < this.array.length; i++) {
                    const level = Math.floor(Math.log2(i + 1));
                    const nodesInLevel = Math.pow(2, level);
                    const positionInLevel = i + 1 - Math.pow(2, level);
                    
                    // 计算节点位置
                    const x = width / (nodesInLevel + 1) * (positionInLevel + 1);
                    const y = level * levelHeight + 50;
                    
                    // 绘制到父节点的连线
                    if (i > 0) {
                        const parentIndex = Math.floor((i - 1) / 2);
                        const parentLevel = Math.floor(Math.log2(parentIndex + 1));
                        const parentNodesInLevel = Math.pow(2, parentLevel);
                        const parentPositionInLevel = parentIndex + 1 - Math.pow(2, parentLevel);
                        
                        const parentX = width / (parentNodesInLevel + 1) * (parentPositionInLevel + 1);
                        const parentY = parentLevel * levelHeight + 50;
                        
                        // 绘制连线
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', parentX);
                        line.setAttribute('y1', parentY + nodeRadius);
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', y - nodeRadius);
                        line.setAttribute('stroke', '#bdc3c7');
                        line.setAttribute('stroke-width', '2');
                        svg.appendChild(line);
                    }
                    
                    // 绘制节点
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', nodeRadius);
                    
                    // 根据节点状态设置颜色
                    switch (this.nodeStates[i]) {
                        case this.NODE_STATE.CURRENT:
                            circle.setAttribute('fill', '#e67e22');
                            circle.setAttribute('stroke', '#d35400');
                            break;
                        case this.NODE_STATE.COMPARE:
                            circle.setAttribute('fill', '#aed6f1');
                            circle.setAttribute('stroke', '#3498db');
                            break;
                        case this.NODE_STATE.IN_PLACE:
                            circle.setAttribute('fill', '#d5f4e6');
                            circle.setAttribute('stroke', '#27ae60');
                            break;
                        default:
                            circle.setAttribute('fill', 'white');
                            circle.setAttribute('stroke', '#bdc3c7');
                    }
                    
                    circle.setAttribute('stroke-width', '2');
                    svg.appendChild(circle);
                    
                    // 绘制节点值
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', y + 5);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('font-size', '16');
                    
                    // 根据背景色调整文字颜色
                    if (this.nodeStates[i] === this.NODE_STATE.CURRENT) {
                        text.setAttribute('fill', 'white');
                    } else {
                        text.setAttribute('fill', '#2c3e50');
                    }
                    
                    text.textContent = this.array[i];
                    svg.appendChild(text);
                    
                    // 绘制节点索引
                    const indexText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    indexText.setAttribute('x', x);
                    indexText.setAttribute('y', y - nodeRadius - 5);
                    indexText.setAttribute('text-anchor', 'middle');
                    indexText.setAttribute('font-size', '12');
                    indexText.setAttribute('fill', '#7f8c8d');
                    indexText.textContent = `[${i}]`;
                    svg.appendChild(indexText);
                }
            }
            
            updateInfo(step = null) {
                const stepTitle = document.getElementById('stepTitle');
                const stepDesc = document.getElementById('stepDesc');
                
                if (step) {
                    stepTitle.textContent = this.getStepTitle(step.type);
                    stepDesc.textContent = step.description;
                } else {
                    stepTitle.textContent = '准备开始';
                    stepDesc.textContent = '请点击"开始建堆"按钮或"下一步"按钮开始动画演示。';
                }
            }
            
            getStepTitle(stepType) {
                const titles = {
                    'mark_current': '标记当前节点',
                    'compare_left': '比较左子节点',
                    'compare_right': '比较右子节点',
                    'left_larger': '左子节点更大',
                    'right_larger': '右子节点更大',
                    'swap': '交换节点',
                    'in_place': '节点已就位'
                };
                
                return titles[stepType] || '执行步骤';
            }
            
            isMaxHeap() {
                for (let i = 0; i < this.array.length; i++) {
                    const left = 2 * i + 1;
                    const right = 2 * i + 2;
                    
                    if (left < this.array.length && this.array[left] > this.array[i]) {
                        return false;
                    }
                    
                    if (right < this.array.length && this.array[right] > this.array[i]) {
                        return false;
                    }
                }
                return true;
            }
        }
        
        // 页面加载完成后初始化动画
        document.addEventListener('DOMContentLoaded', () => {
            const animation = new HeapSortAnimation();
        });
    </script>
</body>
</html>