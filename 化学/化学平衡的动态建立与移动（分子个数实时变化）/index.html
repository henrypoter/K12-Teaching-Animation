<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒ–å­¦å¹³è¡¡çš„åŠ¨æ€å»ºç«‹ä¸ç§»åŠ¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #F7F9FC;
            color: #2C3E50;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            padding: 25px;
        }
        
        header {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #E3F2FD;
        }
        
        h1 {
            color: #2E86AB;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }
        
        .subtitle {
            color: #5D6D7E;
            font-size: 1.1rem;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .simulation-area {
            flex: 1;
            min-width: 500px;
            background-color: #FFFFFF;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #F7F9FC;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #E3F2FD;
            margin-bottom: 15px;
        }
        
        #reactionCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .balance-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background-color: rgba(46, 134, 171, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.5s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            flex: 1;
        }
        
        button {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .btn-start {
            background-color: #2E86AB;
            color: white;
        }
        
        .btn-pause {
            background-color: #A23B72;
            color: white;
        }
        
        .btn-reset {
            background-color: #5D6D7E;
            color: white;
        }
        
        .btn-disturb {
            background-color: #F18F01;
            color: white;
        }
        
        .btn-toggle {
            background-color: #4ECDC4;
            color: white;
        }
        
        .data-panel {
            flex: 1;
            min-width: 300px;
            background-color: #FFFFFF;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }
        
        .data-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #2E86AB;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .data-item {
            background-color: #F7F9FC;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4ECDC4;
        }
        
        .data-item.reactant {
            border-left-color: #FF6B6B;
        }
        
        .data-item.product {
            border-left-color: #FFD166;
        }
        
        .data-label {
            font-size: 0.95rem;
            color: #5D6D7E;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .data-value {
            font-size: 2rem;
            font-weight: 700;
        }
        
        .rate-data {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        
        .rate-item {
            text-align: center;
        }
        
        .rate-value {
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .rate-label {
            font-size: 0.9rem;
            color: #5D6D7E;
        }
        
        .chart-container {
            width: 100%;
            height: 300px;
            margin-top: 20px;
            background-color: #FFFFFF;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }
        
        .chart-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #2E86AB;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #chartCanvas {
            width: 100%;
            height: calc(100% - 30px);
            display: block;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .instructions {
            background-color: #E3F2FD;
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
        }
        
        .instructions h3 {
            color: #2E86AB;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                flex-direction: column;
            }
            
            .simulation-area, .data-panel {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>åŒ–å­¦å¹³è¡¡çš„åŠ¨æ€å»ºç«‹ä¸ç§»åŠ¨</h1>
            <p class="subtitle">å¯è§†åŒ–æ¨¡æ‹Ÿï¼šA + B â‡Œ C ååº”ä¸­åˆ†å­ä¸ªæ•°çš„å®æ—¶å˜åŒ–ä¸å¹³è¡¡ç§»åŠ¨</p>
        </header>
        
        <div class="main-content">
            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="reactionCanvas"></canvas>
                    <div class="balance-indicator" id="balanceIndicator">åŠ¨æ€å¹³è¡¡è¾¾æˆ âœ“</div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <button id="startBtn" class="btn-start">
                            <span>â–¶</span> å¼€å§‹ååº”
                        </button>
                        <button id="pauseBtn" class="btn-pause" disabled>
                            <span>â¸</span> æš‚åœ
                        </button>
                        <button id="resetBtn" class="btn-reset">
                            <span>â†º</span> é‡ç½®
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <button id="addAButton" class="btn-disturb">
                            <span>+</span> å¢åŠ Aæµ“åº¦
                        </button>
                        <button id="increasePressure" class="btn-disturb">
                            <span>â†“</span> å¢å¤§å‹å¼º
                        </button>
                        <button id="increaseTemp" class="btn-disturb">
                            <span>â†‘</span> å‡é«˜æ¸©åº¦
                        </button>
                    </div>
                </div>
                
                <div class="controls">
                    <button id="toggleArrows" class="btn-toggle">
                        <span>â‡„</span> æ˜¾ç¤º/éšè—é€Ÿç‡ç®­å¤´
                    </button>
                    <button id="toggleChart" class="btn-toggle">
                        <span>ğŸ“ˆ</span> æ˜¾ç¤º/éšè—æ›²çº¿å›¾
                    </button>
                </div>
            </div>
            
            <div class="data-panel">
                <h2 class="data-title">
                    <span>ğŸ“Š</span> å®æ—¶æ•°æ®é¢æ¿
                </h2>
                
                <div class="data-grid">
                    <div class="data-item reactant">
                        <div class="data-label">
                            <span style="color: #FF6B6B">â—</span> ååº”ç‰© A
                        </div>
                        <div class="data-value" id="countA">100</div>
                    </div>
                    
                    <div class="data-item reactant">
                        <div class="data-label">
                            <span style="color: #4ECDC4">â—</span> ååº”ç‰© B
                        </div>
                        <div class="data-value" id="countB">80</div>
                    </div>
                    
                    <div class="data-item product">
                        <div class="data-label">
                            <span style="color: #FFD166">â—</span> ç”Ÿæˆç‰© C
                        </div>
                        <div class="data-value" id="countC">0</div>
                    </div>
                    
                    <div class="data-item">
                        <div class="data-label">
                            <span>âš–ï¸</span> å¹³è¡¡å¸¸æ•° K
                        </div>
                        <div class="data-value" id="kValue">0.00</div>
                    </div>
                </div>
                
                <div class="rate-data">
                    <div class="rate-item">
                        <div class="rate-value" id="forwardRate">0.00</div>
                        <div class="rate-label">æ­£ååº”é€Ÿç‡</div>
                    </div>
                    
                    <div class="rate-item">
                        <div class="rate-value" id="reverseRate">0.00</div>
                        <div class="rate-label">é€†ååº”é€Ÿç‡</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chart-container" id="chartContainer">
            <h2 class="chart-title">
                <span>ğŸ“ˆ</span> åˆ†å­ä¸ªæ•°ä¸ååº”é€Ÿç‡å˜åŒ–æ›²çº¿
            </h2>
            <canvas id="chartCanvas"></canvas>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #FF6B6B;"></div>
                    <span>ååº”ç‰©A</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4ECDC4;"></div>
                    <span>ååº”ç‰©B</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #FFD166;"></div>
                    <span>ç”Ÿæˆç‰©C</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #A23B72;"></div>
                    <span>æ­£ååº”é€Ÿç‡</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2E86AB;"></div>
                    <span>é€†ååº”é€Ÿç‡</span>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>
                <span>ğŸ’¡</span> ä½¿ç”¨è¯´æ˜
            </h3>
            <ul>
                <li><strong>å¼€å§‹ååº”</strong>ï¼šè§‚å¯Ÿåˆ†å­è¿åŠ¨ã€ç¢°æ’ååº”ä»¥åŠåˆ†å­æ•°é‡çš„å®æ—¶å˜åŒ–ã€‚</li>
                <li><strong>åŠ¨æ€å¹³è¡¡</strong>ï¼šå½“æ­£é€†ååº”é€Ÿç‡ç›¸ç­‰æ—¶ï¼Œç³»ç»Ÿè¾¾åˆ°åŠ¨æ€å¹³è¡¡ï¼ˆåˆ†å­æ•°é‡ä¸å†å˜åŒ–ï¼Œä½†ååº”ä»åœ¨è¿›è¡Œï¼‰ã€‚</li>
                <li><strong>æ‰°åŠ¨å¹³è¡¡</strong>ï¼šä½¿ç”¨"å¢åŠ Aæµ“åº¦"ã€"å¢å¤§å‹å¼º"æˆ–"å‡é«˜æ¸©åº¦"æŒ‰é’®ï¼Œè§‚å¯Ÿå¹³è¡¡å¦‚ä½•ç§»åŠ¨å¹¶é‡æ–°å»ºç«‹ã€‚</li>
                <li><strong>æ•°æ®è§£è¯»</strong>ï¼šå…³æ³¨å®æ—¶æ•°æ®é¢æ¿å’Œæ›²çº¿å›¾ï¼Œç†è§£åˆ†å­ä¸ªæ•°ã€ååº”é€Ÿç‡å’Œå¹³è¡¡å¸¸æ•°çš„å˜åŒ–è§„å¾‹ã€‚</li>
                <li><strong>å‹’å¤ç‰¹åˆ—åŸç†</strong>ï¼šç³»ç»Ÿä¼šæŠµæŠ—å¤–ç•Œæ¡ä»¶çš„æ”¹å˜ï¼Œå‘ç€å‡å¼±è¿™ç§æ”¹å˜çš„æ–¹å‘ç§»åŠ¨ã€‚</li>
            </ul>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡å’Œé…ç½®
        const config = {
            canvasWidth: 800,
            canvasHeight: 400,
            containerPadding: 20,
            particleRadius: 8,
            reactionRadius: 12,
            baseSpeed: 1.5,
            temperature: 1.0, // æ¸©åº¦å› å­ï¼Œå½±å“åˆ†å­é€Ÿåº¦
            pressure: 1.0,   // å‹å¼ºå› å­ï¼Œå½±å“å®¹å™¨å°ºå¯¸
            showArrows: false,
            showChart: true,
            isRunning: false,
            isBalanced: false,
            time: 0,
            timeStep: 0.05,
            maxHistory: 300,
            equilibriumThreshold: 0.05
        };
        
        // ååº”å‚æ•°
        const reaction = {
            // A + B â‡Œ C
            countA: 100,
            countB: 80,
            countC: 0,
            forwardRate: 0,
            reverseRate: 0,
            k: 0,
            
            // ååº”é€Ÿç‡å¸¸æ•°
            kForward: 0.02,
            kReverse: 0.01,
            
            // å†å²æ•°æ®è®°å½•
            history: {
                time: [],
                countA: [],
                countB: [],
                countC: [],
                forwardRate: [],
                reverseRate: []
            }
        };
        
        // åˆ†å­æ•°ç»„
        let particles = [];
        
        // Canvas ä¸Šä¸‹æ–‡
        let reactionCtx, chartCtx;
        
        // DOM å…ƒç´ 
        let startBtn, pauseBtn, resetBtn, addAButton, increasePressure, increaseTemp;
        let toggleArrows, toggleChart;
        let countAElement, countBElement, countCElement, kValueElement;
        let forwardRateElement, reverseRateElement, balanceIndicator;
        let chartContainer;
        
        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            // è·å–Canvasä¸Šä¸‹æ–‡
            const reactionCanvas = document.getElementById('reactionCanvas');
            const chartCanvas = document.getElementById('chartCanvas');
            
            // è®¾ç½®Canvaså°ºå¯¸
            reactionCanvas.width = reactionCanvas.offsetWidth;
            reactionCanvas.height = reactionCanvas.offsetHeight;
            config.canvasWidth = reactionCanvas.width;
            config.canvasHeight = reactionCanvas.height;
            
            chartCanvas.width = chartCanvas.offsetWidth;
            chartCanvas.height = chartCanvas.offsetHeight;
            
            reactionCtx = reactionCanvas.getContext('2d');
            chartCtx = chartCanvas.getContext('2d');
            
            // è·å–DOMå…ƒç´ 
            startBtn = document.getElementById('startBtn');
            pauseBtn = document.getElementById('pauseBtn');
            resetBtn = document.getElementById('resetBtn');
            addAButton = document.getElementById('addAButton');
            increasePressure = document.getElementById('increasePressure');
            increaseTemp = document.getElementById('increaseTemp');
            toggleArrows = document.getElementById('toggleArrows');
            toggleChart = document.getElementById('toggleChart');
            
            countAElement = document.getElementById('countA');
            countBElement = document.getElementById('countB');
            countCElement = document.getElementById('countC');
            kValueElement = document.getElementById('kValue');
            forwardRateElement = document.getElementById('forwardRate');
            reverseRateElement = document.getElementById('reverseRate');
            balanceIndicator = document.getElementById('balanceIndicator');
            chartContainer = document.getElementById('chartContainer');
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            startBtn.addEventListener('click', startReaction);
            pauseBtn.addEventListener('click', pauseReaction);
            resetBtn.addEventListener('click', resetReaction);
            addAButton.addEventListener('click', () => addReactantA(20));
            increasePressure.addEventListener('click', increaseSystemPressure);
            increaseTemp.addEventListener('click', increaseSystemTemperature);
            toggleArrows.addEventListener('click', toggleVelocityArrows);
            toggleChart.addEventListener('click', toggleChartVisibility);
            
            // åˆå§‹åŒ–ç²’å­
            createParticles();
            
            // åˆå§‹åŒ–å›¾è¡¨
            updateChart();
            
            // åˆå§‹æ¸²æŸ“
            drawReaction();
            updateDataDisplay();
        }
        
        // åˆ›å»ºç²’å­
        function createParticles() {
            particles = [];
            
            // åˆ›å»ºAåˆ†å­
            for (let i = 0; i < reaction.countA; i++) {
                particles.push({
                    type: 'A',
                    x: Math.random() * (config.canvasWidth - 2 * config.containerPadding) + config.containerPadding,
                    y: Math.random() * (config.canvasHeight - 2 * config.containerPadding) + config.containerPadding,
                    vx: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    vy: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    color: '#FF6B6B',
                    radius: config.particleRadius,
                    highlight: false,
                    highlightTime: 0
                });
            }
            
            // åˆ›å»ºBåˆ†å­
            for (let i = 0; i < reaction.countB; i++) {
                particles.push({
                    type: 'B',
                    x: Math.random() * (config.canvasWidth - 2 * config.containerPadding) + config.containerPadding,
                    y: Math.random() * (config.canvasHeight - 2 * config.containerPadding) + config.containerPadding,
                    vx: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    vy: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    color: '#4ECDC4',
                    radius: config.particleRadius,
                    highlight: false,
                    highlightTime: 0
                });
            }
            
            // åˆ›å»ºCåˆ†å­
            for (let i = 0; i < reaction.countC; i++) {
                particles.push({
                    type: 'C',
                    x: Math.random() * (config.canvasWidth - 2 * config.containerPadding) + config.containerPadding,
                    y: Math.random() * (config.canvasHeight - 2 * config.containerPadding) + config.containerPadding,
                    vx: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    vy: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    color: '#FFD166',
                    radius: config.particleRadius,
                    highlight: false,
                    highlightTime: 0
                });
            }
        }
        
        // å¼€å§‹ååº”
        function startReaction() {
            if (!config.isRunning) {
                config.isRunning = true;
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                animate();
            }
        }
        
        // æš‚åœååº”
        function pauseReaction() {
            config.isRunning = false;
            startBtn.disabled = false;
            pauseBtn.disabled = true;
        }
        
        // é‡ç½®ååº”
        function resetReaction() {
            config.isRunning = false;
            config.isBalanced = false;
            config.time = 0;
            config.temperature = 1.0;
            config.pressure = 1.0;
            
            startBtn.disabled = false;
            pauseBtn.disabled = true;
            
            // é‡ç½®ååº”å‚æ•°
            reaction.countA = 100;
            reaction.countB = 80;
            reaction.countC = 0;
            reaction.forwardRate = 0;
            reaction.reverseRate = 0;
            reaction.k = 0;
            
            // æ¸…ç©ºå†å²æ•°æ®
            reaction.history = {
                time: [],
                countA: [],
                countB: [],
                countC: [],
                forwardRate: [],
                reverseRate: []
            };
            
            // é‡æ–°åˆ›å»ºç²’å­
            createParticles();
            
            // æ›´æ–°æ˜¾ç¤º
            updateDataDisplay();
            drawReaction();
            updateChart();
            
            // éšè—å¹³è¡¡æŒ‡ç¤ºå™¨
            balanceIndicator.style.opacity = '0';
        }
        
        // å¢åŠ ååº”ç‰©A
        function addReactantA(count) {
            if (!config.isRunning) return;
            
            // å¢åŠ Aåˆ†å­æ•°é‡
            reaction.countA += count;
            
            // æ·»åŠ æ–°çš„Aç²’å­ï¼ˆé«˜äº®æ˜¾ç¤ºï¼‰
            for (let i = 0; i < count; i++) {
                particles.push({
                    type: 'A',
                    x: Math.random() * (config.canvasWidth - 2 * config.containerPadding) + config.containerPadding,
                    y: Math.random() * (config.canvasHeight - 2 * config.containerPadding) + config.containerPadding,
                    vx: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    vy: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                    color: '#FF6B6B',
                    radius: config.particleRadius,
                    highlight: true,
                    highlightTime: 60 // é«˜äº®æ˜¾ç¤º60å¸§
                });
            }
            
            // å¹³è¡¡è¢«æ‰“ç ´
            config.isBalanced = false;
            balanceIndicator.style.opacity = '0';
            
            updateDataDisplay();
        }
        
        // å¢å¤§ç³»ç»Ÿå‹å¼ºï¼ˆå‹ç¼©å®¹å™¨ï¼‰
        function increaseSystemPressure() {
            if (!config.isRunning) return;
            
            // å¢åŠ å‹å¼ºå› å­ï¼ˆå‡å°å®¹å™¨æœ‰æ•ˆç©ºé—´ï¼‰
            config.pressure *= 0.8;
            
            // å¹³è¡¡è¢«æ‰“ç ´
            config.isBalanced = false;
            balanceIndicator.style.opacity = '0';
            
            // æ›´æ–°æ˜¾ç¤º
            updateDataDisplay();
        }
        
        // å‡é«˜ç³»ç»Ÿæ¸©åº¦
        function increaseSystemTemperature() {
            if (!config.isRunning) return;
            
            // å¢åŠ æ¸©åº¦å› å­
            config.temperature *= 1.5;
            
            // å¢åŠ æ‰€æœ‰ç²’å­çš„é€Ÿåº¦
            particles.forEach(p => {
                p.vx *= Math.sqrt(config.temperature);
                p.vy *= Math.sqrt(config.temperature);
            });
            
            // å¹³è¡¡è¢«æ‰“ç ´
            config.isBalanced = false;
            balanceIndicator.style.opacity = '0';
            
            updateDataDisplay();
        }
        
        // åˆ‡æ¢é€Ÿåº¦ç®­å¤´æ˜¾ç¤º
        function toggleVelocityArrows() {
            config.showArrows = !config.showArrows;
        }
        
        // åˆ‡æ¢å›¾è¡¨æ˜¾ç¤º
        function toggleChartVisibility() {
            config.showChart = !config.showChart;
            chartContainer.style.display = config.showChart ? 'block' : 'none';
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            if (!config.isRunning) return;
            
            // æ›´æ–°æ—¶é—´
            config.time += config.timeStep;
            
            // æ›´æ–°ç²’å­ä½ç½®
            updateParticles();
            
            // å¤„ç†åŒ–å­¦ååº”
            processReactions();
            
            // è®¡ç®—ååº”é€Ÿç‡
            calculateReactionRates();
            
            // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¹³è¡¡
            checkEquilibrium();
            
            // è®°å½•å†å²æ•°æ®
            recordHistory();
            
            // æ›´æ–°æ˜¾ç¤º
            updateDataDisplay();
            drawReaction();
            updateChart();
            
            // ç»§ç»­åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animate);
        }
        
        // æ›´æ–°ç²’å­ä½ç½®
        function updateParticles() {
            // è®¡ç®—æœ‰æ•ˆå®¹å™¨å°ºå¯¸ï¼ˆè€ƒè™‘å‹å¼ºå½±å“ï¼‰
            const effectiveWidth = config.canvasWidth * config.pressure;
            const effectiveHeight = config.canvasHeight * config.pressure;
            const offsetX = (config.canvasWidth - effectiveWidth) / 2;
            const offsetY = (config.canvasHeight - effectiveHeight) / 2;
            
            particles.forEach(p => {
                // æ›´æ–°ä½ç½®
                p.x += p.vx;
                p.y += p.vy;
                
                // è¾¹ç•Œç¢°æ’æ£€æµ‹ï¼ˆè€ƒè™‘å‹å¼ºå½±å“ï¼‰
                if (p.x - p.radius < offsetX + config.containerPadding || p.x + p.radius > offsetX + effectiveWidth - config.containerPadding) {
                    p.vx = -p.vx;
                    p.x = Math.max(offsetX + config.containerPadding + p.radius, 
                                  Math.min(offsetX + effectiveWidth - config.containerPadding - p.radius, p.x));
                }
                
                if (p.y - p.radius < offsetY + config.containerPadding || p.y + p.radius > offsetY + effectiveHeight - config.containerPadding) {
                    p.vy = -p.vy;
                    p.y = Math.max(offsetY + config.containerPadding + p.radius, 
                                  Math.min(offsetY + effectiveHeight - config.containerPadding - p.radius, p.y));
                }
                
                // æ›´æ–°é«˜äº®æ—¶é—´
                if (p.highlight && p.highlightTime > 0) {
                    p.highlightTime--;
                    if (p.highlightTime === 0) {
                        p.highlight = false;
                    }
                }
            });
        }
        
        // å¤„ç†åŒ–å­¦ååº”
        function processReactions() {
            // æ­£ååº”ï¼šA + B â†’ C
            // åŸºäºç¢°æ’æ¦‚ç‡æ¨¡æ‹Ÿååº”
            const forwardProbability = reaction.kForward * config.temperature;
            
            // æŸ¥æ‰¾Aå’ŒBåˆ†å­
            const aParticles = particles.filter(p => p.type === 'A');
            const bParticles = particles.filter(p => p.type === 'B');
            
            // éšæœºé€‰æ‹©ä¸€äº›Aå’ŒBåˆ†å­å°è¯•ååº”
            const reactionAttempts = Math.floor(forwardProbability * Math.min(aParticles.length, bParticles.length));
            
            for (let i = 0; i < reactionAttempts; i++) {
                if (aParticles.length === 0 || bParticles.length === 0) break;
                
                // éšæœºé€‰æ‹©Aå’ŒBåˆ†å­
                const aIndex = Math.floor(Math.random() * aParticles.length);
                const bIndex = Math.floor(Math.random() * bParticles.length);
                
                const aParticle = aParticles[aIndex];
                const bParticle = bParticles[bIndex];
                
                // æ£€æŸ¥æ˜¯å¦åœ¨ååº”åŠå¾„å†…ï¼ˆæ¨¡æ‹Ÿç¢°æ’ï¼‰
                const dx = aParticle.x - bParticle.x;
                const dy = aParticle.y - bParticle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < config.reactionRadius) {
                    // å‘ç”Ÿååº”ï¼šA + B â†’ C
                    // ç§»é™¤Aå’ŒBåˆ†å­
                    const aGlobalIndex = particles.indexOf(aParticle);
                    const bGlobalIndex = particles.indexOf(bParticle);
                    
                    if (aGlobalIndex !== -1 && bGlobalIndex !== -1) {
                        // ç§»é™¤Aå’ŒB
                        particles.splice(Math.max(aGlobalIndex, bGlobalIndex), 1);
                        particles.splice(Math.min(aGlobalIndex, bGlobalIndex), 1);
                        
                        // æ·»åŠ Cåˆ†å­
                        particles.push({
                            type: 'C',
                            x: (aParticle.x + bParticle.x) / 2,
                            y: (aParticle.y + bParticle.y) / 2,
                            vx: (aParticle.vx + bParticle.vx) / 2,
                            vy: (aParticle.vy + bParticle.vy) / 2,
                            color: '#FFD166',
                            radius: config.particleRadius,
                            highlight: false,
                            highlightTime: 0
                        });
                        
                        // æ›´æ–°è®¡æ•°
                        reaction.countA--;
                        reaction.countB--;
                        reaction.countC++;
                    }
                }
            }
            
            // é€†ååº”ï¼šC â†’ A + B
            const reverseProbability = reaction.kReverse * config.temperature;
            const cParticles = particles.filter(p => p.type === 'C');
            const reverseAttempts = Math.floor(reverseProbability * cParticles.length);
            
            for (let i = 0; i < reverseAttempts; i++) {
                if (cParticles.length === 0) break;
                
                // éšæœºé€‰æ‹©Cåˆ†å­
                const cIndex = Math.floor(Math.random() * cParticles.length);
                const cParticle = cParticles[cIndex];
                
                // å‘ç”Ÿé€†ååº”ï¼šC â†’ A + B
                const globalIndex = particles.indexOf(cParticle);
                
                if (globalIndex !== -1) {
                    // ç§»é™¤Cåˆ†å­
                    particles.splice(globalIndex, 1);
                    
                    // æ·»åŠ Aå’ŒBåˆ†å­
                    particles.push({
                        type: 'A',
                        x: cParticle.x + (Math.random() - 0.5) * 20,
                        y: cParticle.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                        vy: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                        color: '#FF6B6B',
                        radius: config.particleRadius,
                        highlight: false,
                        highlightTime: 0
                    });
                    
                    particles.push({
                        type: 'B',
                        x: cParticle.x + (Math.random() - 0.5) * 20,
                        y: cParticle.y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                        vy: (Math.random() - 0.5) * config.baseSpeed * config.temperature,
                        color: '#4ECDC4',
                        radius: config.particleRadius,
                        highlight: false,
                        highlightTime: 0
                    });
                    
                    // æ›´æ–°è®¡æ•°
                    reaction.countA++;
                    reaction.countB++;
                    reaction.countC--;
                }
            }
        }
        
        // è®¡ç®—ååº”é€Ÿç‡
        function calculateReactionRates() {
            // æ­£ååº”é€Ÿç‡ = k_forward * [A] * [B]
            // è¿™é‡Œä½¿ç”¨åˆ†å­æ•°é‡è¿‘ä¼¼æµ“åº¦
            const forwardRate = reaction.kForward * reaction.countA * reaction.countB * config.temperature;
            
            // é€†ååº”é€Ÿç‡ = k_reverse * [C]
            const reverseRate = reaction.kReverse * reaction.countC * config.temperature;
            
            reaction.forwardRate = forwardRate;
            reaction.reverseRate = reverseRate;
            
            // è®¡ç®—å¹³è¡¡å¸¸æ•° K = [C] / ([A] * [B])
            if (reaction.countA > 0 && reaction.countB > 0) {
                reaction.k = reaction.countC / (reaction.countA * reaction.countB);
            } else {
                reaction.k = 0;
            }
        }
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°å¹³è¡¡
        function checkEquilibrium() {
            const rateDifference = Math.abs(reaction.forwardRate - reaction.reverseRate);
            const rateSum = reaction.forwardRate + reaction.reverseRate;
            
            if (rateSum > 0 && rateDifference / rateSum < config.equilibriumThreshold) {
                if (!config.isBalanced) {
                    config.isBalanced = true;
                    balanceIndicator.style.opacity = '1';
                }
            } else {
                if (config.isBalanced) {
                    config.isBalanced = false;
                    balanceIndicator.style.opacity = '0';
                }
            }
        }
        
        // è®°å½•å†å²æ•°æ®
        function recordHistory() {
            // æ·»åŠ å½“å‰æ•°æ®ç‚¹
            reaction.history.time.push(config.time);
            reaction.history.countA.push(reaction.countA);
            reaction.history.countB.push(reaction.countB);
            reaction.history.countC.push(reaction.countC);
            reaction.history.forwardRate.push(reaction.forwardRate);
            reaction.history.reverseRate.push(reaction.reverseRate);
            
            // é™åˆ¶å†å²æ•°æ®é•¿åº¦
            if (reaction.history.time.length > config.maxHistory) {
                reaction.history.time.shift();
                reaction.history.countA.shift();
                reaction.history.countB.shift();
                reaction.history.countC.shift();
                reaction.history.forwardRate.shift();
                reaction.history.reverseRate.shift();
            }
        }
        
        // æ›´æ–°æ•°æ®æ˜¾ç¤º
        function updateDataDisplay() {
            countAElement.textContent = reaction.countA;
            countBElement.textContent = reaction.countB;
            countCElement.textContent = reaction.countC;
            kValueElement.textContent = reaction.k.toFixed(4);
            forwardRateElement.textContent = reaction.forwardRate.toFixed(2);
            reverseRateElement.textContent = reaction.reverseRate.toFixed(2);
        }
        
        // ç»˜åˆ¶ååº”åœºæ™¯
        function drawReaction() {
            // æ¸…é™¤ç”»å¸ƒ
            reactionCtx.clearRect(0, 0, config.canvasWidth, config.canvasHeight);
            
            // ç»˜åˆ¶å®¹å™¨èƒŒæ™¯
            reactionCtx.fillStyle = '#F7F9FC';
            reactionCtx.fillRect(0, 0, config.canvasWidth, config.canvasHeight);
            
            // è®¡ç®—æœ‰æ•ˆå®¹å™¨å°ºå¯¸ï¼ˆè€ƒè™‘å‹å¼ºå½±å“ï¼‰
            const effectiveWidth = config.canvasWidth * config.pressure;
            const effectiveHeight = config.canvasHeight * config.pressure;
            const offsetX = (config.canvasWidth - effectiveWidth) / 2;
            const offsetY = (config.canvasHeight - effectiveHeight) / 2;
            
            // ç»˜åˆ¶å®¹å™¨è¾¹æ¡†
            reactionCtx.strokeStyle = '#2E86AB';
            reactionCtx.lineWidth = 3;
            reactionCtx.strokeRect(
                offsetX + config.containerPadding, 
                offsetY + config.containerPadding, 
                effectiveWidth - 2 * config.containerPadding, 
                effectiveHeight - 2 * config.containerPadding
            );
            
            // ç»˜åˆ¶æ‰€æœ‰ç²’å­
            particles.forEach(p => {
                // ç»˜åˆ¶ç²’å­
                reactionCtx.beginPath();
                reactionCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                
                // è®¾ç½®é¢œè‰²ï¼ˆé«˜äº®ç²’å­ç”¨æ›´äº®çš„é¢œè‰²ï¼‰
                if (p.highlight) {
                    reactionCtx.fillStyle = p.type === 'A' ? '#FF9999' : 
                                           p.type === 'B' ? '#7CECDF' : '#FFE299';
                } else {
                    reactionCtx.fillStyle = p.color;
                }
                
                reactionCtx.fill();
                
                // ç»˜åˆ¶ç²’å­è¾¹æ¡†
                reactionCtx.strokeStyle = '#2C3E50';
                reactionCtx.lineWidth = 1;
                reactionCtx.stroke();
                
                // ç»˜åˆ¶é€Ÿç‡ç®­å¤´ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (config.showArrows) {
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                    if (speed > 0.1) {
                        const arrowLength = speed * 10;
                        const angle = Math.atan2(p.vy, p.vx);
                        
                        reactionCtx.beginPath();
                        reactionCtx.moveTo(p.x, p.y);
                        reactionCtx.lineTo(
                            p.x + Math.cos(angle) * arrowLength,
                            p.y + Math.sin(angle) * arrowLength
                        );
                        reactionCtx.strokeStyle = '#2C3E50';
                        reactionCtx.lineWidth = 1.5;
                        reactionCtx.stroke();
                        
                        // ç»˜åˆ¶ç®­å¤´å¤´éƒ¨
                        reactionCtx.beginPath();
                        reactionCtx.moveTo(
                           
<!--æ£€æµ‹åˆ°ä»£ç æˆªæ–­ï¼Œè‡ªåŠ¨ç»­å†™ä¸­...-->
p.x + Math.cos(angle) * arrowLength,
                            p.y + Math.sin(angle) * arrowLength
                        );
                        reactionCtx.lineTo(
                            p.x + Math.cos(angle - Math.PI/6) * arrowLength * 0.5,
                            p.y + Math.sin(angle - Math.PI/6) * arrowLength * 0.5
                        );
                        reactionCtx.lineTo(
                            p.x + Math.cos(angle + Math.PI/6) * arrowLength * 0.5,
                            p.y + Math.sin(angle + Math.PI/6) * arrowLength * 0.5
                        );
                        reactionCtx.closePath();
                        reactionCtx.fillStyle = '#2C3E50';
                        reactionCtx.fill();
                    }
                }
            });
            
            // ç»˜åˆ¶ååº”é€Ÿç‡æ–‡æœ¬
            reactionCtx.fillStyle = '#2C3E50';
            reactionCtx.font = '14px Arial';
            reactionCtx.fillText(`æ¸©åº¦å› å­: ${config.temperature.toFixed(2)}`, 10, 20);
            reactionCtx.fillText(`å‹å¼ºå› å­: ${config.pressure.toFixed(2)}`, 10, 40);
            reactionCtx.fillText(`æ€»åˆ†å­æ•°: ${particles.length}`, 10, 60);
        }
        
        // æ›´æ–°å›¾è¡¨
        function updateChart() {
            const chartWidth = chartCtx.canvas.width;
            const chartHeight = chartCtx.canvas.height;
            const padding = {top: 30, right: 30, bottom: 50, left: 60};
            const graphWidth = chartWidth - padding.left - padding.right;
            const graphHeight = chartHeight - padding.top - padding.bottom;
            
            // æ¸…é™¤å›¾è¡¨
            chartCtx.clearRect(0, 0, chartWidth, chartHeight);
            
            // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œä¸ç»˜åˆ¶
            if (reaction.history.time.length < 2) return;
            
            // è·å–æ•°æ®èŒƒå›´
            const times = reaction.history.time;
            const countAs = reaction.history.countA;
            const countBs = reaction.history.countB;
            const countCs = reaction.history.countC;
            const forwardRates = reaction.history.forwardRate;
            const reverseRates = reaction.history.reverseRate;
            
            // è®¡ç®—Yè½´èŒƒå›´ï¼ˆåˆ†å­æ•°é‡ï¼‰
            const allCounts = [...countAs, ...countBs, ...countCs];
            const maxCount = Math.max(...allCounts);
            const minCount = 0;
            
            // è®¡ç®—Yè½´èŒƒå›´ï¼ˆååº”é€Ÿç‡ï¼‰
            const allRates = [...forwardRates, ...reverseRates];
            const maxRate = Math.max(...allRates, 1);
            
            // ç»˜åˆ¶ç½‘æ ¼å’Œåæ ‡è½´
            drawChartAxes(padding, graphWidth, graphHeight, times, maxCount, maxRate);
            
            // ç»˜åˆ¶æ›²çº¿
            drawChartCurve(times, countAs, '#FF6B6B', padding, graphWidth, graphHeight, maxCount, false);
            drawChartCurve(times, countBs, '#4ECDC4', padding, graphWidth, graphHeight, maxCount, false);
            drawChartCurve(times, countCs, '#FFD166', padding, graphWidth, graphHeight, maxCount, false);
            
            // ç»˜åˆ¶ååº”é€Ÿç‡æ›²çº¿ï¼ˆä½¿ç”¨æ¬¡Yè½´ï¼‰
            drawChartCurve(times, forwardRates, '#A23B72', padding, graphWidth, graphHeight, maxRate, true);
            drawChartCurve(times, reverseRates, '#2E86AB', padding, graphWidth, graphHeight, maxRate, true);
        }
        
        // ç»˜åˆ¶å›¾è¡¨åæ ‡è½´å’Œç½‘æ ¼
        function drawChartAxes(padding, graphWidth, graphHeight, times, maxCount, maxRate) {
            // ç»˜åˆ¶èƒŒæ™¯
            chartCtx.fillStyle = '#FFFFFF';
            chartCtx.fillRect(0, 0, chartCtx.canvas.width, chartCtx.canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼
            chartCtx.strokeStyle = '#E0E0E0';
            chartCtx.lineWidth = 0.5;
            
            // æ°´å¹³ç½‘æ ¼çº¿ï¼ˆåˆ†å­æ•°é‡ï¼‰
            const yGridLines = 5;
            for (let i = 0; i <= yGridLines; i++) {
                const y = padding.top + graphHeight - (i / yGridLines) * graphHeight;
                chartCtx.beginPath();
                chartCtx.moveTo(padding.left, y);
                chartCtx.lineTo(padding.left + graphWidth, y);
                chartCtx.stroke();
                
                // Yè½´æ ‡ç­¾ï¼ˆåˆ†å­æ•°é‡ï¼‰
                chartCtx.fillStyle = '#5D6D7E';
                chartCtx.font = '12px Arial';
                chartCtx.textAlign = 'right';
                chartCtx.fillText(Math.round((i / yGridLines) * maxCount).toString(), padding.left - 10, y + 4);
            }
            
            // æ°´å¹³ç½‘æ ¼çº¿ï¼ˆååº”é€Ÿç‡ï¼Œæ¬¡Yè½´ï¼‰
            const yRateGridLines = 5;
            for (let i = 0; i <= yRateGridLines; i++) {
                const y = padding.top + graphHeight - (i / yRateGridLines) * graphHeight;
                // åªåœ¨å³ä¾§ç»˜åˆ¶é€Ÿç‡æ ‡ç­¾
                chartCtx.fillStyle = '#5D6D7E';
                chartCtx.font = '12px Arial';
                chartCtx.textAlign = 'left';
                chartCtx.fillText((i / yRateGridLines * maxRate).toFixed(1), padding.left + graphWidth + 10, y + 4);
            }
            
            // å‚ç›´ç½‘æ ¼çº¿
            const xGridLines = 10;
            for (let i = 0; i <= xGridLines; i++) {
                const x = padding.left + (i / xGridLines) * graphWidth;
                chartCtx.beginPath();
                chartCtx.moveTo(x, padding.top);
                chartCtx.lineTo(x, padding.top + graphHeight);
                chartCtx.stroke();
                
                // Xè½´æ ‡ç­¾ï¼ˆæ—¶é—´ï¼‰
                if (times.length > 0) {
                    const maxTime = times[times.length - 1];
                    const timeValue = (i / xGridLines) * maxTime;
                    chartCtx.fillStyle = '#5D6D7E';
                    chartCtx.font = '12px Arial';
                    chartCtx.textAlign = 'center';
                    chartCtx.fillText(timeValue.toFixed(1), x, padding.top + graphHeight + 20);
                }
            }
            
            // ç»˜åˆ¶åæ ‡è½´
            chartCtx.strokeStyle = '#2C3E50';
            chartCtx.lineWidth = 2;
            
            // Yè½´ï¼ˆåˆ†å­æ•°é‡ï¼‰
            chartCtx.beginPath();
            chartCtx.moveTo(padding.left, padding.top);
            chartCtx.lineTo(padding.left, padding.top + graphHeight);
            chartCtx.stroke();
            
            // Yè½´ï¼ˆååº”é€Ÿç‡ï¼Œå³ä¾§ï¼‰
            chartCtx.beginPath();
            chartCtx.moveTo(padding.left + graphWidth, padding.top);
            chartCtx.lineTo(padding.left + graphWidth, padding.top + graphHeight);
            chartCtx.stroke();
            
            // Xè½´
            chartCtx.beginPath();
            chartCtx.moveTo(padding.left, padding.top + graphHeight);
            chartCtx.lineTo(padding.left + graphWidth, padding.top + graphHeight);
            chartCtx.stroke();
            
            // åæ ‡è½´æ ‡ç­¾
            chartCtx.fillStyle = '#2C3E50';
            chartCtx.font = 'bold 14px Arial';
            chartCtx.textAlign = 'center';
            
            // Xè½´æ ‡ç­¾
            chartCtx.fillText('æ—¶é—´ (s)', padding.left + graphWidth / 2, padding.top + graphHeight + 40);
            
            // Yè½´æ ‡ç­¾ï¼ˆå·¦ä¾§ï¼Œåˆ†å­æ•°é‡ï¼‰
            chartCtx.save();
            chartCtx.translate(20, padding.top + graphHeight / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.textAlign = 'center';
            chartCtx.fillText('åˆ†å­æ•°é‡', 0, 0);
            chartCtx.restore();
            
            // Yè½´æ ‡ç­¾ï¼ˆå³ä¾§ï¼Œååº”é€Ÿç‡ï¼‰
            chartCtx.save();
            chartCtx.translate(padding.left + graphWidth + 40, padding.top + graphHeight / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.textAlign = 'center';
            chartCtx.fillText('ååº”é€Ÿç‡', 0, 0);
            chartCtx.restore();
        }
        
        // ç»˜åˆ¶å›¾è¡¨æ›²çº¿
        function drawChartCurve(times, values, color, padding, graphWidth, graphHeight, maxValue, isRate) {
            if (times.length === 0 || values.length === 0) return;
            
            const maxTime = times[times.length - 1];
            
            // å¼€å§‹ç»˜åˆ¶è·¯å¾„
            chartCtx.beginPath();
            
            // ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ªç‚¹
            const firstX = padding.left + (times[0] / maxTime) * graphWidth;
            const firstY = isRate ? 
                padding.top + graphHeight - (values[0] / maxValue) * graphHeight :
                padding.top + graphHeight - (values[0] / maxValue) * graphHeight;
            
            chartCtx.moveTo(firstX, firstY);
            
            // ç»˜åˆ¶æ›²çº¿
            for (let i = 1; i < times.length; i++) {
                const x = padding.left + (times[i] / maxTime) * graphWidth;
                const y = isRate ? 
                    padding.top + graphHeight - (values[i] / maxValue) * graphHeight :
                    padding.top + graphHeight - (values[i] / maxValue) * graphHeight;
                
                // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿å¹³æ»‘è¿æ¥ç‚¹
                const prevX = padding.left + (times[i-1] / maxTime) * graphWidth;
                const prevY = isRate ? 
                    padding.top + graphHeight - (values[i-1] / maxValue) * graphHeight :
                    padding.top + graphHeight - (values[i-1] / maxValue) * graphHeight;
                
                const cpX = (prevX + x) / 2;
                const cpY1 = prevY;
                const cpY2 = y;
                
                chartCtx.quadraticCurveTo(cpX, cpY1, cpX, cpY1);
                chartCtx.quadraticCurveTo(cpX, cpY2, x, y);
            }
            
            // è®¾ç½®çº¿æ¡æ ·å¼
            chartCtx.strokeStyle = color;
            chartCtx.lineWidth = 2.5;
            chartCtx.stroke();
            
            // æ·»åŠ æ•°æ®ç‚¹ï¼ˆæ¯éš”ä¸€å®šé—´éš”ï¼‰
            chartCtx.fillStyle = color;
            for (let i = 0; i < times.length; i += Math.floor(times.length / 15)) {
                const x = padding.left + (times[i] / maxTime) * graphWidth;
                const y = isRate ? 
                    padding.top + graphHeight - (values[i] / maxValue) * graphHeight :
                    padding.top + graphHeight - (values[i] / maxValue) * graphHeight;
                
                chartCtx.beginPath();
                chartCtx.arc(x, y, 3, 0, Math.PI * 2);
                chartCtx.fill();
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', init);
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è°ƒæ•´Canvas
        window.addEventListener('resize', function() {
            if (config.isRunning) {
                pauseReaction();
            }
            init();
        });
    </script>
</body>
</html>