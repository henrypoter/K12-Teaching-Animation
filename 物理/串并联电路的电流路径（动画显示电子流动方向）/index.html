<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>串并联电路电流路径教学动画</title>
    <style>
        /* 样式保持不变 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .header {
            text-align: center;
            margin-bottom: 25px;
            padding: 15px;
            border-bottom: 2px solid #3b82f6;
            width: 100%;
            max-width: 1000px;
        }
        
        h1 {
            color: #60a5fa;
            font-size: 2.2rem;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            max-width: 1200px;
            width: 100%;
            justify-content: center;
        }
        
        .animation-panel {
            flex: 1;
            min-width: 600px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid #475569;
        }
        
        .control-panel {
            flex: 0 0 320px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid #475569;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background-color: #1e293b;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #475569;
        }
        
        #circuitCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .panel-title {
            color: #38bdf8;
            font-size: 1.4rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #475569;
        }
        
        .control-group {
            background: rgba(51, 65, 85, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .control-group h3 {
            color: #7dd3fc;
            margin-bottom: 12px;
            font-size: 1.1rem;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background: #10b981;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .toggle-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .toggle-label {
            font-size: 0.95rem;
            color: #cbd5e1;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #10b981;
        }
        
        input:checked + .slider:before {
            transform: translateX(24px);
        }
        
        .info-display {
            background: rgba(51, 65, 85, 0.5);
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px dashed #475569;
        }
        
        .info-label {
            color: #94a3b8;
        }
        
        .info-value {
            color: #fbbf24;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #475569;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .explanation {
            max-width: 1000px;
            margin-top: 25px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border: 1px solid #475569;
        }
        
        .explanation h3 {
            color: #38bdf8;
            margin-bottom: 10px;
        }
        
        .explanation p {
            line-height: 1.6;
            margin-bottom: 10px;
            color: #cbd5e1;
        }
        
        @media (max-width: 1000px) {
            .container {
                flex-direction: column;
            }
            
            .animation-panel, .control-panel {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>串并联电路电流路径教学动画</h1>
        <p class="subtitle">可视化电子流动方向与电流路径 - 交互式学习工具</p>
    </div>
    
    <div class="container">
        <div class="animation-panel">
            <h2 class="panel-title">电路动画演示</h2>
            <div class="canvas-container">
                <canvas id="circuitCanvas"></canvas>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #60a5fa;"></div>
                    <span>电子流动方向（实际方向）</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f87171;"></div>
                    <span>电流方向（规定方向）</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #10b981;"></div>
                    <span>电源正极</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #475569;"></div>
                    <span>电源负极</span>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <h2 class="panel-title">控制面板</h2>
            
            <div class="control-group">
                <h3>电路控制</h3>
                <div class="button-group">
                    <button id="playBtn">▶ 播放</button>
                    <button id="pauseBtn">⏸ 暂停</button>
                    <button id="resetBtn">↺ 重置</button>
                </div>
                <div class="toggle-group">
                    <span class="toggle-label">电路开关</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="circuitSwitch" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="control-group">
                <h3>电路类型</h3>
                <div class="button-group">
                    <button id="seriesBtn" class="active">串联电路</button>
                    <button id="parallelBtn">并联电路</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>可视化模式</h3>
                <div class="button-group">
                    <button id="electronFlowBtn" class="active">电子流（实际方向）</button>
                    <button id="currentFlowBtn">电流方向（规定方向）</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>信息显示</h3>
                <div class="toggle-group">
                    <span class="toggle-label">显示电子计数器</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="counterToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="toggle-group">
                    <span class="toggle-label">显示电流表读数</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="ammeterToggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="info-display">
                <h3>电路信息</h3>
                <div class="info-item">
                    <span class="info-label">电路类型：</span>
                    <span id="circuitType" class="info-value">串联电路</span>
                </div>
                <div class="info-item">
                    <span class="info-label">可视化模式：</span>
                    <span id="visualizationMode" class="info-value">电子流方向</span>
                </div>
                <div class="info-item">
                    <span class="info-label">电路状态：</span>
                    <span id="circuitStatus" class="info-value">通路</span>
                </div>
                <div class="info-item">
                    <span class="info-label">干路电流：</span>
                    <span id="mainCurrent" class="info-value">1.0 A</span>
                </div>
                <div class="info-item">
                    <span class="info-label">支路1电流：</span>
                    <span id="branch1Current" class="info-value">1.0 A</span>
                </div>
                <div class="info-item">
                    <span class="info-label">支路2电流：</span>
                    <span id="branch2Current" class="info-value">0.5 A</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="explanation">
        <h3>学习要点</h3>
        <p>1. <strong>串联电路</strong>：电流只有一条路径，电子依次通过各个元件，电流处处相等。</p>
        <p>2. <strong>并联电路</strong>：电流有多个路径（支路），电子在分支点分开流动，干路电流等于各支路电流之和。</p>
        <p>3. <strong>电子流方向</strong>：电子带负电，从电源负极流向正极（实际方向）。</p>
        <p>4. <strong>电流方向</strong>：物理学规定正电荷移动方向为电流方向，从电源正极流向负极（规定方向）。</p>
        <p>5. 使用控制面板切换不同模式，观察电子流动路径和电流分配规律。</p>
    </div>

    <script>
        // 获取Canvas元素和上下文
        const canvas = document.getElementById('circuitCanvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸以匹配显示尺寸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // 初始化时设置尺寸
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 电路状态变量
        let circuitType = 'series'; // 'series' 或 'parallel'
        let visualizationMode = 'electron'; // 'electron' 或 'current'
        let isPlaying = true;
        let circuitClosed = true;
        let showCounters = true;
        let showAmmeters = true;
        
        // 电子/电流粒子
        let particles = [];
        let particleId = 0;
        
        // 电流值（模拟）
        let mainCurrent = 1.0;
        let branch1Current = 1.0;
        let branch2Current = 0.5;
        
        // 电路元件坐标定义（响应式缩放）
        function getScaledCoords() {
            const scale = Math.min(canvas.width / 800, canvas.height / 500);
            const baseScale = 0.8; // 基础缩放比例
            
            return {
                // 串联电路坐标
                series: {
                    battery: {x: 150 * scale * baseScale, y: 250 * scale * baseScale, width: 60 * scale * baseScale, height: 100 * scale * baseScale},
                    resistor1: {x: 350 * scale * baseScale, y: 200 * scale * baseScale, width: 80 * scale * baseScale, height: 30 * scale * baseScale},
                    resistor2: {x: 550 * scale * baseScale, y: 200 * scale * baseScale, width: 80 * scale * baseScale, height: 30 * scale * baseScale},
                    switch: {x: 450 * scale * baseScale, y: 300 * scale * baseScale, width: 40 * scale * baseScale, height: 20 * scale * baseScale},
                    wires: [
                        // 电池到电阻1
                        {x1: 210 * scale * baseScale, y1: 250 * scale * baseScale, x2: 350 * scale * baseScale, y2: 250 * scale * baseScale},
                        // 电阻1到电阻2
                        {x1: 430 * scale * baseScale, y1: 250 * scale * baseScale, x2: 550 * scale * baseScale, y2: 250 * scale * baseScale},
                        // 电阻2到开关
                        {x1: 630 * scale * baseScale, y1: 250 * scale * baseScale, x2: 670 * scale * baseScale, y2: 250 * scale * baseScale},
                        {x1: 670 * scale * baseScale, y1: 250 * scale * baseScale, x2: 670 * scale * baseScale, y2: 300 * scale * baseScale},
                        // 开关回电池
                        {x1: 470 * scale * baseScale, y1: 300 * scale * baseScale, x2: 530 * scale * baseScale, y2: 300 * scale * baseScale},
                        {x1: 530 * scale * baseScale, y1: 300 * scale * baseScale, x2: 530 * scale * baseScale, y2: 350 * scale * baseScale},
                        {x1: 530 * scale * baseScale, y1: 350 * scale * baseScale, x2: 150 * scale * baseScale, y2: 350 * scale * baseScale},
                        {x1: 150 * scale * baseScale, y1: 350 * scale * baseScale, x2: 150 * scale * baseScale, y2: 300 * scale * baseScale}
                    ],
                    // 粒子路径点
                    particlePath: [
                        {x: 180 * scale * baseScale, y: 300 * scale * baseScale}, // 电池负极开始
                        {x: 210 * scale * baseScale, y: 250 * scale * baseScale}, {x: 350 * scale * baseScale, y: 250 * scale * baseScale}, // 到电阻1
                        {x: 430 * scale * baseScale, y: 250 * scale * baseScale}, {x: 550 * scale * baseScale, y: 250 * scale * baseScale}, // 到电阻2
                        {x: 630 * scale * baseScale, y: 250 * scale * baseScale}, {x: 670 * scale * baseScale, y: 250 * scale * baseScale}, {x: 670 * scale * baseScale, y: 300 * scale * baseScale}, // 到开关
                        {x: 470 * scale * baseScale, y: 300 * scale * baseScale}, // 开关（如果闭合）
                        {x: 530 * scale * baseScale, y: 300 * scale * baseScale}, {x: 530 * scale * baseScale, y: 350 * scale * baseScale}, // 回电池
                        {x: 150 * scale * baseScale, y: 350 * scale * baseScale}, {x: 150 * scale * baseScale, y: 300 * scale * baseScale} // 回电池正极
                    ]
                },
                // 并联电路坐标
                parallel: {
                    battery: {x: 150 * scale * baseScale, y: 250 * scale * baseScale, width: 60 * scale * baseScale, height: 100 * scale * baseScale},
                    resistor1: {x: 400 * scale * baseScale, y: 150 * scale * baseScale, width: 80 * scale * baseScale, height: 30 * scale * baseScale},
                    resistor2: {x: 400 * scale * baseScale, y: 350 * scale * baseScale, width: 80 * scale * baseScale, height: 30 * scale * baseScale},
                    switch: {x: 300 * scale * baseScale, y: 250 * scale * baseScale, width: 40 * scale * baseScale, height: 20 * scale * baseScale},
                    wires: [
                        // 电池到分支点A
                        {x1: 210 * scale * baseScale, y1: 250 * scale * baseScale, x2: 300 * scale * baseScale, y2: 250 * scale * baseScale},
                        // 分支点A到电阻1
                        {x1: 300 * scale * baseScale, y1: 250 * scale * baseScale, x2: 300 * scale * baseScale, y2: 150 * scale * baseScale},
                        {x1: 300 * scale * baseScale, y1: 150 * scale * baseScale, x2: 400 * scale * baseScale, y2: 150 * scale * baseScale},
                        // 分支点A到电阻2
                        {x1: 300 * scale * baseScale, y1: 250 * scale * baseScale, x2: 300 * scale * baseScale, y2: 350 * scale * baseScale},
                        {x1: 300 * scale * baseScale, y1: 350 * scale * baseScale, x2: 400 * scale * baseScale, y2: 350 * scale * baseScale},
                        // 电阻1到汇合点B
                        {x1: 480 * scale * baseScale, y1: 150 * scale * baseScale, x2: 600 * scale * baseScale, y2: 150 * scale * baseScale},
                        {x1: 600 * scale * baseScale, y1: 150 * scale * baseScale, x2: 600 * scale * baseScale, y2: 250 * scale * baseScale},
                        // 电阻2到汇合点B
                        {x1: 480 * scale * baseScale, y1: 350 * scale * baseScale, x2: 600 * scale * baseScale, y2: 350 * scale * baseScale},
                        {x1: 600 * scale * baseScale, y1: 350 * scale * baseScale, x2: 600 * scale * baseScale, y2: 250 * scale * baseScale},
                        // 汇合点B到开关
                        {x1: 600 * scale * baseScale, y1: 250 * scale * baseScale, x2: 640 * scale * baseScale, y2: 250 * scale * baseScale},
                        // 开关回电池
                        {x1: 340 * scale * baseScale, y1: 250 * scale * baseScale, x2: 400 * scale * baseScale, y2: 250 * scale * baseScale},
                        {x1: 400 * scale * baseScale, y1: 250 * scale * baseScale, x2: 400 * scale * baseScale, y2: 300 * scale * baseScale},
                        {x1: 400 * scale * baseScale, y1: 300 * scale * baseScale, x2: 150 * scale * baseScale, y2: 300 * scale * baseScale},
                        {x1: 150 * scale * baseScale, y1: 300 * scale * baseScale, x2: 150 * scale * baseScale, y2: 300 * scale * baseScale}
                    ],
                    // 粒子路径点（两条路径）
                    particlePath1: [ // 通过电阻1的路径
                        {x: 180 * scale * baseScale, y: 300 * scale * baseScale}, // 电池负极开始
                        {x: 210 * scale * baseScale, y: 250 * scale * baseScale}, {x: 300 * scale * baseScale, y: 250 * scale * baseScale}, // 到分支点A
                        {x: 300 * scale * baseScale, y: 150 * scale * baseScale}, {x: 400 * scale * baseScale, y: 150 * scale * baseScale}, // 到电阻1
                        {x: 480 * scale * baseScale, y: 150 * scale * baseScale}, {x: 600 * scale * baseScale, y: 150 * scale * baseScale}, {x: 600 * scale * baseScale, y: 250 * scale * baseScale}, // 到汇合点B
                        {x: 640 * scale * baseScale, y: 250 * scale * baseScale}, // 到开关
                        {x: 340 * scale * baseScale, y: 250 * scale * baseScale}, // 开关（如果闭合）
                        {x: 400 * scale * baseScale, y: 250 * scale * baseScale}, {x: 400 * scale * baseScale, y: 300 * scale * baseScale}, // 回电池
                        {x: 150 * scale * baseScale, y: 300 * scale * baseScale} // 回电池正极
                    ],
                    particlePath2: [ // 通过电阻2的路径
                        {x: 180 * scale * baseScale, y: 300 * scale * baseScale}, // 电池负极开始
                        {x: 210 * scale * baseScale, y: 250 * scale * baseScale}, {x: 300 * scale * baseScale, y: 250 * scale * baseScale}, // 到分支点A
                        {x: 300 * scale * baseScale, y: 350 * scale * baseScale}, {x: 400 * scale * baseScale, y: 350 * scale * baseScale}, // 到电阻2
                        {x: 480 * scale * baseScale, y: 350 * scale * baseScale}, {x: 600 * scale * baseScale, y: 350 * scale * baseScale}, {x: 600 * scale * baseScale, y: 250 * scale * baseScale}, // 到汇合点B
                        {x: 640 * scale * baseScale, y: 250 * scale * baseScale}, // 到开关
                        {x: 340 * scale * baseScale, y: 250 * scale * baseScale}, // 开关（如果闭合）
                        {x: 400 * scale * baseScale, y: 250 * scale * baseScale}, {x: 400 * scale * baseScale, y: 300 * scale * baseScale}, // 回电池
                        {x: 150 * scale * baseScale, y: 300 * scale * baseScale} // 回电池正极
                    ]
                }
            };
        }
        
        // 粒子类 - 修复路径处理逻辑
        class Particle {
            constructor(path, speed, isElectron = true) {
                this.id = particleId++;
                this.path = path;
                this.currentSegmentIndex = 0; // 改为段索引而不是点索引
                this.segmentProgress = 0; // 当前段的进度
                this.x = path[0].x;
                this.y = path[0].y;
                this.speed = speed;
                this.isElectron = isElectron;
                this.color = isElectron ? '#60a5fa' : '#f87171';
                this.radius = isElectron ? 6 : 5;
                this.branch = path === circuitCoords.parallel?.particlePath2 ? 2 : 1;
            }
            
            update() {
                if (!circuitClosed || !isPlaying) return;
                
                // 确保有下一个段可以移动
                if (this.currentSegmentIndex >= this.path.length - 1) {
                    // 到达路径终点，重新开始
                    this.currentSegmentIndex = 0;
                    this.segmentProgress = 0;
                    this.x = this.path[0].x;
                    this.y = this.path[0].y;
                    return;
                }
                
                // 获取当前段
                const startPoint = this.path[this.currentSegmentIndex];
                const endPoint = this.path[this.currentSegmentIndex + 1];
                
                // 计算段长度
                const dx = endPoint.x - startPoint.x;
                const dy = endPoint.y - startPoint.y;
                const segmentLength = Math.sqrt(dx * dx + dy * dy);
                
                // 更新段进度
                this.segmentProgress += this.speed / segmentLength;
                
                if (this.segmentProgress >= 1) {
                    // 移动到下一段
                    this.segmentProgress = 0;
                    this.currentSegmentIndex++;
                    
                    // 如果到达最后一段的末尾，重新开始
                    if (this.currentSegmentIndex >= this.path.length - 1) {
                        this.currentSegmentIndex = 0;
                        this.x = this.path[0].x;
                        this.y = this.path[0].y;
                        return;
                    }
                }
                
                // 计算当前位置
                const currentStart = this.path[this.currentSegmentIndex];
                const currentEnd = this.path[this.currentSegmentIndex + 1];
                
                this.x = currentStart.x + (currentEnd.x - currentStart.x) * this.segmentProgress;
                this.y = currentStart.y + (currentEnd.y - currentStart.y) * this.segmentProgress;
            }
            
            draw() {
                // 绘制粒子
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // 如果是电子，绘制负号
                if (this.isElectron) {
                    ctx.beginPath();
                    ctx.moveTo(this.x - 3, this.y);
                    ctx.lineTo(this.x + 3, this.y);
                    ctx.strokeStyle = '#1e293b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 电子光晕效果
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, this.radius,
                        this.x, this.y, this.radius * 2
                    );
                    gradient.addColorStop(0, 'rgba(96, 165, 250, 0.8)');
                    gradient.addColorStop(1, 'rgba(96, 165, 250, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }
        }
        
        // 获取当前缩放的坐标
        let circuitCoords = getScaledCoords();
        
        // 初始化粒子
        function initParticles() {
            particles = [];
            particleId = 0;
            circuitCoords = getScaledCoords(); // 更新坐标
            
            if (circuitType === 'series') {
                // 串联电路：创建一条路径上的粒子
                for (let i = 0; i < 15; i++) {
                    const path = [...circuitCoords.series.particlePath];
                    const speed = 0.02 + Math.random() * 0.01;
                    const delay = i * 50; // 毫秒延迟
                    
                    // 延迟启动粒子
                    setTimeout(() => {
                        particles.push(new Particle(path, speed, visualizationMode === 'electron'));
                    }, delay);
                }
            } else {
                // 并联电路：创建两条路径上的粒子
                // 路径1（通过电阻1）的粒子
                for (let i = 0; i < 10; i++) {
                    const path = [...circuitCoords.parallel.particlePath1];
                    const speed = 0.02 + Math.random() * 0.01;
                    const delay = i * 70;
                    
                    setTimeout(() => {
                        particles.push(new Particle(path, speed, visualizationMode === 'electron'));
                    }, delay);
                }
                
                // 路径2（通过电阻2）的粒子
                for (let i = 0; i < 5; i++) {
                    const path = [...circuitCoords.parallel.particlePath2];
                    const speed = 0.015 + Math.random() * 0.01;
                    const delay = i * 100;
                    
                    setTimeout(() => {
                        particles.push(new Particle(path, speed, visualizationMode === 'electron'));
                    }, delay);
                }
            }
        }
        
        // 绘制电路
        function drawCircuit() {
            circuitCoords = getScaledCoords(); // 确保坐标是最新的
            const coords = circuitCoords[circuitType];
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制导线
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#94a3b8';
            
            coords.wires.forEach(wire => {
                ctx.beginPath();
                ctx.moveTo(wire.x1, wire.y1);
                ctx.lineTo(wire.x2, wire.y2);
                ctx.stroke();
            });
            
            // 绘制高亮导线（电子流动路径）
            if (isPlaying && circuitClosed) {
                ctx.lineWidth = 6;
                ctx.strokeStyle = visualizationMode === 'electron' ? 'rgba(96, 165, 250, 0.7)' : 'rgba(248, 113, 113, 0.7)';
                
                // 根据电路类型绘制不同路径
                if (circuitType === 'series') {
                    // 串联电路：绘制完整路径
                    ctx.beginPath();
                    ctx.moveTo(coords.particlePath[0].x, coords.particlePath[0].y);
                    
                    for (let i = 1; i < coords.particlePath.length; i++) {
                        ctx.lineTo(coords.particlePath[i].x, coords.particlePath[i].y);
                    }
                    ctx.stroke();
                } else {
                    // 并联电路：绘制两条路径
                    // 路径1
                    ctx.beginPath();
                    ctx.moveTo(coords.particlePath1[0].x, coords.particlePath1[0].y);
                    
                    for (let i = 1; i < coords.particlePath1.length; i++) {
                        ctx.lineTo(coords.particlePath1[i].x, coords.particlePath1[i].y);
                    }
                    ctx.stroke();
                    
                    // 路径2
                    ctx.beginPath();
                    ctx.moveTo(coords.particlePath2[0].x, coords.particlePath2[0].y);
                    
                    for (let i = 1; i < coords.particlePath2.length; i++) {
                        ctx.lineTo(coords.particlePath2[i].x, coords.particlePath2[i].y);
                    }
                    ctx.stroke();
                }
            }
            
            // 绘制电池
            drawBattery(coords.battery);
            
            // 绘制电阻
            drawResistor(coords.resistor1, 'R₁');
            drawResistor(coords.resistor2, 'R₂');
            
            // 绘制开关
            drawSwitch(coords.switch);
            
            // 绘制分支点（并联电路）
            if (circuitType === 'parallel') {
                drawJunction(300 * Math.min(canvas.width / 800, canvas.height / 500) * 0.8, 250 * Math.min(canvas.width / 800, canvas.height / 500) * 0.8, 'A');
                drawJunction(600 * Math.min(canvas.width / 800, canvas.height / 500) * 0.8, 250 * Math.min(canvas.width / 800, canvas.height / 500) * 0.8, 'B');
            }
            
            // 绘制电流表（如果显示）
            if (showAmmeters) {
                drawAmmeters();
            }
            
            // 绘制电子计数器（如果显示）
            if (showCounters) {
                drawCounters();
            }
            
            // 绘制所有粒子
            particles.forEach(particle => {
                particle.draw();
            });
        }
        
        // 绘制电池
        function drawBattery(battery) {
            const {x, y, width, height} = battery;
            
            // 电池外壳
            ctx.fillStyle = '#475569';
            ctx.fillRect(x, y, width, height);
            
            // 正极（红色）
            ctx.fillStyle = '#10b981';
            ctx.fillRect(x, y, width, height / 2);
            
            // 负极（黑色）
            ctx.fillStyle = '#475569';
            ctx.fillRect(x, y + height / 2, width, height / 2);
            
            // 电池符号
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${Math.max(12, width/5)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('+', x + width / 2, y + height / 4);
            ctx.fillText('-', x + width / 2, y + 3 * height / 4);
            
            // 电池标签
            ctx.fillStyle = '#cbd5e1';
            ctx.font = `${Math.max(12, width/5)}px Arial`;
            ctx.fillText('电源', x + width / 2, y - 15);
        }
        
        // 绘制电阻
        function drawResistor(resistor, label) {
            const {x, y, width, height} = resistor;
            
            // 电阻主体
            ctx.fillStyle = '#64748b';
            ctx.fillRect(x, y, width, height);
            
            // 电阻条纹
            ctx.fillStyle = '#475569';
            for (let i = 1; i <= 3; i++) {
                ctx.fillRect(x + i * width / 4 - 5, y, 10, height);
            }
            
            // 电阻标签
            ctx.fillStyle = '#cbd5e1';
            ctx.font = `bold ${Math.max(12, width/6)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x + width / 2, y + height / 2);
            
            // 电阻值标签
            ctx.font = `${Math.max(10, width/8)}px Arial`;
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('10Ω', x + width / 2, y + height + 15);
        }
        
        // 绘制开关
        function drawSwitch(switchCoord) {
            const {x, y, width, height} = switchCoord;
            
            // 开关底座
            ctx.fillStyle = '#475569';
            ctx.fillRect(x, y, width, height);
            
            // 开关状态
            if (circuitClosed) {
                // 闭合状态（绿色）
                ctx.fillStyle = '#10b981';
                ctx.fillRect(x, y, width, height);
                
                // 开关手柄（闭合位置）
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x + width - 5, y - 10, 5, 20);
            } else {
                // 断开状态（红色）
                ctx.fillStyle = '#ef4444';
                ctx.fillRect(x, y, width, height);
                
                // 开关手柄（断开位置）
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(x, y - 10, 5, 20);
            }
            
            // 开关标签
            ctx.fillStyle = '#cbd5e1';
            ctx.font = `${Math.max(12, width/4)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('开关', x + width / 2, y - 20);
        }
        
        // 绘制连接点
        function drawJunction(x, y, label) {
            const radius = Math.max(6, canvas.width / 100);
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#fbbf24';
            ctx.fill();
            
            ctx.fillStyle = '#1e293b';
            ctx.font = `bold ${Math.max(10, radius)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }
        
        // 绘制电流表 - 修复并联电路读数
        function drawAmmeters() {
            const scale = Math.min(canvas.width / 800, canvas.height / 500) * 0.8;
            ctx.fillStyle = '#cbd5e1';
            ctx.font = `${Math.max(12, 14 * scale)}px Arial`;
            ctx.textAlign = 'center';
            
            if (circuitType === 'series') {
                // 串联电路：一个电流表
                ctx.fillText('电流表 A', 250 * scale, 180 * scale);
                
                // 电流表读数
                ctx.font = `bold ${Math.max(14, 18 * scale)}px Arial`;
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`${mainCurrent.toFixed(1)} A`, 250 * scale, 210 * scale);
            } else {
                // 并联电路：三个电流表
                // 干路电流表
                ctx.fillStyle = '#cbd5e1';
                ctx.font = `${Math.max(12, 14 * scale)}px Arial`;
                ctx.fillText('电流表 A₁ (干路)', 250 * scale, 100 * scale);
                
                ctx.font = `bold ${Math.max(14, 18 * scale)}px Arial`;
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`${mainCurrent.toFixed(1)} A`, 250 * scale, 130 * scale);
                
                // 支路1电流表
                ctx.fillStyle = '#cbd5e1';
                ctx.font = `${Math.max(12, 14 * scale)}px Arial`;
                ctx.fillText('电流表 A₂ (支路1)', 500 * scale, 100 * scale);
                
                ctx.font = `bold ${Math.max(14, 18 * scale)}px Arial`;
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`${branch1Current.toFixed(1)} A`, 500 * scale, 130 * scale);
                
                // 支路2电流表
                ctx.fillStyle = '#cbd5e1';
                ctx.font = `${Math.max(12, 14 * scale)}px Arial`;
                ctx.fillText('电流表 A₃ (支路2)', 500 * scale, 400 * scale);
                
                ctx.font = `bold ${Math.max(14, 18 * scale)}px Arial`;
                ctx.fillStyle = '#fbbf24';
                ctx.fillText(`${branch2Current.toFixed(1)} A`, 500 * scale, 430 * scale);
            }
        }
        
        // 绘制电子计数器 - 修复计数逻辑
        function drawCounters() {
            const scale = Math.min(canvas.width / 800, canvas.height / 500) * 0.8;
            ctx.fillStyle = '#60a5fa';
            ctx.font = `bold ${Math.max(12, 14 * scale)}px Arial`;
            ctx.textAlign = 'center';
            
            if (circuitType === 'series') {
                // 串联电路：一个计数器 - 计算在主干路上的粒子
                const electronCount = particles.filter(p => {
                    // 在主干路上的粒子（不在起始和结束区域）
                    return p.currentSegmentIndex > 0 && p.currentSegmentIndex < p.path.length - 2;
                }).length;
                ctx.fillText(`电子数: ${electronCount}`, 450 * scale, 180 * scale);
            } else {
                // 并联电路：三个计数器
                // 干路计数器 - 在电池到分支点A之间的粒子
                const mainElectronCount = particles.filter(p => {
                    if (p.path === circuitCoords.parallel.particlePath1 || p.path === circuitCoords.parallel.particlePath2) {
                        return p.currentSegmentIndex >= 0 && p.currentSegmentIndex <= 1;
                    }
                    return false;
                }).length;
                ctx.fillText(`电子数: ${mainElectronCount}`, 250 * scale, 180 * scale);
                
                // 支路1计数器 - 在电阻1内的粒子
                const branch1ElectronCount = particles.filter(p => {
                    return p.branch === 1 && p.currentSegmentIndex >= 2 && p.currentSegmentIndex <= 4;
                }).length;
                ctx.fillText(`电子数: ${branch1ElectronCount}`, 400 * scale, 100 * scale);
                
                // 支路2计数器 - 在电阻2内的粒子
                const branch2ElectronCount = particles.filter(p => {
                    return p.branch === 2 && p.currentSegmentIndex >= 2 && p.currentSegmentIndex <= 4;
                }).length;
                ctx.fillText(`电子数: ${branch2ElectronCount}`, 400 * scale, 400 * scale);
            }
        }
        
        // 动画循环
        function animate() {
            // 更新粒子
            particles.forEach(particle => {
                particle.update();
            });
            
            // 绘制电路
            drawCircuit();
            
            // 继续动画循环
            requestAnimationFrame(animate);
        }
        
        // 更新信息显示
        function updateInfoDisplay() {
            document.getElementById('circuitType').textContent = 
                circuitType === 'series' ? '串联电路' : '并联电路';
            
            document.getElementById('visualizationMode').textContent = 
                visualizationMode === 'electron' ? '电子流方向' : '电流方向';
            
            document.getElementById('circuitStatus').textContent = 
                circuitClosed ? '通路' : '断路';
            
            document.getElementById('mainCurrent').textContent = 
                circuitClosed ? `${mainCurrent.toFixed(1)} A` : '0.0 A';
            
            if (circuitType === 'series') {
                document.getElementById('branch1Current').textContent = 
                    circuitClosed ? `${mainCurrent.toFixed(1)} A` : '0.0 A';
                document.getElementById('branch2Current').textContent = 
                    circuitClosed ? `${mainCurrent.toFixed(1)} A` : '0.0 A';
            } else {
                document.getElementById('branch1Current').textContent = 
                    circuitClosed ? `${branch1Current.toFixed(1)} A` : '0.0 A';
                document.getElementById('branch2Current').textContent = 
                    circuitClosed ? `${branch2Current.toFixed(1)} A` : '0.0 A';
            }
        }
        
        // 切换电路类型
        function switchCircuitType(type) {
            circuitType = type;
            
            // 更新按钮状态
            document.getElementById('seriesBtn').classList.toggle('active', type === 'series');
            document.getElementById('parallelBtn').classList.toggle('active', type === 'parallel');
            
            // 更新电流值
            if (type === 'series') {
                mainCurrent = 1.0;
                branch1Current = 1.0;
                branch2Current = 1.0;
            } else {
                mainCurrent = 1.5;
                branch1Current = 1.0;
                branch2Current = 0.5;
            }
            
            // 重新初始化粒子
            initParticles();
            updateInfoDisplay();
        }
        
        // 切换可视化模式
        function switchVisualizationMode(mode) {
            visualizationMode = mode;
            
            // 更新按钮状态
            document.getElementById('electronFlowBtn').classList.toggle('active', mode === 'electron');
            document.getElementById('currentFlowBtn').classList.toggle('active', mode === 'current');
            
            // 更新所有粒子的类型
            particles.forEach(particle => {
                particle.isElectron = (mode === 'electron');
                particle.color = particle.isElectron ? '#60a5fa' : '#f87171';
                particle.radius = particle.isElectron ? 6 : 5;
            });
            
            updateInfoDisplay();
        }
        
        // 初始化事件监听器
        function initEventListeners() {
            // 播放/暂停/重置按钮
            document.getElementById('playBtn').addEventListener('click', () => {
                isPlaying = true;
            });
            
            document.getElementById('pauseBtn').addEventListener('click', () => {
                isPlaying = false;
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                initParticles();
            });
            
            // 电路开关
            document.getElementById('circuitSwitch').addEventListener('change', (e) => {
                circuitClosed = e.target.checked;
                updateInfoDisplay();
            });
            
            // 电路类型切换
            document.getElementById('seriesBtn').addEventListener('click', () => {
                switchCircuitType('series');
            });
            
            document.getElementById('parallelBtn').addEventListener('click', () => {
                switchCircuitType('parallel');
            });
            
            // 可视化模式切换
            document.getElementById('electronFlowBtn').addEventListener('click', () => {
                switchVisualizationMode('electron');
            });
            
            document.getElementById('currentFlowBtn').addEventListener('click', () => {
                switchVisualizationMode('current');
            });
            
            // 信息显示切换
            document.getElementById('counterToggle').addEventListener('change', (e) => {
                showCounters = e.target.checked;
            });
            
            document.getElementById('ammeterToggle').addEventListener('change', (e) => {
                showAmmeters = e.target.checked;
            });
            
            // 鼠标悬停提示（简单实现）
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // 检测鼠标是否在元件上（简化版）
                const coords = circuitCoords[circuitType];
                
                // 检查电池
                if (x >= coords.battery.x && x <= coords.battery.x + coords.battery.width &&
                    y >= coords.battery.y && y <= coords.battery.y + coords.battery.height) {
                    canvas.style.cursor = 'help';
                    return;
                }
                
                // 检查电阻
                if ((x >= coords.resistor1.x && x <= coords.resistor1.x + coords.resistor1.width &&
                     y >= coords.resistor1.y && y <= coords.resistor1.y + coords.resistor1.height) ||
                    (x >= coords.resistor2.x && x <= coords.resistor2.x + coords.resistor2.width &&
                     y >= coords.resistor2.y && y <= coords.resistor2.y + coords.resistor2.height)) {
                    canvas.style.cursor = 'help';
                    return;
                }
                
                // 检查开关
                if (x >= coords.switch.x && x <= coords.switch.x + coords.switch.width &&
                    y >= coords.switch.y && y <= coords.switch.y + coords.switch.height) {
                    canvas.style.cursor = 'pointer';
                    return;
                }
                
                canvas.style.cursor = 'default';
            });
            
            // 点击开关切换状态
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const coords = circuitCoords[circuitType];
                
                // 检查是否点击了开关
                if (x >= coords.switch.x && x <= coords.switch.x + coords.switch.width &&
                    y >= coords.switch.y && y <= coords.switch.y + coords.switch.height) {
                    circuitClosed = !circuitClosed;
                    document.getElementById('circuitSwitch').checked = circuitClosed;
                    updateInfoDisplay();
                }
            });
        }
        
        // 初始化应用
        function initApp() {
            initParticles();
            initEventListeners();
            updateInfoDisplay();
            animate();
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', initApp);
    </script>
</body>
</html>