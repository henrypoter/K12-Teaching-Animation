<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>平面镜成像原理 - 虚像与光路</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
            max-width: 900px;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2rem;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }
        
        .subtitle {
            color: #34495e;
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 900px;
            width: 100%;
            justify-content: center;
        }
        
        .canvas-container {
            flex: 1;
            min-width: 500px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        
        #animationCanvas {
            flex: 1;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #ddd;
            cursor: move;
        }
        
        .controls-container {
            width: 300px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .section-title {
            color: #2c3e50;
            font-size: 1.3rem;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3498db;
        }
        
        .steps-control {
            margin-bottom: 25px;
        }
        
        .step-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .step-btn {
            flex: 1;
            min-width: 120px;
            padding: 10px 12px;
            background-color: #ecf0f1;
            border: none;
            border-radius: 6px;
            color: #2c3e50;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .step-btn:hover {
            background-color: #d5dbdb;
            transform: translateY(-2px);
        }
        
        .step-btn.active {
            background-color: #3498db;
            color: white;
            box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
        }
        
        .step-description {
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
            font-size: 0.95rem;
            line-height: 1.5;
            color: #34495e;
        }
        
        .display-controls {
            margin-bottom: 25px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer;
            font-weight: 500;
            color: #2c3e50;
        }
        
        .control-label input {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .slider-group {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-weight: 500;
            color: #2c3e50;
        }
        
        .slider-value {
            color: #3498db;
            font-weight: 600;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ecf0f1;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .drag-controls {
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .drag-hint {
            display: flex;
            align-items: center;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .drag-hint svg {
            margin-right: 10px;
            color: #3498db;
        }
        
        .reset-btn {
            width: 100%;
            padding: 12px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 10px;
        }
        
        .reset-btn:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            max-width: 900px;
            width: 100%;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 20px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .legend-text {
            font-size: 0.9rem;
            color: #2c3e50;
        }
        
        @media (max-width: 850px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .canvas-container, .controls-container {
                width: 100%;
                min-width: unset;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>平面镜成像原理</h1>
        <p class="subtitle">探索虚像位置与光的实际路径 - 交互式教学动画</p>
    </div>
    
    <div class="container">
        <div class="canvas-container">
            <canvas id="animationCanvas" width="800" height="500"></canvas>
        </div>
        
        <div class="controls-container">
            <div class="steps-control">
                <h3 class="section-title">学习步骤</h3>
                <div class="step-buttons">
                    <button class="step-btn active" data-step="1">1. 观察成像</button>
                    <button class="step-btn" data-step="2">2. 显示光路</button>
                    <button class="step-btn" data-step="3">3. 虚像原理</button>
                    <button class="step-btn" data-step="4">4. 总结规律</button>
                </div>
                <div class="step-description" id="stepDescription">
                    观察平面镜成像现象。注意物体与虚像的大小、形状关系。
                </div>
            </div>
            
            <div class="display-controls">
                <h3 class="section-title">显示控制</h3>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showLightRays" checked>
                        <span>显示实际光线（黄色实线）</span>
                    </label>
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showExtensions" checked>
                        <span>显示反向延长线（蓝色虚线）</span>
                    </label>
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showVirtualImage" checked>
                        <span>显示虚像（半透明红色）</span>
                    </label>
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showSymmetryLines">
                        <span>显示对称辅助线（灰色虚线）</span>
                    </label>
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>光线速度</span>
                        <span class="slider-value" id="speedValue">中速</span>
                    </div>
                    <input type="range" id="lightSpeed" min="1" max="10" value="5">
                </div>
            </div>
            
            <div class="drag-controls">
                <h3 class="section-title">交互控制</h3>
                
                <div class="drag-hint">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3v7h7V3H3zM14 3v7h7V3h-7zM3 14v7h7v-7H3zM14 14v7h7v-7h-7z"/>
                    </svg>
                    拖拽物体或眼睛改变位置，观察光路和虚像的变化
                </div>
                
                <button class="reset-btn" id="resetBtn">重置动画</button>
            </div>
        </div>
    </div>
    
    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background-color: #e74c3c;"></div>
            <div class="legend-text">物体（可拖拽）</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: rgba(231, 76, 60, 0.5);"></div>
            <div class="legend-text">虚像（半透明）</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #f1c40f;"></div>
            <div class="legend-text">实际光线（黄色实线）</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #3498db; border: 1px dashed #3498db;"></div>
            <div class="legend-text">反向延长线（蓝色虚线）</div>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background-color: #95a5a6; border: 1px dashed #95a5a6;"></div>
            <div class="legend-text">对称辅助线（灰色虚线）</div>
        </div>
    </div>

    <script>
        // 获取Canvas和上下文
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');
        
        // 调整Canvas大小以适应容器
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            draw();
        }
        
        // 初始调整大小
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);
        
        // 动画状态
        let currentStep = 1;
        let animationProgress = 0;
        let animationDirection = 1;
        let lastTime = 0;
        const animationSpeed = 0.02;
        
        // 显示控制
        let showLightRays = true;
        let showExtensions = true;
        let showVirtualImage = true;
        let showSymmetryLines = false;
        let lightSpeed = 5;
        
        // 元素位置
        let mirror = {
            x: canvas.width * 0.5,
            y: canvas.height * 0.5,
            width: 10,
            height: 300
        };
        
        let object = {
            x: canvas.width * 0.3,
            y: canvas.height * 0.5,
            radius: 25,
            color: '#e74c3c',
            isDragging: false
        };
        
        let eye = {
            x: canvas.width * 0.8,
            y: canvas.height * 0.3,
            radius: 20,
            isDragging: false
        };
        
        // 计算虚像位置（关于镜面对称）
        function calculateVirtualImage() {
            const mirrorCenterX = mirror.x;
            const distanceFromMirror = mirrorCenterX - object.x;
            return {
                x: mirrorCenterX + distanceFromMirror,
                y: object.y,
                radius: object.radius,
                color: 'rgba(231, 76, 60, 0.5)'
            };
        }
        
        // 计算光线路径
        function calculateLightPaths() {
            const virtualImage = calculateVirtualImage();
            
            // 物体上的两个点（用于发射光线）
            const objectTop = { x: object.x, y: object.y - object.radius * 0.7 };
            const objectBottom = { x: object.x, y: object.y + object.radius * 0.7 };
            
            // 计算光线在镜面上的反射点
            // 使用虚像法：从眼睛到虚像的连线与镜面的交点
            const mirrorTopY = mirror.y - mirror.height/2;
            const mirrorBottomY = mirror.y + mirror.height/2;
            
            // 第一条光线（从物体顶部）
            const reflectionPoint1 = {
                x: mirror.x,
                y: mirrorTopY + (mirrorBottomY - mirrorTopY) * 0.3
            };
            
            // 第二条光线（从物体底部）
            const reflectionPoint2 = {
                x: mirror.x,
                y: mirrorTopY + (mirrorBottomY - mirrorTopY) * 0.7
            };
            
            return {
                ray1: {
                    from: objectTop,
                    toMirror: reflectionPoint1,
                    toEye: eye
                },
                ray2: {
                    from: objectBottom,
                    toMirror: reflectionPoint2,
                    toEye: eye
                }
            };
        }
        
        // 绘制平面镜
        function drawMirror() {
            // 镜面
            ctx.fillStyle = '#bdc3c7';
            ctx.fillRect(mirror.x - mirror.width/2, mirror.y - mirror.height/2, mirror.width, mirror.height);
            
            // 镜框
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(mirror.x - mirror.width/2 - 3, mirror.y - mirror.height/2 - 3, mirror.width + 6, 3);
            ctx.fillRect(mirror.x - mirror.width/2 - 3, mirror.y + mirror.height/2, mirror.width + 6, 3);
            ctx.fillRect(mirror.x - mirror.width/2 - 3, mirror.y - mirror.height/2, 3, mirror.height);
            ctx.fillRect(mirror.x + mirror.width/2, mirror.y - mirror.height/2, 3, mirror.height);
            
            // 镜面反射效果
            const gradient = ctx.createLinearGradient(mirror.x - mirror.width/2, 0, mirror.x + mirror.width/2, 0);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(mirror.x - mirror.width/2, mirror.y - mirror.height/2, mirror.width, mirror.height);
        }
        
        // 绘制物体
        function drawObject() {
            // 物体主体
            ctx.fillStyle = object.color;
            ctx.beginPath();
            ctx.arc(object.x, object.y, object.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 物体高光
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(object.x - object.radius * 0.3, object.y - object.radius * 0.3, object.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // 物体标签
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('物体', object.x, object.y);
            
            // 如果正在拖拽，显示拖拽效果
            if (object.isDragging) {
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(object.x, object.y, object.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // 绘制眼睛
        function drawEye() {
            // 眼睛轮廓
            ctx.fillStyle = '#2c3e50';
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, eye.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼白
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, eye.radius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            
            // 瞳孔
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(eye.x, eye.y, eye.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // 高光
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(eye.x - eye.radius * 0.15, eye.y - eye.radius * 0.15, eye.radius * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛标签
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('眼睛', eye.x, eye.y + eye.radius + 20);
            
            // 如果正在拖拽，显示拖拽效果
            if (eye.isDragging) {
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(eye.x, eye.y, eye.radius + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // 绘制虚像
        function drawVirtualImage() {
            if (!showVirtualImage && currentStep < 3) return;
            
            const virtualImage = calculateVirtualImage();
            
            // 虚像主体（半透明）
            ctx.fillStyle = virtualImage.color;
            ctx.beginPath();
            ctx.arc(virtualImage.x, virtualImage.y, virtualImage.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 虚像标签
            ctx.fillStyle = 'rgba(44, 62, 80, 0.7)';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('虚像', virtualImage.x, virtualImage.y);
            
            // 虚像说明文字
            if (currentStep >= 3) {
                ctx.fillStyle = '#e74c3c';
                ctx.font = 'italic 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('(无实际光线到达)', virtualImage.x, virtualImage.y + virtualImage.radius + 20);
            }
        }
        
        // 绘制光线
        function drawLightRays() {
            if (!showLightRays && currentStep < 2) return;
            
            const lightPaths = calculateLightPaths();
            const progress = currentStep >= 2 ? animationProgress : 0;
            const speedFactor = lightSpeed / 5;
            
            // 绘制第一条光线
            drawRay(
                lightPaths.ray1.from, 
                lightPaths.ray1.toMirror, 
                lightPaths.ray1.toEye, 
                progress, 
                speedFactor,
                0
            );
            
            // 绘制第二条光线
            drawRay(
                lightPaths.ray2.from, 
                lightPaths.ray2.toMirror, 
                lightPaths.ray2.toEye, 
                progress, 
                speedFactor,
                0.3
            );
        }
        
        // 绘制单条光线
        function drawRay(from, toMirror, toEye, progress, speedFactor, delay) {
            const adjustedProgress = Math.max(0, (progress - delay) / (1 - delay));
            
            if (adjustedProgress <= 0) return;
            
            // 实际光线（黄色实线）
            if (showLightRays && currentStep >= 2) {
                ctx.strokeStyle = '#f1c40f';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                // 从物体到镜面的部分
                const mirrorProgress = Math.min(1, adjustedProgress * 2);
                const mirrorX = from.x + (toMirror.x - from.x) * mirrorProgress;
                const mirrorY = from.y + (toMirror.y - from.y) * mirrorProgress;
                
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(mirrorX, mirrorY);
                ctx.stroke();
                
                // 绘制光线箭头（在镜面处）
                if (mirrorProgress >= 0.5 && mirrorProgress < 1) {
                    drawArrow(mirrorX, mirrorY, toMirror.x - from.x, toMirror.y - from.y, '#f1c40f');
                }
                
                // 从镜面到眼睛的部分
                if (adjustedProgress > 0.5) {
                    const eyeProgress = (adjustedProgress - 0.5) * 2;
                    const eyeX = toMirror.x + (toEye.x - toMirror.x) * eyeProgress;
                    const eyeY = toMirror.y + (toEye.y - toMirror.y) * eyeProgress;
                    
                    ctx.beginPath();
                    ctx.moveTo(toMirror.x, toMirror.y);
                    ctx.lineTo(eyeX, eyeY);
                    ctx.stroke();
                    
                    // 绘制光线箭头（在眼睛处）
                    if (eyeProgress >= 0.7) {
                        drawArrow(eyeX, eyeY, toEye.x - toMirror.x, toEye.y - toMirror.y, '#f1c40f');
                    }
                }
            }
            
            // 反向延长线（蓝色虚线）
            if (showExtensions && currentStep >= 3 && adjustedProgress > 0.5) {
                const virtualImage = calculateVirtualImage();
                const eyeProgress = (adjustedProgress - 0.5) * 2;
                
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.lineCap = 'round';
                
                // 从眼睛反向延长到虚像
                const extensionProgress = Math.min(1, eyeProgress * 1.5);
                const extensionX = toEye.x + (virtualImage.x - toEye.x) * extensionProgress;
                const extensionY = toEye.y + (virtualImage.y - toEye.y) * extensionProgress;
                
                ctx.beginPath();
                ctx.moveTo(toEye.x, toEye.y);
                ctx.lineTo(extensionX, extensionY);
                ctx.stroke();
                
                // 绘制延长线箭头
                if (extensionProgress >= 0.7) {
                    drawArrow(extensionX, extensionY, virtualImage.x - toEye.x, virtualImage.y - toEye.y, '#3498db');
                }
                
                ctx.setLineDash([]);
            }
        }
        
        // 绘制箭头
        function drawArrow(x, y, dx, dy, color) {
            const angle = Math.atan2(dy, dx);
            const arrowLength = 15;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.fillStyle = color;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-arrowLength, arrowLength/2);
            ctx.lineTo(-arrowLength, -arrowLength/2);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        // 绘制对称辅助线
        function drawSymmetryLines() {
            if (!showSymmetryLines && currentStep < 4) return;
            
            const virtualImage = calculateVirtualImage();
            
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // 物体到虚像的连线
            ctx.beginPath();
            ctx.moveTo(object.x, object.y);
            ctx.lineTo(virtualImage.x, virtualImage.y);
            ctx.stroke();
            
            // 镜面的垂直线（对称轴）
            ctx.beginPath();
            ctx.moveTo(mirror.x, mirror.y - mirror.height/2);
            ctx.lineTo(mirror.x, mirror.y + mirror.height/2);
            ctx.stroke();
            
            // 物体到镜面的垂线
            ctx.beginPath();
            ctx.moveTo(object.x, object.y);
            ctx.lineTo(mirror.x, object.y);
            ctx.stroke();
            
            // 虚像到镜面的垂线
            ctx.beginPath();
            ctx.moveTo(virtualImage.x, virtualImage.y);
            ctx.lineTo(mirror.x, virtualImage.y);
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // 标记距离相等
            if (currentStep >= 4) {
                const distance = Math.abs(mirror.x - object.x);
                const midY = object.y;
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                
                // 物体到镜面的距离
                ctx.fillText(`d = ${Math.round(distance)}px`, (object.x + mirror.x) / 2, midY - 10);
                
                // 虚像到镜面的距离
                ctx.fillText(`d = ${Math.round(distance)}px`, (virtualImage.x + mirror.x) / 2, midY - 10);
                
                // 对称标记
                ctx.fillText('对称轴', mirror.x, mirror.y - mirror.height/2 - 10);
            }
        }
        
        // 绘制步骤说明
        function drawStepInfo() {
            const stepTexts = [
                "第一步：观察成像现象。注意物体与虚像的大小、形状相同。",
                "第二步：显示实际光路。光线从物体发出，经平面镜反射后进入眼睛。",
                "第三步：揭示虚像原理。眼睛沿直线追溯光线来源，反向延长线在镜后相交形成虚像。",
                "第四步：总结规律。物像关于镜面对称，等大、等距，虚像无实际光线到达。"
            ];
            
            ctx.fillStyle = 'rgba(44, 62, 80, 0.9)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // 绘制背景框
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(20, 20, canvas.width - 40, 60);
            
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, canvas.width - 40, 60);
            
            // 绘制步骤文本
            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 18px Arial';
            ctx.fillText(`步骤 ${currentStep}/4`, 30, 30);
            
            ctx.font = '16px Arial';
            const lines = wrapText(stepTexts[currentStep-1], canvas.width - 80);
            lines.forEach((line, index) => {
                ctx.fillText(line, 30, 55 + index * 20);
            });
        }
        
        // 文本换行函数
        function wrapText(text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];
            
            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }
        
        // 主绘制函数
        function draw() {
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.width);
            
            // 更新镜面位置（始终在画布中央）
            mirror.x = canvas.width * 0.5;
            mirror.y = canvas.height * 0.5;
            
            // 确保物体和眼睛在合理范围内
            object.x = Math.max(object.radius + 10, Math.min(canvas.width * 0.45, object.x));
            object.y = Math.max(object.radius + 50, Math.min(canvas.height - object.radius - 50, object.y));
            
            eye.x = Math.max(mirror.x + 50, Math.min(canvas.width - eye.radius - 10, eye.x));
            eye.y = Math.max(eye.radius + 50, Math.min(canvas.height - eye.radius - 50, eye.y));
            
            // 绘制所有元素
            drawMirror();
            drawVirtualImage();
            drawSymmetryLines();
            drawLightRays();
            drawObject();
            drawEye();
            drawStepInfo();
        }
        
        // 动画循环
        function animate(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // 更新动画进度
            if (currentStep >= 2) {
                animationProgress += animationDirection * animationSpeed * (deltaTime / 16) * (lightSpeed / 5);
                
                if (animationProgress >= 1) {
                    animationProgress = 1;
                    // 在第3步和第4步，动画完成后保持状态
                    if (currentStep < 3) {
                        setTimeout(() => {
                            animationDirection = -1;
                        }, 1000);
                    }
                }
                
                if (animationProgress <= 0) {
                    animationProgress = 0;
                    animationDirection = 1;
                }
            }
            
            draw();
            requestAnimationFrame(animate);
        }
        
        // 初始化事件监听
        function initEventListeners() {
            // 步骤按钮
            document.querySelectorAll('.step-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const step = parseInt(this.dataset.step);
                    setStep(step);
                });
            });
            
            // 显示控制复选框
            document.getElementById('showLightRays').addEventListener('change', function() {
                showLightRays = this.checked;
                draw();
            });
            
            document.getElementById('showExtensions').addEventListener('change', function() {
                showExtensions = this.checked;
                draw();
            });
            
            document.getElementById('showVirtualImage').addEventListener('change', function() {
                showVirtualImage = this.checked;
                draw();
            });
            
            document.getElementById('showSymmetryLines').addEventListener('change', function() {
                showSymmetryLines = this.checked;
                draw();
            });
            
            // 光线速度滑块
            document.getElementById('lightSpeed').addEventListener('input', function() {
                lightSpeed = parseInt(this.value);
                document.getElementById('speedValue').textContent = 
                    lightSpeed <= 3 ? '慢速' : lightSpeed <= 7 ? '中速' : '快速';
            });
            
            // 重置按钮
            document.getElementById('resetBtn').addEventListener('click', function() {
                resetAnimation();
            });
            
            // 鼠标拖拽事件
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // 触摸屏支持
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('touchend', handleTouchEnd);
        }
        
        // 设置当前步骤
        function setStep(step) {
            currentStep = step;
            animationProgress = 0;
            animationDirection = 1;
            
            // 更新按钮状态
            document.querySelectorAll('.step-btn').forEach(btn => {
                if (parseInt(btn.dataset.step) === step) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // 更新步骤描述
            const stepDescriptions = [
                "观察平面镜成像现象。注意物体与虚像的大小、形状关系。",
                "显示实际光路。光线从物体发出，经平面镜反射后进入眼睛。",
                "揭示虚像原理。眼睛沿直线追溯光线来源，反向延长线在镜后相交形成虚像。",
                "总结规律。物像关于镜面对称，等大、等距，虚像无实际光线到达。"
            ];
            
            document.getElementById('stepDescription').textContent = stepDescriptions[step-1];
            
            // 根据步骤自动设置显示选项
            if (step === 1) {
                document.getElementById('showLightRays').checked = false;
                document.getElementById('showExtensions').checked = false;
                document.getElementById('showSymmetryLines').checked = false;
                showLightRays = false;
                showExtensions = false;
                showSymmetryLines = false;
            } else if (step === 2
<!--检测到代码截断，自动续写中...-->