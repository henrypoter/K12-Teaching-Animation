<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‰²æ•£ç°è±¡ä¸ä¸‰æ£±é•œ - ç™½å…‰åˆ†è§£å®éªŒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
            background: linear-gradient(to bottom, #0a0a2a, #1a1a3a);
            color: #f0f0f0;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        h1 {
            color: #ffffff;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .subtitle {
            color: #a0c8ff;
            font-size: 1.2rem;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }

        .animation-section {
            flex: 1;
            min-width: 600px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls-section {
            flex: 1;
            min-width: 300px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #animationCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .info-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .control-group {
            margin-bottom: 25px;
        }

        h2 {
            color: #7ab8ff;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(122, 184, 255, 0.3);
            font-size: 1.4rem;
        }

        h3 {
            color: #a0c8ff;
            margin: 15px 0 10px;
            font-size: 1.1rem;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        button {
            background: linear-gradient(to bottom, #2a4a7a, #1a3a6a);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        button:hover {
            background: linear-gradient(to bottom, #3a5a8a, #2a4a7a);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(to bottom, #4a6a9a, #3a5a8a);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #2a2a4a;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a8aff;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(74, 138, 255, 0.5);
        }

        .value-display {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 1.1rem;
            text-align: center;
            margin: 10px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .color-spectrum {
            height: 30px;
            background: linear-gradient(to right, 
                #FF3333, #FF9933, #FFFF33, #33FF33, 
                #3333FF, #4B0082, #9933FF);
            border-radius: 6px;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .knowledge-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .knowledge-content {
            display: none;
            padding-top: 15px;
        }

        .knowledge-content.active {
            display: block;
        }

        .knowledge-item {
            background: rgba(30, 40, 70, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #4a8aff;
        }

        .knowledge-item h4 {
            color: #a0c8ff;
            margin-bottom: 8px;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #888;
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .animation-section, .controls-section {
                min-width: 100%;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>è‰²æ•£ç°è±¡ä¸ä¸‰æ£±é•œ</h1>
            <p class="subtitle">ç™½å…‰åˆ†è§£æˆä¸ƒè‰²å…‰çš„å…¨è¿‡ç¨‹æ¼”ç¤º</p>
        </header>

        <div class="main-content">
            <section class="animation-section">
                <h2>å®éªŒæ¼”ç¤º</h2>
                <div class="canvas-container">
                    <canvas id="animationCanvas"></canvas>
                    <div class="info-overlay">
                        <div>å½“å‰æ¨¡å¼: <span id="currentMode">å®Œæ•´æ¼”ç¤º</span></div>
                        <div>å…¥å°„è§’: <span id="currentAngle">45Â°</span></div>
                    </div>
                </div>
            </section>

            <section class="controls-section">
                <h2>å®éªŒæ§åˆ¶</h2>
                
                <div class="control-group">
                    <h3>åŠ¨ç”»æ§åˆ¶</h3>
                    <div class="button-group">
                        <button id="playBtn">æ’­æ”¾</button>
                        <button id="pauseBtn">æš‚åœ</button>
                        <button id="resetBtn">é‡ç½®</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>åˆ†æ­¥å­¦ä¹ </h3>
                    <div class="button-group">
                        <button class="step-btn" data-step="0">å®Œæ•´æ¼”ç¤º</button>
                        <button class="step-btn" data-step="1">1. ç™½å…‰å…¥å°„</button>
                        <button class="step-btn" data-step="2">2. ç¬¬ä¸€æ¬¡æŠ˜å°„</button>
                        <button class="step-btn" data-step="3">3. æ£±é•œå†…ä¼ æ’­</button>
                        <button class="step-btn" data-step="4">4. ç¬¬äºŒæ¬¡æŠ˜å°„</button>
                        <button class="step-btn" data-step="5">5. å½¢æˆå…‰è°±</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>å‚æ•°è°ƒèŠ‚</h3>
                    
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>å…¥å°„è§’åº¦</span>
                            <span id="angleValue">45Â°</span>
                        </div>
                        <input type="range" id="angleSlider" min="20" max="70" value="45" step="1">
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>æ£±é•œé¡¶è§’</span>
                            <span id="prismValue">60Â°</span>
                        </div>
                        <input type="range" id="prismSlider" min="40" max="80" value="60" step="1">
                    </div>

                    <div class="slider-container">
                        <div class="slider-label">
                            <span>åŠ¨ç”»é€Ÿåº¦</span>
                            <span id="speedValue">1.0x</span>
                        </div>
                        <input type="range" id="speedSlider" min="0.1" max="3" value="1" step="0.1">
                    </div>
                </div>

                <div class="control-group">
                    <h3>å…‰æºé€‰æ‹©</h3>
                    <div class="button-group">
                        <button class="light-btn active" data-light="white">ç™½å…‰</button>
                        <button class="light-btn" data-light="red">çº¢å…‰</button>
                        <button class="light-btn" data-light="violet">ç´«å…‰</button>
                    </div>
                    <div class="value-display">
                        æŠ˜å°„ç‡: <span id="refractionInfo">n(çº¢)=1.51 &lt; n(ç´«)=1.53</span>
                    </div>
                </div>

                <div class="color-spectrum"></div>
                <p style="text-align: center; font-size: 0.9rem; color: #aaa;">
                    å¯è§å…‰è°±: çº¢ â†’ æ©™ â†’ é»„ â†’ ç»¿ â†’ è“ â†’ é› â†’ ç´«
                </p>
            </section>
        </div>

        <section class="knowledge-section">
            <h2 style="cursor: pointer;" id="knowledgeToggle">ğŸ“š çŸ¥è¯†æ‰©å±• (ç‚¹å‡»å±•å¼€)</h2>
            <div class="knowledge-content" id="knowledgeContent">
                <div class="knowledge-item">
                    <h4>è‰²æ•£åŸç†</h4>
                    <p>ç™½å…‰æ˜¯ç”±ä¸åŒæ³¢é•¿çš„å•è‰²å…‰æ··åˆè€Œæˆã€‚ä¸åŒé¢œè‰²çš„å…‰åœ¨ç»ç’ƒä¸­çš„ä¼ æ’­é€Ÿåº¦ä¸åŒï¼Œå¯¼è‡´æŠ˜å°„ç‡ä¸åŒï¼ˆnç´« > nçº¢ï¼‰ã€‚ä¸‰æ£±é•œçš„å‡ ä½•å½¢çŠ¶å°†è¿™ç§å¾®å°çš„æŠ˜å°„å·®å¼‚æ”¾å¤§ï¼Œå½¢æˆå…‰è°±ã€‚</p>
                </div>
                <div class="knowledge-item">
                    <h4>ç”Ÿæ´»ä¸­çš„è‰²æ•£ç°è±¡</h4>
                    <p>â€¢ å½©è™¹ï¼šé˜³å…‰åœ¨æ°´æ»´ä¸­å‘ç”ŸæŠ˜å°„ã€åå°„å’Œè‰²æ•£<br>
                       â€¢ å…‰ç›˜è¡¨é¢ï¼šå…‰æ …è¡å°„äº§ç”Ÿå½©è‰²æ¡çº¹<br>
                       â€¢ è‚¥çš‚æ³¡ï¼šè–„è†œå¹²æ¶‰äº§ç”Ÿå½©è‰²å›¾æ¡ˆ<br>
                       â€¢ é’»çŸ³ï¼šå¤šä¸ªåˆ‡é¢å¢å¼ºè‰²æ•£æ•ˆæœï¼Œäº§ç”Ÿ"ç«å½©"</p>
                </div>
                <div class="knowledge-item">
                    <h4>ç§‘å­¦å²è¯</h4>
                    <p>1666å¹´ï¼Œè‰¾è¨å…‹Â·ç‰›é¡¿é€šè¿‡ä¸‰æ£±é•œå®éªŒé¦–æ¬¡è¯æ˜äº†ç™½å…‰æ˜¯ç”±ä¸åŒé¢œè‰²çš„å…‰ç»„æˆçš„ï¼Œè¿™ä¸€å‘ç°å¥ å®šäº†ç°ä»£å…‰å­¦çš„åŸºç¡€ã€‚</p>
                </div>
            </div>
        </section>

        <footer>
            <p>æ•™å­¦åŠ¨ç”» | è‰²æ•£ç°è±¡ä¸ä¸‰æ£±é•œ | è®¾è®¡ç”¨äºç‰©ç†å…‰å­¦æ•™å­¦</p>
            <p>æç¤ºï¼šå°è¯•è°ƒèŠ‚å‚æ•°è§‚å¯Ÿè‰²æ•£æ•ˆæœçš„å˜åŒ–ï¼Œä½¿ç”¨åˆ†æ­¥å­¦ä¹ æ¨¡å¼ç†è§£æ¯ä¸ªç‰©ç†è¿‡ç¨‹</p>
        </footer>
    </div>

    <script>
        // è·å–Canvaså…ƒç´ å’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('animationCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®Canvaså°ºå¯¸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        // åˆå§‹åŒ–å˜é‡
        let animationId = null;
        let isPlaying = true;
        let currentStep = 0; // 0:å®Œæ•´æ¼”ç¤º, 1-5:åˆ†æ­¥
        let animationTime = 0;
        let animationSpeed = 1.0;
        
        // å®éªŒå‚æ•°
        let incidentAngle = 45; // å…¥å°„è§’ï¼ˆåº¦ï¼‰
        let prismAngle = 60;    // æ£±é•œé¡¶è§’ï¼ˆåº¦ï¼‰
        let lightType = 'white'; // å…‰æºç±»å‹
        
        // é¢œè‰²å®šä¹‰
        const colors = {
            white: '#FFFFFF',
            red: '#FF3333',
            orange: '#FF9933',
            yellow: '#FFFF33',
            green: '#33FF33',
            blue: '#3333FF',
            indigo: '#4B0082',
            violet: '#9933FF',
            prism: 'rgba(200, 220, 255, 0.15)',
            prismBorder: 'rgba(224, 224, 224, 0.8)'
        };

        // æŠ˜å°„ç‡æ•°æ®
        const refractionIndices = {
            red: 1.51,
            orange: 1.512,
            yellow: 1.514,
            green: 1.516,
            blue: 1.518,
            indigo: 1.52,
            violet: 1.53
        };

        // åˆå§‹åŒ–
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ç»˜åˆ¶ä¸‰æ£±é•œ
        function drawPrism() {
            const centerX = canvas.width * 0.4;
            const centerY = canvas.height * 0.5;
            const size = Math.min(canvas.width, canvas.height) * 0.3;
            
            // è®¡ç®—æ£±é•œé¡¶ç‚¹
            const angleRad = prismAngle * Math.PI / 180;
            const height = size * Math.sin(angleRad / 2);
            const halfBase = size * Math.cos(angleRad / 2);
            
            const topX = centerX;
            const topY = centerY - height / 2;
            const leftX = centerX - halfBase;
            const leftY = centerY + height / 2;
            const rightX = centerX + halfBase;
            const rightY = centerY + height / 2;
            
            // ç»˜åˆ¶æ£±é•œ
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(topX, topY);
            ctx.lineTo(leftX, leftY);
            ctx.lineTo(rightX, rightY);
            ctx.closePath();
            
            // æ£±é•œå¡«å……
            ctx.fillStyle = colors.prism;
            ctx.fill();
            
            // æ£±é•œè¾¹æ¡†
            ctx.lineWidth = 2;
            ctx.strokeStyle = colors.prismBorder;
            ctx.stroke();
            
            // æ ‡æ³¨é¡¶è§’
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px Arial';
            ctx.fillText(`${prismAngle}Â°`, centerX, centerY - height/2 - 10);
            
            ctx.restore();
            
            return { topX, topY, leftX, leftY, rightX, rightY, centerX, centerY };
        }

        // è®¡ç®—å…‰çº¿è·¯å¾„
        function calculateLightPath(prism, color, isSingleColor = false) {
            const { topX, topY, leftX, leftY, rightX, rightY, centerX, centerY } = prism;
            
            // å…¥å°„ç‚¹ï¼ˆå·¦ä¾§é¢ä¸­ç‚¹ï¼‰
            const incidentX = leftX + (topX - leftX) * 0.5;
            const incidentY = leftY + (topY - leftY) * 0.5;
            
            // å·¦ä¾§é¢æ³•çº¿ï¼ˆå‚ç›´äºå·¦ä¾§é¢ï¼‰
            const leftNormalAngle = Math.atan2(topY - leftY, topX - leftX) + Math.PI / 2;
            
            // å…¥å°„è§’ï¼ˆç›¸å¯¹äºæ³•çº¿ï¼‰
            const incidentAngleRad = incidentAngle * Math.PI / 180;
            const actualIncidentAngle = leftNormalAngle + incidentAngleRad;
            
            // è®¡ç®—æŠ˜å°„è§’ï¼ˆæ–¯æ¶…å°”å®šå¾‹ï¼‰
            const n_air = 1.0;
            const n_glass = refractionIndices[color];
            const refractionAngle = Math.asin(Math.sin(incidentAngleRad) * n_air / n_glass);
            
            // æ£±é•œå†…å…‰çº¿æ–¹å‘
            const internalAngle = leftNormalAngle + refractionAngle;
            
            // è®¡ç®—ä¸å³ä¾§é¢çš„äº¤ç‚¹
            const m1 = Math.tan(internalAngle);
            const b1 = incidentY - m1 * incidentX;
            
            // å³ä¾§é¢ç›´çº¿æ–¹ç¨‹
            const m2 = (rightY - topY) / (rightX - topX);
            const b2 = topY - m2 * topX;
            
            // æ±‚äº¤ç‚¹
            const exitX = (b2 - b1) / (m1 - m2);
            const exitY = m1 * exitX + b1;
            
            // å³ä¾§é¢æ³•çº¿
            const rightNormalAngle = Math.atan2(topY - rightY, topX - rightX) - Math.PI / 2;
            
            // å‡ºå°„è§’è®¡ç®—
            const internalIncidentAngle = internalAngle - rightNormalAngle;
            const exitAngle = Math.asin(Math.sin(internalIncidentAngle) * n_glass / n_air);
            
            // æœ€ç»ˆå‡ºå°„æ–¹å‘
            const finalAngle = rightNormalAngle + exitAngle;
            
            return {
                incidentX, incidentY,
                exitX, exitY,
                internalAngle, finalAngle,
                refractionAngle: refractionAngle * 180 / Math.PI,
                exitAngle: exitAngle * 180 / Math.PI
            };
        }

        // ç»˜åˆ¶å…‰çº¿
        function drawLightBeam(startX, startY, angle, length, color, width = 3, withGlow = true) {
            ctx.save();
            
            const endX = startX + Math.cos(angle) * length;
            const endY = startY + Math.sin(angle) * length;
            
            // å…‰æ™•æ•ˆæœ
            if (withGlow) {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, color + '80');
                gradient.addColorStop(0.5, color + 'FF');
                gradient.addColorStop(1, color + '80');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = width + 4;
                ctx.lineCap = 'round';
                ctx.stroke();
            }
            
            // ä¸»å…‰çº¿
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            ctx.restore();
            
            return { endX, endY };
        }

        // ç»˜åˆ¶å•è‰²å…‰
        function drawSingleColorLight(prism, colorName, progress) {
            const path = calculateLightPath(prism, colorName, true);
            const color = colors[colorName];
            
            // å…¥å°„å…‰çº¿
            const incidentLength = canvas.width * 0.2 * progress;
            const incidentAngle = path.internalAngle - path.refractionAngle * Math.PI / 180;
            drawLightBeam(
                path.incidentX - Math.cos(incidentAngle) * incidentLength,
                path.incidentY - Math.sin(incidentAngle) * incidentLength,
                incidentAngle,
                incidentLength,
                color
            );
            
            // æ£±é•œå†…å…‰çº¿
            if (progress > 0.3) {
                const internalProgress = Math.min(1, (progress - 0.3) / 0.4);
                const internalLength = Math.sqrt(
                    Math.pow(path.exitX - path.incidentX, 2) + 
                    Math.pow(path.exitY - path.incidentY, 2)
                ) * internalProgress;
                
                drawLightBeam(
                    path.incidentX,
                    path.incidentY,
                    path.internalAngle,
                    internalLength,
                    color
                );
            }
            
            // å‡ºå°„å…‰çº¿
            if (progress > 0.7) {
                const exitProgress = (progress - 0.7) / 0.3;
                const exitLength = canvas.width * 0.3 * exitProgress;
                
                drawLightBeam(
                    path.exitX,
                    path.exitY,
                    path.finalAngle,
                    exitLength,
                    color
                );
            }
            
            // æ ‡æ³¨æŠ˜å°„ç‡
            if (progress > 0.5) {
                ctx.save();
                ctx.fillStyle = color;
                ctx.font = 'bold 14px Arial';
                ctx.fillText(`n=${refractionIndices[colorName]}`, 
                    path.incidentX + 20, path.incidentY - 10);
                ctx.restore();
            }
        }

        // ç»˜åˆ¶ç™½å…‰åˆ†è§£
        function drawWhiteLightDispersion(prism, progress) {
            const colorOrder = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
            
            colorOrder.forEach((colorName, index) => {
                // æ¯ä¸ªé¢œè‰²ç¨å¾®åç§»ä¸€ç‚¹è§’åº¦
                const angleOffset = (index - 3) * 0.5 * Math.PI / 180;
                const originalAngle = incidentAngle;
                incidentAngle += (index - 3) * 0.1;
                
                const path = calculateLightPath(prism, colorName);
                const color = colors[colorName];
                
                // æ ¹æ®æ­¥éª¤æ§åˆ¶ç»˜åˆ¶
                let drawIncident = progress > 0.1;
                let drawInternal = progress > 0.3;
                let drawExit = progress > 0.7;
                
                // åˆ†æ­¥æ¨¡å¼æ§åˆ¶
                if (currentStep === 1) { // åªç»˜åˆ¶å…¥å°„
                    drawInternal = false;
                    drawExit = false;
                    drawIncident = progress > 0.1;
                } else if (currentStep === 2) { // åªç»˜åˆ¶ç¬¬ä¸€æ¬¡æŠ˜å°„
                    drawIncident = progress > 0.1;
                    drawInternal = progress > 0.3 && progress < 0.5;
                    drawExit = false;
                } else if (currentStep === 3) { // åªç»˜åˆ¶æ£±é•œå†…
                    drawIncident = false;
                    drawInternal = progress > 0.3;
                    drawExit = false;
                } else if (currentStep === 4) { // åªç»˜åˆ¶ç¬¬äºŒæ¬¡æŠ˜å°„
                    drawIncident = false;
                    drawInternal = progress > 0.3;
                    drawExit = progress > 0.7 && progress < 0.9;
                } else if (currentStep === 5) { // åªç»˜åˆ¶å‡ºå°„å…‰è°±
                    drawIncident = false;
                    drawInternal = false;
                    drawExit = progress > 0.7;
                }
                
                // å…¥å°„å…‰çº¿
                if (drawIncident) {
                    const incidentLength = canvas.width * 0.2 * Math.min(1, progress / 0.3);
                    const incidentAngle = path.internalAngle - path.refractionAngle * Math.PI / 180 + angleOffset;
                    drawLightBeam(
                        path.incidentX - Math.cos(incidentAngle) * incidentLength,
                        path.incidentY - Math.sin(incidentAngle) * incidentLength,
                        incidentAngle,
                        incidentLength,
                        currentStep === 0 ? colors.white : color,
                        currentStep === 0 ? 5 : 2,
                        currentStep === 0
                    );
                }
                
                // æ£±é•œå†…å…‰çº¿
                if (drawInternal) {
                    const internalProgress = currentStep === 2 ? 
                        Math.min(1, (progress - 0.3) / 0.2) :
                        Math.min(1, (progress - 0.3) / 0.4);
                    
                    const internalLength = Math.sqrt(
                        Math.pow(path.exitX - path.incidentX, 2) + 
                        Math.pow(path.exitY - path.incidentY, 2)
                    ) * internalProgress;
                    
                    drawLightBeam(
                        path.incidentX,
                        path.incidentY,
                        path.internalAngle + angleOffset,
                        internalLength,
                        color,
                        2
                    );
                }
                
                // å‡ºå°„å…‰çº¿
                if (drawExit) {
                    const exitProgress = currentStep === 4 ? 
                        Math.min(1, (progress - 0.7) / 0.2) :
                        Math.min(1, (progress - 0.7) / 0.3);
                    
                    const exitLength = canvas.width * 0.3 * exitProgress;
                    
                    drawLightBeam(
                        path.exitX,
                        path.exitY,
                        path.finalAngle + angleOffset * 3,
                        exitLength,
                        color,
                        2,
                        true
                    );
                }
                
                incidentAngle = originalAngle; // æ¢å¤åŸå§‹è§’åº¦
            });
            
            // ç»˜åˆ¶å…‰è°±
            if (progress > 0.8 && (currentStep === 0 || currentStep === 5)) {
                const spectrumX = prism.rightX + 50;
                const spectrumY = prism.rightY;
                const spectrumWidth = 200;
                const spectrumHeight = 150;
                
                // å…‰è°±èƒŒæ™¯
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(spectrumX, spectrumY - spectrumHeight/2, spectrumWidth, spectrumHeight);
                
                // æ¸å˜å…‰è°±
                const gradient = ctx.createLinearGradient(
                    spectrumX, spectrumY - spectrumHeight/2,
                    spectrumX + spectrumWidth, spectrumY - spectrumHeight/2
                );
                
                gradient.addColorStop(0, colors.red);
                gradient.addColorStop(1/6, colors.orange);
                gradient.addColorStop(2/6, colors.yellow);
                gradient.addColorStop(3/6, colors.green);
                gradient.addColorStop(4/6, colors.blue);
                gradient.addColorStop(5/6, colors.indigo);
                gradient.addColorStop(1, colors.violet);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(spectrumX + 10, spectrumY - spectrumHeight/2 + 10, 
                           spectrumWidth - 20, spectrumHeight - 20);
                
                // å…‰è°±æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const labels = ['çº¢', 'æ©™', 'é»„', 'ç»¿', 'è“', 'é›', 'ç´«'];
                for (let i = 0; i < 7; i++) {
                    ctx.fillText(labels[i], 
                        spectrumX + 10 + (i * (spectrumWidth - 20) / 6) + (spectrumWidth - 20) / 12,
                        spectrumY + spectrumHeight/2 - 5);
                }
                
                ctx.restore();
            }
        }

        // ç»˜åˆ¶æ³•çº¿å’Œè§’åº¦æ ‡æ³¨
        function drawAnnotations(prism) {
            const { leftX, leftY, topX, topY, rightX, rightY } = prism;
            
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // å·¦ä¾§é¢æ³•çº¿
            const leftMidX = (leftX + topX) / 2;
            const leftMidY = (leftY + topY) / 2;
            const leftNormalLength = 60;
            const leftNormalAngle = Math.atan2(topY - leftY, topX - leftX) + Math.PI / 2;
            
            ctx.beginPath();
            ctx.moveTo(leftMidX, leftMidY);
            ctx.lineTo(
                leftMidX + Math.cos(leftNormalAngle) * leftNormalLength,
                leftMidY + Math.sin(leftNormalAngle) * leftNormalLength
            );
            ctx.stroke();
            
            // æ ‡æ³¨å…¥å°„è§’
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '14px Arial';
            ctx.fillText(`å…¥å°„è§’: ${incidentAngle}Â°`, leftMidX + 80, leftMidY - 30);
            
            ctx.restore();
        }

        // ä¸»ç»˜åˆ¶å‡½æ•°
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ˜Ÿç©ºèƒŒæ™¯
            drawBackground();
            
            // ç»˜åˆ¶ä¸‰æ£±é•œ
            const prism = drawPrism();
            
            // ç»˜åˆ¶æ³•çº¿å’Œæ ‡æ³¨
            drawAnnotations(prism);
            
            // è®¡ç®—åŠ¨ç”»è¿›åº¦
            let progress = 0;
            if (isPlaying) {
                animationTime += 0.016 * animationSpeed; // çº¦60fps
                progress = (Math.sin(animationTime) + 1) / 2; // 0åˆ°1ä¹‹é—´å¾ªç¯
                
                // åˆ†æ­¥æ¨¡å¼ä¸‹ï¼Œè¿›åº¦åªåˆ°å½“å‰æ­¥éª¤
                if (currentStep > 0) {
                    progress = Math.min(progress, currentStep * 0.2);
                }
            } else {
                progress = animationTime;
            }
            
            // æ ¹æ®å…‰æºç±»å‹ç»˜åˆ¶å…‰çº¿
            if (lightType === 'white') {
                drawWhiteLightDispersion(prism, progress);
            } else {
                drawSingleColorLight(prism, lightType, progress);
            }
            
            // æ›´æ–°æ˜¾ç¤ºä¿¡æ¯
            updateDisplayInfo();
        }

        // ç»˜åˆ¶æ˜Ÿç©ºèƒŒæ™¯
        function drawBackground() {
            // æ·±è‰²æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0a0a2a');
            gradient.addColorStop(1, '#1a1a3a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 50; i++) {
                const x = (i * 1234567) % canvas.width;
                const y = (i * 7654321) % canvas.height;
                const size = (i % 3) * 0.5 + 0.5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // æ›´æ–°æ˜¾ç¤ºä¿¡æ¯
        function updateDisplayInfo() {
            document.getElementById('currentAngle').textContent = `${incidentAngle}Â°`;
            document.getElementById('angleValue').textContent = `${incidentAngle}Â°`;
            document.getElementById('prismValue').textContent = `${prismAngle}Â°`;
            document.getElementById('speedValue').textContent = `${animationSpeed.toFixed(1)}x`;
            
            // æ›´æ–°æ¨¡å¼æ˜¾ç¤º
            const modeNames = ['å®Œæ•´æ¼”ç¤º', 'ç™½å…‰å…¥å°„', 'ç¬¬ä¸€æ¬¡æŠ˜å°„', 'æ£±é•œå†…ä¼ æ’­', 'ç¬¬äºŒæ¬¡æŠ˜å°„', 'å½¢æˆå…‰è°±'];
            document.getElementById('currentMode').textContent = modeNames[currentStep];
            
            // æ›´æ–°æŠ˜å°„ç‡ä¿¡æ¯
            if (lightType === 'white') {
                document.getElementById('refractionInfo').innerHTML = 
                    `n(çº¢)=${refractionIndices.red} &lt; n(ç´«)=${refractionIndices.violet}`;
            } else if (lightType === 'red') {
                document.getElementById('refractionInfo').textContent = 
                    `n(çº¢)=${refractionIndices.red}`;
            } else {
                document.getElementById('refractionInfo').textContent = 
                    `n(ç´«)=${refractionIndices.violet}`;
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        function initEventListeners() {
            // åŠ¨ç”»æ§åˆ¶æŒ‰é’®
            document.getElementById('playBtn').addEventListener('click', () => {
                isPlaying = true;
            });
            
            document.getElementById('pauseBtn').addEventListener('click', () => {
                isPlaying = false;
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                animationTime = 0;
                incidentAngle = 45;
                prismAngle = 60;
                animationSpeed = 1.0;
                lightType = 'white';
                currentStep = 0;
                
                // æ›´æ–°UI
                document.getElementById('angleSlider').value = incidentAngle;
                document.getElementById('prismSlider').value = prismAngle;
                document.getElementById('speedSlider').value = animationSpeed;
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.light-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector('.light-btn[data-light="white"]').classList.add('active');
                
                document.querySelectorAll('.step-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector('.step-btn[data-step="0"]').classList.add('active');
            });
            
            // åˆ†æ­¥å­¦ä¹ æŒ‰é’®
            document.querySelectorAll('.step-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const step = parseInt(this.dataset.step);
                    currentStep = step;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.querySelectorAll('.step-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // é‡ç½®åŠ¨ç”»æ—¶é—´
                    animationTime = 0;
                });
            });
            
            // å…‰æºé€‰æ‹©æŒ‰é’®
            document.querySelectorAll('.light-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    lightType = this.dataset.light;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.querySelectorAll('.light-btn').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // é‡ç½®åŠ¨ç”»æ—¶é—´
                    animationTime = 0;
                });
            });
            
            // æ»‘å—æ§åˆ¶
            document.getElementById('angleSlider').addEventListener('input', function() {
                incidentAngle = parseInt(this.value);
                animationTime = 0;
            });
            
            document.getElementById('prismSlider').addEventListener('input', function() {
                prismAngle = parseInt(this.value);
                animationTime = 0;
            });
            
            document.getElementById('speedSlider').addEventListener('input', function() {
                animationSpeed = parseFloat(this.value);
            });
            
            // çŸ¥è¯†æ‰©å±•åˆ‡æ¢
            document.getElementById('knowledgeToggle').add
<!--æ£€æµ‹åˆ°ä»£ç æˆªæ–­ï¼Œè‡ªåŠ¨ç»­å†™ä¸­...-->
            // çŸ¥è¯†æ‰©å±•åˆ‡æ¢
            document.getElementById('knowledgeToggle').addEventListener('click', function() {
                const content = document.getElementById('knowledgeContent');
                content.classList.toggle('active');
                this.textContent = content.classList.contains('active') ? 
                    'ğŸ“š çŸ¥è¯†æ‰©å±• (ç‚¹å‡»æ”¶èµ·)' : 'ğŸ“š çŸ¥è¯†æ‰©å±• (ç‚¹å‡»å±•å¼€)';
            });
            
            // æ‚¬åœæç¤ºæ•ˆæœ
            canvas.addEventListener('mousemove', function(event) {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                
                // ç®€å•çš„åŒºåŸŸæ£€æµ‹ï¼ˆå®é™…åº”ç”¨ä¸­å¯ä»¥æ ¹æ®åæ ‡è®¡ç®—å…·ä½“ä½ç½®ï¼‰
                const prism = drawPrism();
                const prismCenterX = (prism.leftX + prism.topX + prism.rightX) / 3;
                const prismCenterY = (prism.leftY + prism.topY + prism.rightY) / 3;
                
                const distance = Math.sqrt(Math.pow(x - prismCenterX, 2) + Math.pow(y - prismCenterY, 2));
                
                if (distance < 150) {
                    canvas.style.cursor = 'pointer';
                    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´è¯¦ç»†çš„æ‚¬åœæç¤º
                } else {
                    canvas.style.cursor = 'default';
                }
            });
            
            // ç‚¹å‡»ç”»å¸ƒé‡ç½®åŠ¨ç”»
            canvas.addEventListener('click', function() {
                if (!isPlaying) {
                    animationTime = 0;
                }
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            resizeCanvas();
            initEventListeners();
            animate();
            
            // åˆå§‹æ¿€æ´»å®Œæ•´æ¼”ç¤ºæŒ‰é’®
            document.querySelector('.step-btn[data-step="0"]').classList.add('active');
            
            // åˆå§‹æ¿€æ´»ç™½å…‰æŒ‰é’®
            document.querySelector('.light-btn[data-light="white"]').classList.add('active');
            
            console.log('è‰²æ•£ç°è±¡æ•™å­¦åŠ¨ç”»å·²åŠ è½½å®Œæˆï¼');
            console.log('æç¤ºï¼šå°è¯•è°ƒèŠ‚å‚æ•°è§‚å¯Ÿè‰²æ•£æ•ˆæœçš„å˜åŒ–');
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†åŠ¨ç”»
        window.addEventListener('beforeunload', function() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>