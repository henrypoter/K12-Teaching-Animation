<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç†æƒ³æ°”ä½“è¿‡ç¨‹ï¼šp-Vå›¾ä¸åˆ†å­è¿åŠ¨åŒæ­¥æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
            width: 100%;
            max-width: 1200px;
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2rem;
        }

        .subtitle {
            color: #5d6d7e;
            font-size: 1.1rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            width: 100%;
            max-width: 1200px;
            justify-content: center;
        }

        .panel {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
            padding: 25px;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 1.4rem;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-title i {
            font-size: 1.2rem;
        }

        .graph-panel {
            flex: 1;
            min-width: 500px;
        }

        .simulation-panel {
            flex: 1;
            min-width: 500px;
        }

        .control-panel {
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: white;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #e0e6ed;
        }

        canvas {
            display: block;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }

        .process-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .process-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .process-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }

        .process-btn.active {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        #btn-isothermal {
            background-color: #ff9f43;
            color: white;
        }

        #btn-isothermal.active {
            background-color: #e67e22;
        }

        #btn-isobaric {
            background-color: #3498db;
            color: white;
        }

        #btn-isobaric.active {
            background-color: #2980b9;
        }

        #btn-isochoric {
            background-color: #2ecc71;
            color: white;
        }

        #btn-isochoric.active {
            background-color: #27ae60;
        }

        .action-btn {
            padding: 12px 24px;
            background-color: #95a5a6;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .action-btn:hover {
            background-color: #7f8c8d;
            transform: translateY(-2px);
        }

        #btn-reset {
            background-color: #e74c3c;
        }

        #btn-reset:hover {
            background-color: #c0392b;
        }

        .toggle-btn {
            padding: 12px 24px;
            background-color: #9b59b6;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-btn:hover {
            background-color: #8e44ad;
            transform: translateY(-2px);
        }

        .toggle-btn.active {
            background-color: #7d3c98;
        }

        .data-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 25px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .data-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .data-label {
            font-size: 0.9rem;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .data-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2c3e50;
        }

        .data-unit {
            font-size: 1rem;
            color: #7f8c8d;
            margin-left: 5px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-text {
            font-size: 0.9rem;
            color: #5d6d7e;
        }

        .instructions {
            margin-top: 25px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            max-width: 1200px;
            width: 100%;
        }

        .instructions h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .instructions p {
            color: #5d6d7e;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .instructions ul {
            padding-left: 20px;
            color: #5d6d7e;
            line-height: 1.6;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .status-info {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #2c3e50;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .particle-count {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            z-index: 10;
        }

        @media (max-width: 1100px) {
            .container {
                flex-direction: column;
                align-items: center;
            }
            
            .graph-panel, .simulation-panel {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ç†æƒ³æ°”ä½“è¿‡ç¨‹ï¼šp-Vå›¾ä¸åˆ†å­è¿åŠ¨åŒæ­¥æ¼”ç¤º</h1>
        <p class="subtitle">é€šè¿‡äº¤äº’å¼åŠ¨ç”»æ¢ç´¢ç­‰æ¸©ã€ç­‰å‹ã€ç­‰å®¹è¿‡ç¨‹ä¸­å®è§‚çŠ¶æ€ä¸å¾®è§‚åˆ†å­è¿åŠ¨çš„åŒæ­¥å˜åŒ–å…³ç³»</p>
    </div>

    <div class="container">
        <!-- p-Vå›¾é¢æ¿ -->
        <div class="panel graph-panel">
            <div class="panel-title">
                <span>ğŸ“ˆ p-V çŠ¶æ€å›¾</span>
            </div>
            <div class="canvas-container">
                <div class="status-info" id="pv-status">å½“å‰è¿‡ç¨‹ï¼šç­‰æ¸© | æ‹–æ‹½çº¢ç‚¹æ”¹å˜çŠ¶æ€</div>
                <canvas id="pvCanvas" width="800" height="400"></canvas>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff9f43;"></div>
                    <div class="legend-text">ç­‰æ¸©è¿‡ç¨‹ (æ¸©åº¦æ’å®š)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <div class="legend-text">ç­‰å‹è¿‡ç¨‹ (å‹å¼ºæ’å®š)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                    <div class="legend-text">ç­‰å®¹è¿‡ç¨‹ (ä½“ç§¯æ’å®š)</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c; border-radius: 50%;"></div>
                    <div class="legend-text">çŠ¶æ€æ§åˆ¶ç‚¹</div>
                </div>
            </div>
        </div>

        <!-- åˆ†å­è¿åŠ¨æ¨¡æ‹Ÿé¢æ¿ -->
        <div class="panel simulation-panel">
            <div class="panel-title">
                <span>ğŸ”¬ åˆ†å­è¿åŠ¨æ¨¡æ‹Ÿ</span>
            </div>
            <div class="canvas-container">
                <div class="particle-count" id="particle-count">åˆ†å­æ•°: 80</div>
                <canvas id="simCanvas" width="800" height="400"></canvas>
            </div>
            <div class="data-display">
                <div class="data-item">
                    <div class="data-label">å‹å¼º (p)</div>
                    <div class="data-value" id="pressure-value">1.00<span class="data-unit">atm</span></div>
                </div>
                <div class="data-item">
                    <div class="data-label">ä½“ç§¯ (V)</div>
                    <div class="data-value" id="volume-value">1.00<span class="data-unit">L</span></div>
                </div>
                <div class="data-item">
                    <div class="data-label">æ¸©åº¦ (T)</div>
                    <div class="data-value" id="temperature-value">300<span class="data-unit">K</span></div>
                </div>
                <div class="data-item">
                    <div class="data-label">å¹³å‡é€Ÿç‡</div>
                    <div class="data-value" id="speed-value">400<span class="data-unit">m/s</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="panel control-panel">
        <div class="panel-title">
            <span>ğŸ® æ§åˆ¶é¢æ¿</span>
        </div>
        <div class="controls">
            <div class="process-selector">
                <button id="btn-isothermal" class="process-btn active">
                    <span>ğŸŒ¡ï¸</span> ç­‰æ¸©è¿‡ç¨‹ (Tæ’å®š)
                </button>
                <button id="btn-isobaric" class="process-btn">
                    <span>âš–ï¸</span> ç­‰å‹è¿‡ç¨‹ (pæ’å®š)
                </button>
                <button id="btn-isochoric" class="process-btn">
                    <span>ğŸ“¦</span> ç­‰å®¹è¿‡ç¨‹ (Væ’å®š)
                </button>
            </div>
            
            <button id="btn-color" class="toggle-btn">
                <span>ğŸ¨</span> æ˜¾ç¤ºé€Ÿåº¦é¢œè‰²
            </button>
            
            <button id="btn-reset" class="action-btn">
                <span>ğŸ”„</span> é‡ç½®çŠ¶æ€
            </button>
        </div>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜ -->
    <div class="instructions">
        <h3><span>ğŸ“˜</span> ä½¿ç”¨è¯´æ˜</h3>
        <p>æœ¬åŠ¨ç”»æ¼”ç¤ºç†æƒ³æ°”ä½“åœ¨ä¸‰ç§ä¸åŒè¿‡ç¨‹ä¸­å®è§‚çŠ¶æ€ä¸å¾®è§‚åˆ†å­è¿åŠ¨çš„åŒæ­¥å˜åŒ–ï¼š</p>
        <ul>
            <li><strong>ç­‰æ¸©è¿‡ç¨‹ï¼ˆæ©™è‰²ï¼‰</strong>ï¼šæ¸©åº¦æ’å®šã€‚å‹ç¼©æ°”ä½“æ—¶ï¼Œå‹å¼ºå¢åŠ ï¼Œåˆ†å­è¿åŠ¨é€Ÿåº¦ä¸å˜ï¼Œä½†ç¢°æ’é¢‘ç‡å¢åŠ ã€‚</li>
            <li><strong>ç­‰å‹è¿‡ç¨‹ï¼ˆè“è‰²ï¼‰</strong>ï¼šå‹å¼ºæ’å®šã€‚åŠ çƒ­æ°”ä½“æ—¶ï¼Œä½“ç§¯è†¨èƒ€ï¼Œåˆ†å­è¿åŠ¨é€Ÿåº¦åŠ å¿«ï¼Œç¢°æ’é¢‘ç‡åŸºæœ¬ä¸å˜ã€‚</li>
            <li><strong>ç­‰å®¹è¿‡ç¨‹ï¼ˆç»¿è‰²ï¼‰</strong>ï¼šä½“ç§¯æ’å®šã€‚åŠ çƒ­æ°”ä½“æ—¶ï¼Œå‹å¼ºå¢åŠ ï¼Œåˆ†å­è¿åŠ¨é€Ÿåº¦åŠ å¿«ï¼Œç¢°æ’é¢‘ç‡å¢åŠ ã€‚</li>
        </ul>
        <p><strong>äº¤äº’æ“ä½œ</strong>ï¼šé€‰æ‹©è¿‡ç¨‹ç±»å‹åï¼Œåœ¨p-Vå›¾ä¸Šæ‹–æ‹½çº¢è‰²æ§åˆ¶ç‚¹ã€‚è§‚å¯Ÿå³ä¾§åˆ†å­è¿åŠ¨å¦‚ä½•åŒæ­¥å˜åŒ–ï¼Œä»¥åŠå‚æ•°æ•°å€¼çš„å®æ—¶æ›´æ–°ã€‚</p>
        <p><strong>é€Ÿåº¦é¢œè‰²</strong>ï¼šå¯ç”¨"æ˜¾ç¤ºé€Ÿåº¦é¢œè‰²"åï¼Œåˆ†å­å°†æ ¹æ®é€Ÿåº¦ç€è‰²ï¼ˆè“è‰²=æ…¢ï¼Œé»„è‰²=å¿«ï¼‰ã€‚</p>
    </div>

    <script>
        // å…¨å±€å˜é‡å’Œå¸¸é‡
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const PARTICLE_COUNT = 80;
        const INITIAL_PRESSURE = 1.0; // atm
        const INITIAL_VOLUME = 1.0;   // L
        const INITIAL_TEMP = 300;     // K
        const GAS_CONSTANT = 0.0821;  // LÂ·atm/(molÂ·K)ï¼Œç”¨äºè®¡ç®—

        // å½“å‰çŠ¶æ€
        let currentProcess = 'isothermal'; // 'isothermal', 'isobaric', 'isochoric'
        let pressure = INITIAL_PRESSURE;
        let volume = INITIAL_VOLUME;
        let temperature = INITIAL_TEMP;
        let showSpeedColor = true;
        
        // p-Vå›¾çŠ¶æ€
        let pvStatePoint = { x: 0, y: 0 };
        let isDragging = false;
        let processHistory = [];
        
        // åˆ†å­æ¨¡æ‹ŸçŠ¶æ€
        let particles = [];
        let containerWidth = 0;
        let containerHeight = 0;
        let containerX = 0;
        let containerY = 0;
        
        // è·å–Canvaså…ƒç´ å’Œä¸Šä¸‹æ–‡
        const pvCanvas = document.getElementById('pvCanvas');
        const pvCtx = pvCanvas.getContext('2d');
        const simCanvas = document.getElementById('simCanvas');
        const simCtx = simCanvas.getContext('2d');
        
        // è·å–UIå…ƒç´ 
        const pvStatus = document.getElementById('pv-status');
        const pressureValue = document.getElementById('pressure-value');
        const volumeValue = document.getElementById('volume-value');
        const temperatureValue = document.getElementById('temperature-value');
        const speedValue = document.getElementById('speed-value');
        const particleCountElement = document.getElementById('particle-count');
        
        // åˆå§‹åŒ–p-Vå›¾åæ ‡è½¬æ¢
        const pvMargin = { top: 50, right: 50, bottom: 60, left: 70 };
        const pvWidth = CANVAS_WIDTH - pvMargin.left - pvMargin.right;
        const pvHeight = CANVAS_HEIGHT - pvMargin.top - pvMargin.bottom;
        
        // ä½“ç§¯å’Œå‹å¼ºèŒƒå›´
        const volumeRange = { min: 0.5, max: 2.0 };
        const pressureRange = { min: 0.5, max: 2.0 };
        
        // åˆå§‹åŒ–å‡½æ•°
        function init() {
            // è®¾ç½®Canvaså°ºå¯¸
            pvCanvas.width = CANVAS_WIDTH;
            pvCanvas.height = CANVAS_HEIGHT;
            simCanvas.width = CANVAS_WIDTH;
            simCanvas.height = CANVAS_HEIGHT;
            
            // åˆå§‹åŒ–p-Vå›¾çŠ¶æ€ç‚¹
            updateStatePointFromPV();
            
            // åˆå§‹åŒ–åˆ†å­æ¨¡æ‹Ÿå®¹å™¨
            containerWidth = CANVAS_WIDTH * 0.8;
            containerHeight = CANVAS_HEIGHT * 0.7;
            containerX = (CANVAS_WIDTH - containerWidth) / 2;
            containerY = (CANVAS_HEIGHT - containerHeight) / 2;
            
            // åˆ›å»ºç²’å­
            particles = [];
            const baseSpeed = calculateBaseSpeed();
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(createParticle(baseSpeed));
            }
            
            // ç»˜åˆ¶åˆå§‹çŠ¶æ€
            drawPVGraph();
            drawSimulation();
            updateDataDisplay();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // è¿‡ç¨‹é€‰æ‹©æŒ‰é’®
            document.getElementById('btn-isothermal').addEventListener('click', () => setProcess('isothermal'));
            document.getElementById('btn-isobaric').addEventListener('click', () => setProcess('isobaric'));
            document.getElementById('btn-isochoric').addEventListener('click', () => setProcess('isochoric'));
            
            // é¢œè‰²åˆ‡æ¢æŒ‰é’®
            document.getElementById('btn-color').addEventListener('click', function() {
                showSpeedColor = !showSpeedColor;
                this.classList.toggle('active');
                this.innerHTML = showSpeedColor ? '<span>ğŸ¨</span> æ˜¾ç¤ºé€Ÿåº¦é¢œè‰²' : '<span>ğŸ¨</span> éšè—é€Ÿåº¦é¢œè‰²';
                drawSimulation();
            });
            
            // é‡ç½®æŒ‰é’®
            document.getElementById('btn-reset').addEventListener('click', resetState);
            
            // p-Vå›¾äº¤äº’
            pvCanvas.addEventListener('mousedown', handleMouseDown);
            pvCanvas.addEventListener('mousemove', handleMouseMove);
            pvCanvas.addEventListener('mouseup', handleMouseUp);
            pvCanvas.addEventListener('touchstart', handleTouchStart);
            pvCanvas.addEventListener('touchmove', handleTouchMove);
            pvCanvas.addEventListener('touchend', handleTouchEnd);
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', function() {
                drawPVGraph();
                drawSimulation();
            });
        }
        
        // è®¾ç½®å½“å‰è¿‡ç¨‹
        function setProcess(process) {
            currentProcess = process;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('btn-isothermal').classList.remove('active');
            document.getElementById('btn-isobaric').classList.remove('active');
            document.getElementById('btn-isochoric').classList.remove('active');
            document.getElementById(`btn-${process}`).classList.add('active');
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            const processNames = {
                'isothermal': 'ç­‰æ¸©',
                'isobaric': 'ç­‰å‹',
                'isochoric': 'ç­‰å®¹'
            };
            pvStatus.textContent = `å½“å‰è¿‡ç¨‹ï¼š${processNames[process]} | æ‹–æ‹½çº¢ç‚¹æ”¹å˜çŠ¶æ€`;
            
            // é‡æ–°ç»˜åˆ¶p-Vå›¾
            drawPVGraph();
        }
        
        // é‡ç½®çŠ¶æ€
        function resetState() {
            pressure = INITIAL_PRESSURE;
            volume = INITIAL_VOLUME;
            temperature = INITIAL_TEMP;
            processHistory = [];
            updateStatePointFromPV();
            updateParticlesFromState();
            drawPVGraph();
            drawSimulation();
            updateDataDisplay();
        }
        
        // ä»på’ŒVæ›´æ–°çŠ¶æ€ç‚¹åæ ‡
        function updateStatePointFromPV() {
            pvStatePoint.x = pvMargin.left + ((volume - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
            pvStatePoint.y = pvMargin.top + pvHeight - ((pressure - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
        }
        
        // ä»çŠ¶æ€ç‚¹åæ ‡æ›´æ–°på’ŒV
        function updatePVFromStatePoint() {
            // è®¡ç®—åŸå§‹ä½“ç§¯å’Œå‹å¼º
            let newVolume = volumeRange.min + ((pvStatePoint.x - pvMargin.left) / pvWidth) * (volumeRange.max - volumeRange.min);
            let newPressure = pressureRange.min + ((pvHeight - (pvStatePoint.y - pvMargin.top)) / pvHeight) * (pressureRange.max - pressureRange.min);
            
            // æ ¹æ®å½“å‰è¿‡ç¨‹çº¦æŸè°ƒæ•´
            switch(currentProcess) {
                case 'isothermal':
                    // pV = å¸¸æ•° (ç»æ„è€³å®šå¾‹)
                    const constant = pressure * volume;
                    newPressure = constant / newVolume;
                    temperature = INITIAL_TEMP; // æ¸©åº¦æ’å®š
                    break;
                    
                case 'isobaric':
                    // V/T = å¸¸æ•° (ç›–-å•è¨å…‹å®šå¾‹)
                    newPressure = pressure; // å‹å¼ºæ’å®š
                    temperature = (newVolume / volume) * temperature;
                    break;
                    
                case 'isochoric':
                    // p/T = å¸¸æ•° (æŸ¥ç†å®šå¾‹)
                    newVolume = volume; // ä½“ç§¯æ’å®š
                    temperature = (newPressure / pressure) * temperature;
                    break;
            }
            
            // é™åˆ¶èŒƒå›´
            volume = Math.max(volumeRange.min, Math.min(volumeRange.max, newVolume));
            pressure = Math.max(pressureRange.min, Math.min(pressureRange.max, newPressure));
            temperature = Math.max(200, Math.min(500, temperature));
            
            // æ›´æ–°çŠ¶æ€ç‚¹ä½ç½®ï¼ˆè€ƒè™‘çº¦æŸåï¼‰
            updateStatePointFromPV();
            
            // æ›´æ–°ç²’å­æ¨¡æ‹Ÿ
            updateParticlesFromState();
            
            // æ›´æ–°æ•°æ®æ˜¾ç¤º
            updateDataDisplay();
        }
        
        // æ ¹æ®çŠ¶æ€æ›´æ–°ç²’å­
        function updateParticlesFromState() {
            // æ›´æ–°å®¹å™¨å¤§å°ï¼ˆæ ¹æ®ä½“ç§¯ï¼‰
            const volumeRatio = volume / INITIAL_VOLUME;
            containerWidth = CANVAS_WIDTH * 0.8 * Math.sqrt(volumeRatio); // å‡è®¾äºŒç»´ï¼Œæ‰€ä»¥ç”¨å¹³æ–¹æ ¹
            containerHeight = CANVAS_HEIGHT * 0.7 * Math.sqrt(volumeRatio);
            containerX = (CANVAS_WIDTH - containerWidth) / 2;
            containerY = (CANVAS_HEIGHT - containerHeight) / 2;
            
            // æ›´æ–°ç²’å­é€Ÿåº¦ï¼ˆæ ¹æ®æ¸©åº¦ï¼‰
            const baseSpeed = calculateBaseSpeed();
            const speedRatio = baseSpeed / calculateBaseSpeed(INITIAL_TEMP);
            
            for (let particle of particles) {
                // è°ƒæ•´é€Ÿåº¦
                particle.vx *= speedRatio;
                particle.vy *= speedRatio;
                
                // ç¡®ä¿ç²’å­åœ¨å®¹å™¨å†…
                particle.x = Math.max(containerX + particle.radius, 
                                     Math.min(containerX + containerWidth - particle.radius, particle.x));
                particle.y = Math.max(containerY + particle.radius, 
                                     Math.min(containerY + containerHeight - particle.radius, particle.y));
            }
        }
        
        // è®¡ç®—åŸºç¡€é€Ÿåº¦ï¼ˆä¸æ¸©åº¦å¹³æ–¹æ ¹æˆæ­£æ¯”ï¼‰
        function calculateBaseSpeed(temp = temperature) {
            return 200 + (temp - 200) * 2; // ç®€åŒ–æ¨¡å‹
        }
        
        // åˆ›å»ºç²’å­
        function createParticle(baseSpeed) {
            const speed = baseSpeed * (0.8 + Math.random() * 0.4); // é€Ÿåº¦å˜åŒ–
            const angle = Math.random() * 2 * Math.PI;
            
            return {
                x: containerX + Math.random() * containerWidth,
                y: containerY + Math.random() * containerHeight,
                vx: Math.cos(angle) * speed * 0.05,
                vy: Math.sin(angle) * speed * 0.05,
                radius: 4,
                baseSpeed: speed,
                color: getSpeedColor(speed)
            };
        }
        
        // æ ¹æ®é€Ÿåº¦è·å–é¢œè‰²
        function getSpeedColor(speed) {
            if (!showSpeedColor) return '#3498db';
            
            const minSpeed = calculateBaseSpeed(200);
            const maxSpeed = calculateBaseSpeed(500);
            const ratio = (speed - minSpeed) / (maxSpeed - minSpeed);
            
            // ä»è“è‰²åˆ°é»„è‰²
            const r = Math.floor(50 + ratio * 205);
            const g = Math.floor(100 + ratio * 155);
            const b = Math.floor(205 - ratio * 155);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // ç»˜åˆ¶p-Vå›¾
        function drawPVGraph() {
            // æ¸…ç©ºç”»å¸ƒ
            pvCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ç»˜åˆ¶èƒŒæ™¯
            pvCtx.fillStyle = 'white';
            pvCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ç»˜åˆ¶åæ ‡è½´
            drawAxes();
            
            // ç»˜åˆ¶ç­‰æ¸©çº¿ã€ç­‰å‹çº¿ã€ç­‰å®¹çº¿
            drawProcessLines();
            
            // ç»˜åˆ¶å†å²è½¨è¿¹
            drawProcessHistory();
            
            // ç»˜åˆ¶çŠ¶æ€ç‚¹
            drawStatePoint();
            
            // ç»˜åˆ¶æ ‡é¢˜å’Œæ ‡ç­¾
            drawLabels();
        }
        
        // ç»˜åˆ¶åæ ‡è½´
        function drawAxes() {
            pvCtx.strokeStyle = '#34495e';
            pvCtx.lineWidth = 2;
            
            // ç»˜åˆ¶åæ ‡è½´
            pvCtx.beginPath();
            pvCtx.moveTo(pvMargin.left, pvMargin.top);
            pvCtx.lineTo(pvMargin.left, pvMargin.top + pvHeight);
            pvCtx.lineTo(pvMargin.left + pvWidth, pvMargin.top + pvHeight);
            pvCtx.stroke();
            
            // ç»˜åˆ¶ç®­å¤´
            pvCtx.beginPath();
            pvCtx.moveTo(pvMargin.left, pvMargin.top);
            pvCtx.lineTo(pvMargin.left - 5, pvMargin.top + 10);
            pvCtx.lineTo(pvMargin.left + 5, pvMargin.top + 10);
            pvCtx.closePath();
            pvCtx.fillStyle = '#34495e';
            pvCtx.fill();
            
            pvCtx.beginPath();
            pvCtx.moveTo(pvMargin.left + pvWidth, pvMargin.top + pvHeight);
            pvCtx.lineTo(pvMargin.left + pvWidth - 10, pvMargin.top + pvHeight - 5);
            pvCtx.lineTo(pvMargin.left + pvWidth - 10, pvMargin.top + pvHeight + 5);
            pvCtx.closePath();
            pvCtx.fill();
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            pvCtx.strokeStyle = '#ecf0f1';
            pvCtx.lineWidth = 1;
            
            // å‚ç›´ç½‘æ ¼çº¿ï¼ˆä½“ç§¯ï¼‰
            for (let v = volumeRange.min; v <= volumeRange.max; v += 0.25) {
                const x = pvMargin.left + ((v - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
                pvCtx.beginPath();
                pvCtx.moveTo(x, pvMargin.top);
                pvCtx.lineTo(x, pvMargin.top + pvHeight);
                pvCtx.stroke();
            }
            
            // æ°´å¹³ç½‘æ ¼çº¿ï¼ˆå‹å¼ºï¼‰
            for (let p = pressureRange.min; p <= pressureRange.max; p += 0.25) {
                const y = pvMargin.top + pvHeight - ((p - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                pvCtx.beginPath();
                pvCtx.moveTo(pvMargin.left, y);
                pvCtx.lineTo(pvMargin.left + pvWidth, y);
                pvCtx.stroke();
            }
        }
        
        // ç»˜åˆ¶è¿‡ç¨‹çº¿
        function drawProcessLines() {
            // ç­‰æ¸©çº¿ (pV = å¸¸æ•°ï¼ŒåŒæ›²çº¿)
            const isoConstant = INITIAL_PRESSURE * INITIAL_VOLUME;
            pvCtx.strokeStyle = '#ff9f43';
            pvCtx.lineWidth = 2;
            pvCtx.setLineDash([]);
            
            pvCtx.beginPath();
            for (let v = volumeRange.min; v <= volumeRange.max; v += 0.01) {
                const p = isoConstant / v;
                if (p >= pressureRange.min && p <= pressureRange.max) {
                    const x = pvMargin.left + ((v - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
                    const y = pvMargin.top + pvHeight - ((p - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                    
                    if (v === volumeRange.min) {
                        pvCtx.moveTo(x, y);
                    } else {
                        pvCtx.lineTo(x, y);
                    }
                }
            }
            pvCtx.stroke();
            
            // ç­‰å‹çº¿ (æ°´å¹³çº¿)
            pvCtx.strokeStyle = '#3498db';
            pvCtx.beginPath();
            const yIsobaric = pvMargin.top + pvHeight - ((INITIAL_PRESSURE - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
            pvCtx.moveTo(pvMargin.left, yIsobaric);
            pvCtx.lineTo(pvMargin.left + pvWidth, yIsobaric);
            pvCtx.stroke();
            
            // ç­‰å®¹çº¿ (å‚ç›´çº¿)
            pvCtx.strokeStyle = '#2ecc71';
            pvCtx.beginPath();
            const xIsochoric = pvMargin.left + ((INITIAL_VOLUME - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
            pvCtx.moveTo(xIsochoric, pvMargin.top);
            pvCtx.lineTo(xIsochoric, pvMargin.top + pvHeight);
            pvCtx.stroke();
        }
        
        // ç»˜åˆ¶è¿‡ç¨‹å†å²
        function drawProcessHistory() {
            if (processHistory.length < 2) return;
            
            pvCtx.strokeStyle = '#e74c3c';
            pvCtx.lineWidth = 3;
            pvCtx.setLineDash([]);
            
            pvCtx.beginPath();
            pvCtx.moveTo(processHistory[0].x, processHistory[0].y);
            
            for (let i = 1; i < processHistory.length; i++) {
                pvCtx.lineTo(processHistory[i].x, processHistory[i].y);
            }
            
            pvCtx.stroke();
        }
        
        // ç»˜åˆ¶çŠ¶æ€ç‚¹
        function drawStatePoint() {
            // ç»˜åˆ¶å…‰æ™•æ•ˆæœ
            const gradient = pvCtx.createRadialGradient(
                pvStatePoint.x, pvStatePoint.y, 0,
                pvStatePoint.x, pvStatePoint.y, 15
            );
            gradient.addColorStop(0, 'rgba(231, 76, 60, 0.8)');
            gradient.addColorStop(1, 'rgba(231, 76, 60, 0)');
            
            pvCtx.fillStyle = gradient;
            pvCtx.beginPath();
            pvCtx.arc(pvStatePoint.x, pvStatePoint.y, 15, 0, Math.PI * 2);
            pvCtx.fill();
            
            // ç»˜åˆ¶çŠ¶æ€ç‚¹
            pvCtx.fillStyle = '#e74c3c';
            pvCtx.beginPath();
            pvCtx.arc(pvStatePoint.x, pvStatePoint.y, 8, 0, Math.PI * 2);
            pvCtx.fill();
            
            pvCtx.fillStyle = 'white';
            pvCtx.beginPath();
            pvCtx.arc(pvStatePoint.x, pvStatePoint.y, 4, 0, Math.PI * 2);
            pvCtx.fill();
        }
        
        // ç»˜åˆ¶æ ‡ç­¾
        function drawLabels() {
            pvCtx.fillStyle = '#2c3e50';
            pvCtx.font = 'bold 16px Arial';
            pvCtx.textAlign = 'center';
            
            // æ ‡é¢˜
            pvCtx.fillText('ç†æƒ³æ°”ä½“ p-V å›¾', CANVAS_WIDTH / 2, 30);
            
            // åæ ‡è½´æ ‡ç­¾
            pvCtx.save();
            pvCtx.translate(30, pvMargin.top + pvHeight / 2);
            pvCtx.rotate(-Math.PI / 2);
            pvCtx.fillText('å‹å¼º p (atm)', 0, 0);
            pvCtx.restore();
            
            pvCtx.fillText('ä½“ç§¯ V (L)', pvMargin.left + pvWidth / 2, CANVAS_HEIGHT - 20);
            
            // åæ ‡è½´åˆ»åº¦
            pvCtx.font = '12px Arial';
            pvCtx.textAlign = 'center';
            
            // ä½“ç§¯åˆ»åº¦
            for (let v = volumeRange.min; v <= volumeRange.max; v += 0.5) {
                const x = pvMargin.left + ((v - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
                pvCtx.fillText(v.toFixed(1), x, pvMargin.top + pvHeight + 20);
            }
            
            // å‹å¼ºåˆ»åº¦
            pvCtx.textAlign = 'right';
            for (let p = pressureRange.min; p <= pressureRange.max; p += 0.5) {
                const y = pvMargin.top + pvHeight - ((p - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                pvCtx.fillText(p.toFixed(1), pvMargin.left - 10, y + 4);
            }
        }
        
        // ç»˜åˆ¶åˆ†å­æ¨¡æ‹Ÿ
        function drawSimulation() {
            // æ¸…ç©ºç”»å¸ƒ
            simCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ç»˜åˆ¶èƒŒæ™¯
            simCtx.fillStyle = '#1a252f';
            simCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ç»˜åˆ¶å®¹å™¨
            simCtx.strokeStyle = '#7f8c8d';
            simCtx.lineWidth = 3;
            simCtx.strokeRect(containerX, containerY, containerWidth, containerHeight);
            
            // ç»˜åˆ¶æ´»å¡ï¼ˆå¦‚æœæ˜¯ç­‰å‹æˆ–ç­‰æ¸©è¿‡ç¨‹ï¼Œæ˜¾ç¤ºå¯ç§»åŠ¨çš„æ´»å¡ï¼‰

<!--æ£€æµ‹åˆ°ä»£ç æˆªæ–­ï¼Œè‡ªåŠ¨ç»­å†™ä¸­...-->
if (currentProcess === 'isobaric' || currentProcess === 'isothermal') {
                simCtx.fillStyle = 'rgba(189, 195, 199, 0.7)';
                simCtx.fillRect(containerX + containerWidth - 10, containerY, 10, containerHeight);
                simCtx.strokeStyle = '#95a5a6';
                simCtx.lineWidth = 2;
                simCtx.strokeRect(containerX + containerWidth - 10, containerY, 10, containerHeight);
                
                // æ´»å¡æ‰‹æŸ„
                simCtx.fillStyle = '#e74c3c';
                simCtx.fillRect(containerX + containerWidth - 15, containerY + containerHeight/2 - 20, 5, 40);
            }
            
            // æ›´æ–°å¹¶ç»˜åˆ¶ç²’å­
            updateParticles();
            
            // ç»˜åˆ¶ç²’å­
            for (let particle of particles) {
                // æ›´æ–°é¢œè‰²ï¼ˆå¦‚æœé€Ÿåº¦é¢œè‰²æ˜¾ç¤ºå¼€å¯ï¼‰
                if (showSpeedColor) {
                    particle.color = getSpeedColor(Math.sqrt(particle.vx*particle.vx + particle.vy*particle.vy) * 20);
                }
                
                // ç»˜åˆ¶ç²’å­
                simCtx.fillStyle = particle.color;
                simCtx.beginPath();
                simCtx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                simCtx.fill();
                
                // å¯é€‰ï¼šç»˜åˆ¶é€Ÿåº¦è½¨è¿¹
                if (Math.random() < 0.3) {
                    simCtx.strokeStyle = particle.color + '80';
                    simCtx.lineWidth = 1;
                    simCtx.beginPath();
                    simCtx.moveTo(particle.x, particle.y);
                    simCtx.lineTo(particle.x - particle.vx * 5, particle.y - particle.vy * 5);
                    simCtx.stroke();
                }
            }
            
            // ç»˜åˆ¶å®¹å™¨æ ‡ç­¾
            simCtx.fillStyle = '#ecf0f1';
            simCtx.font = '14px Arial';
            simCtx.textAlign = 'center';
            simCtx.fillText('ç†æƒ³æ°”ä½“åˆ†å­è¿åŠ¨æ¨¡æ‹Ÿ', CANVAS_WIDTH / 2, 30);
            
            // ç»˜åˆ¶è¿‡ç¨‹è¯´æ˜
            let processText = '';
            switch(currentProcess) {
                case 'isothermal': processText = 'ç­‰æ¸©è¿‡ç¨‹ï¼šæ¸©åº¦æ’å®šï¼Œåˆ†å­é€Ÿåº¦ä¸å˜'; break;
                case 'isobaric': processText = 'ç­‰å‹è¿‡ç¨‹ï¼šå‹å¼ºæ’å®šï¼Œåˆ†å­é€Ÿåº¦å˜åŒ–'; break;
                case 'isochoric': processText = 'ç­‰å®¹è¿‡ç¨‹ï¼šä½“ç§¯æ’å®šï¼Œåˆ†å­é€Ÿåº¦å˜åŒ–'; break;
            }
            simCtx.font = 'italic 13px Arial';
            simCtx.fillText(processText, CANVAS_WIDTH / 2, CANVAS_HEIGHT - 20);
        }
        
        // æ›´æ–°ç²’å­ä½ç½®
        function updateParticles() {
            const baseSpeed = calculateBaseSpeed();
            let totalSpeed = 0;
            
            for (let particle of particles) {
                // æ›´æ–°ä½ç½®
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // è®¡ç®—é€Ÿåº¦ç”¨äºæ˜¾ç¤º
                const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                totalSpeed += speed;
                
                // è¾¹ç•Œç¢°æ’æ£€æµ‹
                if (particle.x <= containerX + particle.radius || particle.x >= containerX + containerWidth - particle.radius) {
                    particle.vx = -particle.vx;
                    particle.x = Math.max(containerX + particle.radius, 
                                         Math.min(containerX + containerWidth - particle.radius, particle.x));
                }
                
                if (particle.y <= containerY + particle.radius || particle.y >= containerY + containerHeight - particle.radius) {
                    particle.vy = -particle.vy;
                    particle.y = Math.max(containerY + particle.radius, 
                                         Math.min(containerY + containerHeight - particle.radius, particle.y));
                }
                
                // ç²’å­é—´ç¢°æ’ï¼ˆç®€åŒ–ç‰ˆï¼‰
                for (let other of particles) {
                    if (particle === other) continue;
                    
                    const dx = other.x - particle.x;
                    const dy = other.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < particle.radius + other.radius) {
                        // ç®€å•å¼¹æ€§ç¢°æ’ååº”
                        const angle = Math.atan2(dy, dx);
                        const targetX = particle.x + Math.cos(angle) * (particle.radius + other.radius);
                        const targetY = particle.y + Math.sin(angle) * (particle.radius + other.radius);
                        
                        const ax = (targetX - other.x) * 0.05;
                        const ay = (targetY - other.y) * 0.05;
                        
                        particle.vx -= ax;
                        particle.vy -= ay;
                        other.vx += ax;
                        other.vy += ay;
                    }
                }
                
                // é™åˆ¶æœ€å¤§é€Ÿåº¦
                const maxSpeed = baseSpeed * 0.08;
                const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                if (currentSpeed > maxSpeed) {
                    particle.vx = (particle.vx / currentSpeed) * maxSpeed;
                    particle.vy = (particle.vy / currentSpeed) * maxSpeed;
                }
            }
            
            // æ›´æ–°å¹³å‡é€Ÿåº¦æ˜¾ç¤º
            const avgSpeed = (totalSpeed / particles.length) * 20; // è½¬æ¢ä¸ºm/sé‡çº§
            speedValue.textContent = Math.round(avgSpeed);
        }
        
        // æ›´æ–°æ•°æ®æ˜¾ç¤º
        function updateDataDisplay() {
            pressureValue.innerHTML = `${pressure.toFixed(2)}<span class="data-unit">atm</span>`;
            volumeValue.innerHTML = `${volume.toFixed(2)}<span class="data-unit">L</span>`;
            temperatureValue.innerHTML = `${Math.round(temperature)}<span class="data-unit">K</span>`;
            
            // æ›´æ–°ç²’å­è®¡æ•°æ˜¾ç¤º
            particleCountElement.textContent = `åˆ†å­æ•°: ${PARTICLE_COUNT}`;
        }
        
        // é¼ æ ‡äº‹ä»¶å¤„ç†
        function handleMouseDown(e) {
            const rect = pvCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†çŠ¶æ€ç‚¹
            const distance = Math.sqrt((x - pvStatePoint.x) ** 2 + (y - pvStatePoint.y) ** 2);
            if (distance <= 15) {
                isDragging = true;
                pvCanvas.style.cursor = 'grabbing';
                
                // è®°å½•åˆå§‹çŠ¶æ€
                if (processHistory.length === 0) {
                    processHistory.push({x: pvStatePoint.x, y: pvStatePoint.y});
                }
            }
        }
        
        function handleMouseMove(e) {
            if (!isDragging) return;
            
            const rect = pvCanvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            // é™åˆ¶åœ¨p-Vå›¾åŒºåŸŸå†…
            x = Math.max(pvMargin.left, Math.min(pvMargin.left + pvWidth, x));
            y = Math.max(pvMargin.top, Math.min(pvMargin.top + pvHeight, y));
            
            // æ ¹æ®å½“å‰è¿‡ç¨‹çº¦æŸç§»åŠ¨
            switch(currentProcess) {
                case 'isothermal':
                    // æ²¿ç­‰æ¸©çº¿ç§»åŠ¨ï¼ˆåŒæ›²çº¿ï¼‰
                    const isoConstant = INITIAL_PRESSURE * INITIAL_VOLUME;
                    const v = volumeRange.min + ((x - pvMargin.left) / pvWidth) * (volumeRange.max - volumeRange.min);
                    const p = isoConstant / v;
                    y = pvMargin.top + pvHeight - ((p - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                    break;
                    
                case 'isobaric':
                    // æ°´å¹³ç§»åŠ¨
                    y = pvMargin.top + pvHeight - ((INITIAL_PRESSURE - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                    break;
                    
                case 'isochoric':
                    // å‚ç›´ç§»åŠ¨
                    x = pvMargin.left + ((INITIAL_VOLUME - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
                    break;
            }
            
            // æ›´æ–°çŠ¶æ€ç‚¹
            pvStatePoint.x = x;
            pvStatePoint.y = y;
            
            // æ›´æ–°ç‰©ç†çŠ¶æ€
            updatePVFromStatePoint();
            
            // æ·»åŠ åˆ°å†å²è½¨è¿¹
            processHistory.push({x: pvStatePoint.x, y: pvStatePoint.y});
            
            // é‡ç»˜
            drawPVGraph();
            drawSimulation();
        }
        
        function handleMouseUp() {
            if (isDragging) {
                isDragging = false;
                pvCanvas.style.cursor = 'default';
            }
        }
        
        // è§¦æ‘¸äº‹ä»¶å¤„ç†ï¼ˆç§»åŠ¨è®¾å¤‡æ”¯æŒï¼‰
        function handleTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const rect = pvCanvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                const distance = Math.sqrt((x - pvStatePoint.x) ** 2 + (y - pvStatePoint.y) ** 2);
                if (distance <= 20) {
                    isDragging = true;
                    
                    if (processHistory.length === 0) {
                        processHistory.push({x: pvStatePoint.x, y: pvStatePoint.y});
                    }
                }
            }
        }
        
        function handleTouchMove(e) {
            if (!isDragging || e.touches.length !== 1) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = pvCanvas.getBoundingClientRect();
            let x = touch.clientX - rect.left;
            let y = touch.clientY - rect.top;
            
            x = Math.max(pvMargin.left, Math.min(pvMargin.left + pvWidth, x));
            y = Math.max(pvMargin.top, Math.min(pvMargin.top + pvHeight, y));
            
            switch(currentProcess) {
                case 'isothermal':
                    const isoConstant = INITIAL_PRESSURE * INITIAL_VOLUME;
                    const v = volumeRange.min + ((x - pvMargin.left) / pvWidth) * (volumeRange.max - volumeRange.min);
                    const p = isoConstant / v;
                    y = pvMargin.top + pvHeight - ((p - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                    break;
                    
                case 'isobaric':
                    y = pvMargin.top + pvHeight - ((INITIAL_PRESSURE - pressureRange.min) / (pressureRange.max - pressureRange.min)) * pvHeight;
                    break;
                    
                case 'isochoric':
                    x = pvMargin.left + ((INITIAL_VOLUME - volumeRange.min) / (volumeRange.max - volumeRange.min)) * pvWidth;
                    break;
            }
            
            pvStatePoint.x = x;
            pvStatePoint.y = y;
            
            updatePVFromStatePoint();
            processHistory.push({x: pvStatePoint.x, y: pvStatePoint.y});
            
            drawPVGraph();
            drawSimulation();
        }
        
        function handleTouchEnd(e) {
            if (isDragging) {
                isDragging = false;
            }
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            drawSimulation();
            requestAnimationFrame(animate);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', function() {
            init();
            animate();
        });
    </script>
</body>
</html>